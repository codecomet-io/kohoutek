{"version":3,"file":"ingester.js","sourceRoot":"/","sources":["lib/ingester.ts"],"names":[],"mappings":"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","sourcesContent":["import {bool, int, uint64} from \"codecomet-js/source/buildkit-port/dependencies/golang/mock.js\";\nimport {digest} from \"codecomet-js/source/buildkit-port/dependencies/opencontainers/go-digest.js\";\nimport {Types} from \"codecomet-js/source/protobuf/types.js\";\nimport {\n    SolveStatus,\n    Vertex,\n    VertexLog,\n} from \"codecomet-js/source/buildkit-port/client/graph.js\"\nimport { createId } from './helper.js';\nimport * as model from \"./model.js\";\nimport {ActionStatus, BuildActionsObject, BuildPipeline, ActionsInfo, Stack, User, Repository} from \"./model.js\";\nimport * as readline from 'node:readline/promises';\nimport {ReadStream} from \"tty\";\n\nimport * as Sentry from \"@sentry/node\";\nimport \"@sentry/tracing\";\nimport {createHash} from \"node:crypto\";\n\nclass Build implements BuildPipeline {\n    id = \"github.com/codecomet-io/reporter-elastic/plan.js\"\n    name = \"User defined name\"\n    description = \"This is our super test plan, and guess what this description can change at any time\"\n    runID = \"\"\n    started = 0\n    completed = 0\n    status = model.PipelineStatus.Completed\n    runtime = 0\n    machineTime = 0\n    trigger = \"manual\"\n    actionsObject: BuildActionsObject = {}\n    actionsInfo: ActionsInfo = {\n        total: 0,\n        cached: 0,\n        ran: 0,\n        errored: 0,\n        interrupted: 0,\n        notRan: 0,\n    }\n    // disable repository output for now\n    // it leaks info and isn't currently needed\n    // repository = {\n    //     commit: \"\",\n    //     author: \"\",\n    //     parent: \"\",\n    //     dirty: false,\n    //     location: \"\",\n    // }\n    actor: User = {\n        id: \"spacedub\",\n        name: \"Space Raccoon\"\n    }\n    // disable host output for now\n    // it creates a lot of noise and isn't currently needed\n    // host = new model.Host(\"host-unique-id\", {\n    //     label1: \"foo\",\n    //     label2: \"bar\",\n    // })\n\n    addLog(log: VertexLog) {\n        if (this.actionsObject[log.Vertex] == null) {\n            throw new Error(\"Logs without a registered vertex - panic\")\n        }\n\n        if (this.actionsObject[log.Vertex].stdout == undefined) {\n            this.actionsObject[log.Vertex].stdout = []\n        }\n\n        if (this.actionsObject[log.Vertex].stderr == undefined) {\n            this.actionsObject[log.Vertex].stderr = []\n        }\n\n        let dt = Buffer.from(log.Data.toString(), \"base64\").toString(\"utf-8\").trim()\n        if (dt != \"\") {\n            // Structured stack traces are transmitted in a data url form\n            if (dt.startsWith(\"data:application/json;base64,\")) {\n                // Decode it, parse it\n                let structured = JSON.parse(Buffer.from(dt.substring(dt.indexOf(\",\") + 1), \"base64\").toString(\"utf-8\"))\n                // Copy that over into a Structured type\n                this.actionsObject[log.Vertex].stack = {\n                    timestamp: Date.parse(log.Timestamp),\n                    lineNumber: parseInt(structured.linenumber, 10) - 1,\n                    exitCode: parseInt(structured.exitcode, 10),\n                    command: structured.command,\n                    // Source is double encoded, so, decode it, and split by line to facilitate accessing source[linenumber]\n                    source: Buffer.from(structured.source, \"base64\").toString(\"utf-8\").split(\"\\n\"),\n                }\n            } else if (log.Stream == 2){\n                this.actionsObject[log.Vertex].stderr.push({\n                    timestamp: Date.parse(log.Timestamp),\n                    line: dt\n                })\n            } else {\n                this.actionsObject[log.Vertex].stdout.push({\n                    timestamp: Date.parse(log.Timestamp),\n                    line: dt\n                })\n            }\n        }\n    }\n\n    addVertex(vertice: Vertex){\n        if (!vertice.Digest) {\n            throw new Error(\"Missing digest\" + vertice)\n        }\n\n        if (!vertice.Name) {\n            throw new Error(\"Missing name\" + vertice)\n        }\n\n        // Some actions are hidden away - either CodeComet internal shenanigans, or actions authors who want to hide their own internal dance\n        if (vertice.ProgressGroup && vertice.ProgressGroup.weak == true) {\n            return\n        }\n\n        // Currently, BK leaks internal operations. The right solution is to finish replacing the default client with our own. Short term, very dirty hack by ignoring anything that starts with \"[auth] \"\n        if (vertice.Name.startsWith(\"[auth] \")){\n            return\n        }\n\n        if (!this.actionsObject[vertice.Digest]) {\n            let action = <model.BuildAction>{\n                id : createId('html'),\n                name: vertice.Name,\n                digest: vertice.Digest,\n                cached: false,\n                status: ActionStatus.Ignored,\n            }\n\n            if (vertice.Inputs) {\n                action.buildParents = vertice.Inputs\n            }\n\n            this.actionsObject[vertice.Digest] = action\n        }\n\n        if (vertice.Started){\n            this.actionsObject[vertice.Digest].started = Date.parse(vertice.Started)\n            // this.actionsObject[vertice.Digest].datestamp = new Date(Date.parse(vertice.Started)).toISOString()\n            if (!this.started || this.actionsObject[vertice.Digest].started < this.started) {\n                this.started = this.actionsObject[vertice.Digest].started\n                // this.datestamp = new Date(this.timestamp).toISOString()\n                // Temporary hack to create unique Descriptions for each Report - obviously needs to be undone\n                this.description = \"Some Pipeline\" //  + this.Report.Started.toString().slice(-4)\n            }\n            this.actionsObject[vertice.Digest].status = ActionStatus.Started\n        }\n        if (vertice.Completed){\n            this.actionsObject[vertice.Digest].completed = Date.parse(vertice.Completed)\n            this.actionsObject[vertice.Digest].runtime = this.actionsObject[vertice.Digest].completed - this.actionsObject[vertice.Digest].started\n            this.actionsObject[vertice.Digest].status = ActionStatus.Completed\n        }\n        if (vertice.Error){\n            this.actionsObject[vertice.Digest].error = vertice.Error\n            this.actionsObject[vertice.Digest].status = ActionStatus.Errored\n        }\n        if (vertice.Cached) {\n            this.actionsObject[vertice.Digest].cached = true\n            this.actionsObject[vertice.Digest].status = ActionStatus.Cached\n        }\n    }\n\n    wrap() {\n        const actionKeys = Object.keys(this.actionsObject)\n\n        this.actionsInfo = this.parseActionsInfo(actionKeys, this.actionsObject)\n\n        // if any action errored, the pipeline errored\n        if (actionKeys.some((key) => this.actionsObject[key].error)) {\n            this.status = model.PipelineStatus.Errored\n        } else if (!actionKeys.some((key) => this.actionsObject[key].completed)) { // if any action didn't complete, and we have NOT errored, it means we got cancelled\n            this.status = model.PipelineStatus.Cancelled\n        }\n\n        actionKeys.forEach((key) => {\n            // If there is a more recent finish time, use it\n            if (!this.completed || this.actionsObject[key].completed > this.completed) {\n                this.completed = this.actionsObject[key].completed\n            }\n        })\n\n        let mt: int = 0\n\n        actionKeys\n            .filter((key) => this.actionsObject[key].started && this.actionsObject[key].completed)\n            .forEach((key) => mt += this.actionsObject[key].completed - this.actionsObject[key].started)\n\n        this.machineTime = mt\n        this.runtime = this.completed - this.started\n\n        // FakeID it for now\n        this.runID = 'sha256:' + createHash('sha256')\n            .update(Math.random().toString())\n            .digest('hex')\n\n    }\n\n    parseActionsInfo(actionKeys : string[], actionsObject : model.BuildActionsObject) : model.ActionsInfo {\n        // Total is easy\n        const total = actionKeys.length\n\n        // Cached is easy\n        const cached = actionKeys\n            .filter((key) => actionsObject[key].cached)\n            .length\n\n        // Errored is easy\n        const errored = actionKeys\n            .filter((key) => actionsObject[key].error)\n            .length\n\n        // Not ran have not started\n        const notRan = actionKeys\n            .filter((key) => !actionsObject[key].started)\n            .length\n\n        // Ran have started, not cached, not errored, finished\n        const ran = actionKeys\n            .filter((key) =>\n                actionsObject[key].started\n                && !actionsObject[key].cached\n                && !actionsObject[key].error\n                && actionsObject[key].completed\n            )\n            .length\n\n        // Interrupted has started, not cached, not errored, never finished\n        const interrupted = actionKeys\n            .filter((key) =>\n                actionsObject[key].started\n                && !actionsObject[key].cached\n                && !actionsObject[key].error\n                && !actionsObject[key].completed\n            )\n            .length\n\n        return {\n            total,\n            cached,\n            errored,\n            notRan,\n            ran,\n            interrupted,\n        }\n    }\n}\n\n\n// Purpose of this is to suck out the info out of console colored output\n// Hang-on to your butt\nfunction parseLogEntry(line) {\n    let prior = 0\n    let original = line.line\n    let hasCommand = false\n    let hasOutput = false\n    let command = \"\"\n    let output = \"\"\n\n    // Match colored console break points\n    line.line.replace(/\\x1B\\x5B[a-z0-9]{3}/g, (match, index, subject) : string => {\n        // If first match, or empty slice, move on\n        if (prior != 0 && (index-prior) != 0){\n            // Get the string then, after a bit of cleanup\n            let sub = subject.substring(prior, index).trim() // .trimLeft(\"▶\").trim()\n            if (sub.charAt(0) == \"▶\")\n                sub = sub.substring(1).trim()\n            // Anything in there?\n            if (sub != \"\"){\n                // If we saw a command prompt, then it is a command\n                if (hasCommand){\n                    command = sub\n                    hasCommand = false\n                }\n                // If we saw an output prompt, then it is output (possibly multi line)\n                if (hasOutput){\n                    output += subject.substring(prior, index) // sub\n                    // splices.push(\"out\", output)\n                    // hasOutput = false\n                }\n                // Have a command prompt, mark it\n                if (sub.trim() == \"command\"){\n                    hasCommand = true\n                }\n                // Have an output prompt, mark it\n                if (sub.trim() == \"output\"){\n                    hasOutput = true\n                }\n            }\n        }\n\n        // Seek\n        prior = index + match.length\n\n        // Whatever\n        return \"\"\n    })\n\n    // Get the tail part and consolidate the output\n    let tail = original.substring(prior).trim()\n\n    let plain = \"\"\n\n    if (hasOutput) {\n        output += original.substring(prior).trim()\n    }\n\n    if (!original.match(/^\\x1B\\x5B[a-z0-9]{3}$/)){\n        if (!command)\n            plain = original\n    }\n\n    return {\n        timestamp: line.timestamp,\n        command: command,\n        output: output,\n        plain: plain\n    }\n}\n\nexport class BuffIngester {\n    private build: Build\n\n    constructor() {\n        this.build = new Build()\n    }\n\n    ingest(buff: Buffer) : BuildPipeline {\n        let transaction = Sentry.startTransaction({\n            op: \"Ingester\",\n            name: \"Data ingesting transaction\",\n        })\n\n        buff.toString().split('\\n').forEach((data) => {\n            // resist badly formatted lines\n            if (data.trim() == '') {\n                return\n            }\n\n            let solveStatus : SolveStatus\n\n            try {\n                solveStatus = <SolveStatus>JSON.parse(data)\n\n                if (solveStatus.Vertexes) {\n                    solveStatus.Vertexes.forEach(this.build.addVertex.bind(this.build))\n                }\n\n                if (solveStatus.Logs) {\n                    solveStatus.Logs.forEach(this.build.addLog.bind(this.build))\n                }\n\n            } catch(e) {\n                Sentry.captureException(e, {\n                    extra: {\n                        data: data\n                    }\n                })\n            }\n        })\n\n        const sortByTimestamp = (a, b) => a.timestamp - b.timestamp\n\n        // Sort the logs and process them into something manageable\n        // let logs = {}\n        Object.values(this.build.actionsObject).forEach(function(action){\n            // Sort stdout\n            if (action.stdout) {\n                action.stdout.sort(sortByTimestamp)\n            }\n\n            // Sort stderr\n            if (action.stderr) {\n                action.stderr.sort(sortByTimestamp)\n            }\n\n            // If we have anything in there\n            if (action.stdout) {\n                // Final form\n                let assembledLogs: model.AssembledLog[] = []\n                // Look into stderr\n                action.stderr.forEach(function (line) {\n                    // If we have a stack trace, just get anything BEFORE\n                    if (!action.stack || action.stack.timestamp > line.timestamp){\n                        // Get the processed form of stderr\n                        let parsedLog = parseLogEntry(line)\n                        // timestamps are not reliable - stdout may be off by a millisecond\n\n                        let enrichedStderrSplitByNewline = parsedLog.output.split(\"\\n\")\n                        let resolved = enrichedStderrSplitByNewline.shift()\n                        let remainingStderrLines = enrichedStderrSplitByNewline.join(\"\\n\")\n\n                        let stdout\n\n                        if (remainingStderrLines === \"\"){\n                            stdout = action.stdout.shift()\n                        }\n\n                        // Stuff it into our AssembledLog entry\n                        if (!parsedLog.plain || assembledLogs.length === 0 ) {\n                            assembledLogs.push({\n                                resolved,\n                                command: parsedLog.command,\n                                timestamp: parsedLog.timestamp,\n                                stdout: stdout?.line,\n                                stderr: remainingStderrLines,\n                                exitCode: 0,\n                            })\n                        } else if (parsedLog.plain != \".\") {\n                            try {\n                                assembledLogs[assembledLogs.length - 1 ].stderr = parsedLog.plain\n                            } catch(e) {\n                                console.warn(\"WTF\", parsedLog, assembledLogs.length)\n                            }\n                        }\n                    }\n                })\n\n                action.assembledLogs = assembledLogs\n            }\n\n            if (action.stack) {\n                action.assembledLogs[action.assembledLogs.length - 1].exitCode = action.stack.exitCode\n            }\n        })\n\n        // post-processing and sending to callback\n        this.build.wrap()\n\n        // Sentry transaction done\n        transaction.finish()\n\n        return this.build\n    }\n}\n"]}