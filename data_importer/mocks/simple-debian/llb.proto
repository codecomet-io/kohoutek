
æ›"ß›£›ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*â›

/codecomet¿Î‹#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Defines the supported color palette, and our color scheme
########################################################################################################################

# Supported color palette
readonly _CC_PV_COLOR_BLACK=0
readonly _CC_PV_COLOR_RED=1
readonly _CC_PV_COLOR_GREEN=2
readonly _CC_PV_COLOR_YELLOW=3
# shellcheck disable=SC2034
readonly _CC_PV_COLOR_BLUE=4
readonly _CC_PV_COLOR_MAGENTA=5
readonly _CC_PV_COLOR_CYAN=6
readonly _CC_PV_COLOR_WHITE=7

# Colors scheme definition - can evidently be customized at runtime by setting these variables to other values from the palette
export CC_COLOR_DEFAULT_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEFAULT_BACK="$_CC_PV_COLOR_BLACK"

export CC_COLOR_BODY="$_CC_PV_COLOR_WHITE"
export CC_COLOR_COMMENT="$_CC_PV_COLOR_CYAN"
export CC_COLOR_HUMPF="$_CC_PV_COLOR_MAGENTA"

# Logger
export CC_COLOR_ERROR_FRONT="$_CC_PV_COLOR_RED"
export CC_COLOR_ERROR_BACK="$_CC_PV_COLOR_WHITE"
export CC_COLOR_WARNING_FRONT="$_CC_PV_COLOR_YELLOW"
export CC_COLOR_WARNING_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_INFO_FRONT="$_CC_PV_COLOR_GREEN"
export CC_COLOR_INFO_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_DEBUG_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEBUG_BACK="$_CC_PV_COLOR_BLACK"

# Tracer
export CC_COLOR_TRACER_HUMPF="$_CC_PV_COLOR_GREEN"
export CC_COLOR_TRACER_COMMAND_LABEL="$_CC_PV_COLOR_BLUE"
export CC_COLOR_TRACER_OUTPUT_LABEL="$_CC_PV_COLOR_RED"
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provide helpers to print colorful text
#
# Depends on:
# defaults.sh
# colors.sh
########################################################################################################################

_cc_private::tput(){
  [ ! "$CC_CAP_HAS_TERM" ] || [ "$CC_CAP_NO_COLOR" != "" ] || tput "$@" 2>/dev/null || true
}

_cc_private::console::inline(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it and pad to 7 chars, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"
}

_cc_private::console(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-7s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    # Otherwise, just a plain front/back
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"

  # Restore console to default before we \n so that we do not leak over into BK timestamp display
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::error(){
  _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_ERROR_BACK" "error" "$@"
}

cc::console::warning(){
  _cc_private::console "$CC_COLOR_WARNING_FRONT" "$CC_COLOR_WARNING_BACK" "warning" "$@"
}

cc::console::info(){
  _cc_private::console "$CC_COLOR_INFO_FRONT" "$CC_COLOR_INFO_BACK" "info" "$@"
}

cc::console::debug(){
  _cc_private::console "$CC_COLOR_DEBUG_FRONT" "$CC_COLOR_DEBUG_BACK" "debug" "$@"
}

cc::console::body(){
  _cc_private::console "$CC_COLOR_BODY" "" "" "$@"
}

cc::console::comment(){
  _cc_private::console "$CC_COLOR_COMMENT" "" "" "$@"
}

cc::console::humpf(){
  _cc_private::console "$CC_COLOR_HUMPF" "" "" "$@"
}

cc::console::reset(){
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::end(){
  _cc_private::tput op
  printf "\n"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Debugger based on socat
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
# logger.sh
########################################################################################################################

# Fancy prompt adapted from https://github.com/pombadev/fancy-linux-prompt/blob/master/LICENSE under MIT License
__powerline() {
    # Unicode symbols
    readonly GIT_NEED_PULL_SYMBOL='‚á£'
    readonly GIT_NEED_PUSH_SYMBOL='‚á°'
    readonly PS_SYMBOL='ü™ê' # üêß‚òÑ'‚ñ∂‚èµ‚ñ∂‚èµ

    # Solarized colorscheme
    readonly BG_BLUE="\\[$(tput setab 4)\\]"
    readonly BG_COLOR5="\\[\\e[48;5;31m\\]"
    readonly BG_COLOR8="\\[\\e[48;5;161m\\]"
    readonly BG_GREEN="\\[$(tput setab 2)\\]"
    readonly BG_RED="\\[$(tput setab 1)\\]"
    readonly FG_BASE3="\\[$(tput setaf 15)\\]"
    readonly FG_BLUE="\\[$(tput setaf 4)\\]"
    readonly FG_COLOR1="\\[\\e[38;5;250m\\]"
    readonly FG_COLOR6="\\[\\e[38;5;31m\\]"
    readonly FG_COLOR9="\\[\\e[38;5;161m\\]"
    readonly FG_GREEN="\\[$(tput setaf 2)\\]"
    readonly FG_RED="\\[$(tput setaf 1)\\]"
    readonly RESET="\\[$(tput sgr0)\\]"

    __git_info() {
        # has a .git directory and a git binary
    	[ -d .git ] || command -v git >/dev/null || return 0

        local aheadN
        local behindN
        local branch
        local marks=""
        local stats

        # get current branch name or short SHA1 hash for detached head
        branch="$(git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --always 2>/dev/null)"
        [ -n "$branch" ] || return 0 # git branch not found

        # how many commits local branch is ahead/behind of remote?
        stats="$(git status --porcelain --branch | grep '^##' | grep -o '\[.\+\]$')"
        aheadN="$(echo "$stats" | grep -o 'ahead \d\+' | grep -o '\d\+')"
        behindN="$(echo "$stats" | grep -o 'behind \d\+' | grep -o '\d\+')"
        [ -n "$aheadN" ] && marks+=" $GIT_NEED_PUSH_SYMBOL$aheadN"
        [ -n "$behindN" ] && marks+=" $GIT_NEED_PULL_SYMBOL$behindN"

        # print the git branch segment without a trailing newline
        # branch is modified?
        if [ -n "$(git status --porcelain)" ]; then
            printf "%s" "${BG_COLOR8}‚ñ∂$RESET$BG_COLOR8 $branch$marks $FG_COLOR9"
        else
            printf "%s" "${BG_BLUE}‚ñ∂$RESET$BG_BLUE $branch$marks $RESET$FG_BLUE"
        fi
    }


    ps1() {
        # Check the exit code of the previous command and display different
        # colors in the prompt accordingly.
        if [ "$?" -eq 0 ]; then
            local BG_EXIT="$BG_GREEN"
            local FG_EXIT="$FG_GREEN"
        else
            local BG_EXIT="$BG_RED"
            local FG_EXIT="$FG_RED"
        fi

        PS1="$FG_COLOR1$BG_COLOR5 CodeComet \\w "
        PS1+="$RESET${FG_COLOR6}"
        PS1+="$(__git_info)"
        PS1+="$BG_EXIT‚ñ∂$RESET"
        PS1+="$BG_EXIT$FG_BASE3 ${PS_SYMBOL} ${RESET}${FG_EXIT}‚ñ∂${RESET} "
    }

    PROMPT_COMMAND=ps1
}

_cc_private::debugger::setup(){
  # Set-up PS1
  cat << EOF > "$CC_TMPFS"/.profile
# export PS1='\[\033[01;32m\]CodeComet\[\033[00m\] \w \$ '
alias l="ls -lA"
source ${BASH_SOURCE[0]}
umask 077
export LSCOLORS=exfxcxdxbxegedabagacad
export CLICOLOR=1

_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Welcome!" printf "You are now debugging your pipeline at the point it stopped.\n"
printf "\n"
#_cc_private::console::inline "$_CC_PV_COLOR_BLACK" "$_CC_PV_COLOR_BLACK" "         " printf ""
printf "Environment, pwd, and filesystem, are exactly as they were when the last action failed.\n"
printf "You can call the following helpers:\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdout" printf "will output your action stdout\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stderr" printf "will output your action stderr\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdex " printf "will output your action exit code\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_action" printf "will output the location of your action script\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Tip           " printf "If you want to re-run your action, just call \\\$(ccdebug_action)\n"

# touch "$CC_TMPFS/.codecomet/connected"
__powerline

EOF

  cat << EOF >> "$CC_TMPFS"/.inputrc
"\e[A": history-search-backward
"\e[B": history-search-forward
set show-all-if-ambiguous on
set completion-ignore-case on

EOF

}

# "on demand
# "Abnormal exit, with non zero grace:
# - start debugger repeatedly, with grace
# - once the other end exits, bail out

# "live", with non zero grace
# - start debugger, with infinity grace
# - if the other end was connected and exited, that is it, end of story
# - if the other end is still running, bring socat forward and wait for the end to exit
# - if there was no other end, we should branch back to the first scenario

# This is called on trap ERR, if a live debugger has been running, and will make a decision to bring it back forward and keep it alive,
# or to drop it
cc::debugger::front(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  cc::logger::debug "[debugger-front] socat is here"
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  cc::logger::debug "[debugger-front] grace is fine"


  # Debugger still live? Bail out if not
  jobs | grep -q -v Done || {
    cc::logger::debug "[debugger-front] no jobs detected. Bailing out."
    return 0
  }

  # Ok, it is live. Do we have a client?
  # XXX unfortunately, this does not work as expected... socat does start the process first, bash sources the files and create the stamp file...
  local lasttry
  local current
  lasttry="$(cat $CC_TMPFS/.codecomet/lasttry 2>/dev/null)" || true
  current="$(date +%s)"
  # The older an unconnected socat could be is 2 seconds - if greater than that, then we definitely have a client
  # However, it is possible that a client has been connected for less than 2 seconds (since socat call) when the failure happens,
  # which means the client will wrongly get the boot... no good solution right now
  [ $(( current - lasttry)) -gt 2 ] && {
  # [ -e "$CC_TMPFS/.codecomet/connected" ] && {
    cc::logger::debug "[debugger-front] we have a connected client"
    # Yes, then foreground and let it sit
    fg 2>/dev/null
  } || {
    cc::logger::debug "[debugger-front] no live client. Kick it out restart."
    # No live client. Kill it, and start again the normal process with timeout and message
    kill %%
    cc::debugger::start "$ex"
  }
}

# XXX this is largely broken
cc::debugger::live(){
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  while true; do
    lasttry="$(date +%s)"
    printf "%s" "$lasttry" > "$CC_TMPFS/.codecomet/lasttry"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-live] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Break if we have been hanging out more than a second (meaning the other end did connect, but exit in error)
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-live] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
    }
    x=$(( x + 1 ))
    cc::logger::debug "[debugger-live] sleeping"
    sleep 1
  done
}

cc::debugger::start(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  # Prep-up profile
  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  cc::logger::error "Abnormal exit code $ex. If you want to inspect manually, start codecomet-debugger. Otherwise, we will exit after $CC_DEBUGGER_GRACE seconds"
  cc::logger::error "You can also restart the build with CODECOMET_DEBUG=true"

  >&2 _cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "waiting" printf "Waiting %s seconds for debugger to connect" "$CC_DEBUGGER_GRACE"
  # cc::logger::warning "Waiting "


  # https://medium.com/@JAlblas/tryhackme-what-the-shell-walkthrough-6c0ebe8f854e
  #pty, allocates a pseudoterminal on the target ‚Äî part of the stabilisation process
  #stderr, makes sure that any error messages get shown in the shell (often a problem with non-interactive shells)
  #sigint, passes any Ctrl + C commands through into the sub-process, allowing us to kill commands inside the shell
  #setsid, creates the process in a new session
  #sane, stabilises the terminal, attempting to ‚Äúnormalise‚Äù it.

  while [ "$x" -lt "$CC_DEBUGGER_GRACE" ]; do
    lasttry="$(date +%s)"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-stat] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Timeing out means we wait for a second. Any more than that should mean the connection was succesful
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-stat] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
      >&2 printf "."
    }
    x=$(( x + 1 ))
    sleep 1
  done
}

ccdebug_stdout(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stdout.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stdout.log
  fi
}

ccdebug_stderr(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stderr.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stderr.log
  fi
}

ccdebug_stdex(){
  [ -e "$CC_TMPFS"/.codecomet/logs/ex.log ] && {
    cat "$CC_TMPFS"/.codecomet/logs/ex.log
  } || {
    cc::logger::warning "Action is in progress, no exit code yet"
  }
}

ccdebug_action(){
  echo "$_CC_PV_SCRIPT"
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# List all environment variables we depend on, possibly providing defaults
########################################################################################################################

#############
# Generic controls
#############
# Log level to start with (error, warning, info, debug or 4, 3, 2, 1, 0 <- mute)
readonly CC_LOG_LEVEL="${CC_LOG_LEVEL:-}"
# Where is the tempfs mounted
readonly CC_TMPFS="${CC_TMPFS:-}"
# Honors NO_COLOR (see https://no-color.org/)
# shellcheck disable=SC2034
readonly CC_CAP_NO_COLOR="${NO_COLOR:-}"
# About detection
# https://stackoverflow.com/questions/911168/how-can-i-detect-if-my-shell-script-is-running-through-a-pipe
# Could also test for [ ! -t 2 ]
# Or could be: `test -t 0` (formerly `tty -s`)
# In our context though, this probably does not matter much
# shellcheck disable=SC2034
readonly CC_CAP_HAS_TERM="${TERM:-}"

#############
# Action execution flow control
#############
# Whether the action can fail or not
readonly CC_ACTION_CAN_FAIL="${CC_ACTION_CAN_FAIL:-}"

#############
# Tracing and debugging
#############
# Controls wether the tracer will also trace internal codecomet library or hide them
readonly CC_TRACER_CODECOMET_INTERNALS="${CC_TRACER_CODECOMET_INTERNALS:-}"
# How long to wait for a connection before dropping the debugger
export CC_DEBUGGER_GRACE="${CC_DEBUGGER_GRACE:-}"
# Port to connect to
readonly CC_DEBUGGER_PORT="${CC_DEBUGGER_PORT:-}"
# IP to connect to
readonly CC_DEBUGGER_IP="${CC_DEBUGGER_IP:-}"
# Whether a debugger should be started pre-emptively so that one can hook in "live" during the action. This is very wonky as soon as you have parallelism...
readonly CC_DEBUGGER_LIVE="${CC_DEBUGGER_LIVE:-}"


#############
# Error code used accross the codebase - rn, only the bland FAILED is used...
#############
# shellcheck disable=SC2034
readonly ERROR_NETWORK=200
# Thrown if a required argument is missing
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_MISSING=201
# Thrown if an argument does not match validation
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_INVALID=202
# Should be used to convey that a certain operation is not supported
# shellcheck disable=SC2034
readonly ERROR_UNSUPPORTED=203
# Generic error to denote that the operation has failed. More specific errors may be provided instead
# shellcheck disable=SC2034
readonly ERROR_FAILED=204
# Expectations failed on a file (not readable, writable, doesn't exist, can't be created)
# shellcheck disable=SC2034
readonly ERROR_FILESYSTEM=205
# System requirements
# shellcheck disable=SC2034
readonly ERROR_MISSING_REQUIREMENTS=206

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# A generic logger
#
# Depends on:
# console.sh
########################################################################################################################

readonly CC_LOGGER_DEBUG=4
readonly CC_LOGGER_INFO=3
readonly CC_LOGGER_WARNING=2
readonly CC_LOGGER_ERROR=1

_CC_PV_LOGGER_LEVEL="$CC_LOGGER_WARNING"

_cc_private::logger::log(){
  local prefix="$1"
  shift

  local level="CC_LOGGER_$prefix"
  local i

  [ "$_CC_PV_LOGGER_LEVEL" -ge "${!level}" ] || return 0

  # About the crazy shit: https://stackoverflow.com/questions/12674783/bash-double-process-substitution-gives-bad-file-descriptor
  exec 3>&2
  for i in "$@"; do
    >&2 cc::console::"$(printf "$prefix" | tr '[:upper:]' '[:lower:]')" printf "$i"
  done
  exec 3>&-
}

cc::logger::level::set() {
  local level
  level="$(printf "%s" "${1:-}" | tr '[:upper:]' '[:lower:]')"

  case "$level" in
    ''|*[!0-9]*)
      case "$level" in
          "debug")
            _CC_PV_LOGGER_LEVEL=4
            ;;
          "info")
            _CC_PV_LOGGER_LEVEL=3
            ;;
          "warning")
            _CC_PV_LOGGER_LEVEL=2
            ;;
          "error")
            _CC_PV_LOGGER_LEVEL=1
            ;;
          "mute")
            _CC_PV_LOGGER_LEVEL=0
            ;;
          *)
            _CC_PV_LOGGER_LEVEL=3
            ;;
      esac
      ;;
    *)
      if [ "$level" -gt "$CC_LOGGER_DEBUG" ]; then
        return "$ERROR_FAILED"
      fi
      _CC_PV_LOGGER_LEVEL="$level"
      ;;
  esac

  [ "$_CC_PV_LOGGER_LEVEL" != "$CC_LOGGER_DEBUG" ] || {
    cc::console::warning printf "YOU ARE LOGGING AT THE DEBUG LEVEL."
    cc::console::warning printf "This is NOT recommended for production use, and WILL LIKELY LEAK sensitive information to logs."
  }
}

# Sugar
cc::logger::level::set::debug(){
  cc::logger::level::set "$CC_LOGGER_DEBUG"
}

cc::logger::level::set::info(){
  cc::logger::level::set "$CC_LOGGER_INFO"
}

cc::logger::level::set::warning(){
  cc::logger::level::set "$CC_LOGGER_WARNING"
}

cc::logger::level::set::error(){
  cc::logger::level::set "$CC_LOGGER_ERROR"
}

cc::logger::mute() {
  _CC_PV_LOGGER_LEVEL=0
}

cc::logger::ismute() {
  [ "$_CC_PV_LOGGER_LEVEL" == 0 ] || return "$ERROR_FAILED"
}

cc::logger::debug(){
  _cc_private::logger::log "DEBUG" "$@"
}

cc::logger::info(){
  _cc_private::logger::log "INFO" "$@"
}

cc::logger::warning(){
  _cc_private::logger::log "WARNING" "$@"
}

cc::logger::error(){
  _cc_private::logger::log "ERROR" "$@"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provides fancy display for `set -x`
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
########################################################################################################################

cc::codecomet::tracer(){
  local length="${#BASH_SOURCE[@]}"

  #local indent=""
  local linenumber
  local filename
  local filecontent
  local funcname
  local col

  [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[1]}" == *"action.sh" ]] || return 0

  printf "\n"

  for (( j=$(( length - 1 )); j>0; j-- )); do
    [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[$j]}" == *"action.sh" ]] || {
      continue
    }

    linenumber="${BASH_LINENO[$(( j - 1 ))]}"
    filename="${BASH_SOURCE[$j]}"
    filecontent="$(cat -n "$filename" | grep -E "^\s+$linenumber\s" | sed -E "s/^\s+$linenumber\s+//")"
    funcname="${FUNCNAME[$j]}"

    # Why is this showing is a mystery for the times
    # [ "$filecontent" != "#!/usr/bin/env bash" ] || continue

    [ "$j" != 1 ] && {
      col="$CC_COLOR_DEFAULT_FRONT"
    } || {
      col="$CC_COLOR_TRACER_HUMPF"
    }

    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$filename"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$linenumber"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "function" printf "%-30s" "$funcname()"
    printf "\n"
    [ "$j" != 1 ] || {
      _cc_private::console "$CC_COLOR_TRACER_COMMAND_LABEL" "$CC_COLOR_DEFAULT_FRONT" "command" printf "%s" "$filecontent"
      _cc_private::console "$CC_COLOR_TRACER_OUTPUT_LABEL" "$CC_COLOR_DEFAULT_FRONT" "output" printf ""
    }

  done
}

cc::tracer::register(){
  # shellcheck disable=SC2016
  local ps=('$(' "$@" ')')
  export PS4="${ps[*]}"
}

cc::init::tracer(){
  cc::tracer::register cc::codecomet::tracer
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Trap management
#
# Depends on:
# colors.sh
# console.sh
########################################################################################################################

_CC_PV_TRAP_LISTENERS=()

_CC_PV_ERR_LNO=
_CC_PV_ERR_CMD=
_CC_PV_ERR_STACK=
_CC_PV_ERR_EX=

dc::trap::register(){
  _CC_PV_TRAP_LISTENERS+=( "$1" )
}

# Trap lno and cmd on ERR for future use
cc::trap::err(){
  _CC_PV_ERR_EX="$1"
  _CC_PV_ERR_LNO="$2"
  _CC_PV_ERR_CMD="$3"
  _CC_PV_ERR_STACK="$4"
  # Dropping the rest of the stack?

  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$_CC_PV_ERR_STACK"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$_CC_PV_ERR_LNO"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "exit" printf "%s" "$_CC_PV_ERR_EX"
  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "command" printf "%-30s" "$_CC_PV_ERR_CMD"
  >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  >&2 printf "\n"

  >&2 _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "source" printf ""
  prefix=" "
  for (( j=$(( _CC_PV_ERR_LNO - 3 )); j<$(( _CC_PV_ERR_LNO + 3 )); j++ )); do
    [ "$j" -gt 0 ] || continue
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=">"
      >&2 _cc_private::tput setaf "$CC_COLOR_ERROR_FRONT"
      #>&2 _cc_private::tput bold
    fi
    #  | sed -E "s/^\s+$j\s//"
    >&2 printf "%s%s" "$prefix" "$(cat -n "$_CC_PV_ERR_STACK" | grep -E "^\s+$j\s")" || true
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=" "
      >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
      #>&2 _cc_private::tput sgr0
    fi
    >&2 printf "\n"
  done
}

_CC_PV_NO_REENTRY=

# Trap exit for the actual cleanup
cc::trap::exit() {
  # { set +x; } 2>/dev/null

  local ex="$1"
  local i

  # Prevent reentrancy - XXX is this actually needed?
  [ ! "$_CC_PV_NO_REENTRY" ] || return 0
  _CC_PV_NO_REENTRY="exiting"

  printf "%s\n" "$ex" > "$CC_TMPFS"/.codecomet/logs/ex.log

  if [ "${#_CC_PV_TRAP_LISTENERS[@]}" -gt 0 ]; then
    for i in "${_CC_PV_TRAP_LISTENERS[@]}"; do
      cc::logger::debug "Calling exit hook $i"
#      >&2 printf "\n"
      "$i" "$ex" "$_CC_PV_ERR_CMD" "$_CC_PV_ERR_LNO" "$_CC_PV_ERR_STACK"
    done
  fi
  >&2 cc::console::reset
  >&2 printf "\n"
  cc::logger::debug "Exiting ($ex)"
  [ "$CC_ACTION_CAN_FAIL" == "true" ] && {
    [ "$ex" != "" ] || cc::logger::error "Action failed, but it is marked as 'can fail', so, exiting successfully"
    exit 0
  } || exit "$ex"
}

# Forking to disable xtrace when entering traps
cc::init::trap(){
  # Signals are caught by buildkit already - and only SIGKILL triggers a failure
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::err "$ex" "$LINENO" "$BASH_COMMAND" "${BASH_SOURCE[@]}"' ERR
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::exit "$ex"' EXIT
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# See https://manpages.ubuntu.com/manpages/xenial/man1/eatmydata.1.html
# Technically, we get a 10% speedup with apt operations for eg
# XXX careful here if this is going to be used in a chroot
cc::init::speedup(){
  ! command -v eatmydata >/dev/null || export LD_PRELOAD=libeatmydata.so
}

# Boot if we have an argument - otherwise, we are being sourced
if [ "$#" -gt 0 ]; then
  mkdir -p "$TMPDIR"
  rm -Rf "$CC_TMPFS"/.codecomet
  mkdir -p "$CC_TMPFS"/.codecomet/bin
  mkdir -p "$CC_TMPFS"/.codecomet/logs

  # Set logger to env var from the Bash helper
  cc::logger::level::set "$CC_LOG_LEVEL"

  # Eat data, trap, register tracer, register debugger on exit trap
  cc::init::speedup
  cc::init::trap
  cc::init::tracer
  # Live debugger is really wonky
  if [ "${CC_DEBUGGER_LIVE:-}" != "" ]; then
    cc::debugger::live &
    dc::trap::register cc::debugger::front
  else
    [ "$CC_ACTION_CAN_FAIL" == true ] || dc::trap::register cc::debugger::start
  fi

  # XXX technically, we receive a bunch of scripts, and we could just play them all - use case is not completely clear yet
  out="$CC_TMPFS"/.codecomet/logs/stdout.log
  err="$CC_TMPFS"/.codecomet/logs/stderr.log

  # Unpack libraries path and source them
  while [ "$#" -gt 1 ]; do
    cp "$1" "$CC_TMPFS"/.codecomet/bin
    # shellcheck disable=SC1090
    source "$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
    shift
  done
  cp "$1" "$CC_TMPFS"/.codecomet/bin
  _CC_PV_SCRIPT="$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
  export _CC_PV_SCRIPT

  # Run the actual action
  # shellcheck disable=SC1090
  source "$_CC_PV_SCRIPT" > >(tee -a "$out") 2> >(tee -a "$err" >&2)
else
  # If we are a library, toss this one so we do not exit on any error...
  # This is especially important for the reverse debugger
  set +o errexit
fi
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
â"Ûˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*◊
/library0.sh¿∏#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# A generic lock mechanism that supports exclusive locks, shared locks, and a simplistic queueing mechanism
_cc_lockindex=9
_cc_lock_location="/_cc/share/locks"

# Sets our locks location. Must be called to guarantee that the lock location exist.
cc::lock::init(){
	_cc_lock_location="${1:-.}"
	mkdir -p "${_cc_lock_location}"
}

# Acquire a lock with a given name, and a share mode (shared or exclusive (which is the default))
# If the lock is already acquired in a different mode, or the mode is exclusive, the function will wait until the lock is released.
# Return the lock id that you need to carry around to release the lock later on.
cc::lock::acquire(){
	local lockfile="$_cc_lock_location/$1"
	local shared="${2:-}"
	[ "$shared" ] && shared=-s || shared=-x
	_cc_lockindex=$((_cc_lockindex+1))
	mkdir -p "$(dirname "$lockfile")"
	exec {_cc_lockindex}>"$lockfile"
	flock $shared $_cc_lockindex
	return $_cc_lockindex
}

# Release a previously acquire lock by its id
cc::lock::release(){
	local idx="$1"
	# This is essentially the same
	flock -u "$idx"
	# exec {idx}>&-
}

cc::lock::queue(){
	local basepath="${1:-.}"
	local shared1="${2:-}"
	local shared2="${3:-}"
	local qid
	local oid

	# Get into the queue first
	cc::lock::acquire "$basepath"/cc_queue.lock "$shared1" || qid=$?

	# Then when out of the queue, acquire an operation lock
	cc::lock::acquire "$basepath"/cc_op.lock "$shared2" || oid=$?

	# Now, leave the queue
	cc::lock::release $qid

	# Return the lock id
	return $oid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
˙"‰·ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*»
/library1.sh¿©#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Lessons learned:
# - find -exec is VERY SLOW - better off piping to read (almost 10x) (0.2 second vs 0.02 second for about 200 files)
# - then globbing and grepping is faster than find + read
# This matters not in case we are copying a large amount of data of course, but then
# - there is no way to get something stable out of ls without further processing - directories with different owners
# for eg will widen some columns
# this "works" right now (if we do not use --numeric-uid-gid) but will be problematic outside of this specific case

_cc::fingerprint(){
  local directory="$1"
  # Will fail if the directory is empty, so the guardrail
  # Ignore directories, links, and "total" (note: -d will not work for that)
  # --numeric-uid-gid < messes up the output width
  # shellcheck disable=SC2010
  ls --full-time --almost-all --ignore lock "$directory" 2>/dev/null | grep -v "^[d|l|t]" || true
}

# Copy or symlink data "from" storage "to" destination
# This assume that storage holds only files, and no lock
# Will not copy anything if there is no difference
cc::storage::retrieve(){
  local from="$1"
  local to="$2"
  local copy="${3:-}"
  local lid
  local fromState

  # Ensure destination exists
  mkdir -p "$to"

  # Lock origin and keep the lock id
  cc::lock::acquire "$from" shared || lid=$?

  # Ensure origin exists
  mkdir -p "$from"

  # If we are asked to copy (not expected for large amount of data - linking is prefered in that case)
  if [ "$copy" ]; then
    # Retrieve the state of it
    fromState="$(_cc::fingerprint "$from")"

    # Check that we have content in storage
    # Check that we have a difference between storage and destination (ignoring directories and lock file)
    # shellcheck disable=SC2010
    # shellcheck disable=SC2015
    [ "$fromState" ] && [ "$fromState" != "$(_cc::fingerprint "$to")" ] && {
      # Then cleanup destination
      rm -Rf "$to"
      mkdir -p "$to"
      # And copy over
      cp -p "$from"/* "$to"
      # Slower
      #find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
      #  cp -p "$fd" "$to"
      #done
    } || {
      # Otherwise, do nothing
      cc::logger::debug "Nothing to retrieve from storage"
    }
  else
    # We want links, so, lets check we have anything in the origin
    #[ ! "$fromState" ] || {
    # Get rid of possibly remaining files in our destination
    find "$to" -type f -delete
    ln -sf "$from"/* "$to" 2>/dev/null || true
    # Note: below is slower
    # find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
    #  ln -s "$fd" "$to"
    # done
    #}
  fi

  # Release the lock
	cc::lock::release $lid
}

cc::storage::store(){
  local from="$1"
  local to="$2"
  local erase="${3:-}"
  local lid
  local fd
  local toState

  # Ensure origin exists
  mkdir -p "$from"

  # Lock destination and keep the lock id
  cc::lock::acquire "$to" "" || lid=$?

  # Ensure destination exists
  mkdir -p "$to"
  # Retrieve the state of it
  # shellcheck disable=SC2010
  toState="$(_cc::fingerprint "$to")"

  # Compare state of the destination with the origin (origin ignores directories and lock files)
  # shellcheck disable=SC2010
  # shellcheck disable=SC2015
  [ "$toState" != "$(_cc::fingerprint "$from")" ] && {
    # We have changes - if asked to wipe out, do so
    if [ "$erase" ]; then
      rm -Rf "$to"
      mkdir -p "$to"
    fi
    # Now copy the files
    # This is probably slow-ish. The question is: will it be significant in a context where copy IO is the bottleneck?
    find "$from" -type f -not -iname "lock" -print0 | while IFS= read -r -d $'\0' fd; do
      cp -p "$fd" "$to"
    done
  } || {
    cc::logger::debug "Nothing to save to storage"
  }

  # Release the lock
	cc::lock::release $lid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
Ï*"÷*”*ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∫*
/library2.sh¿õ*#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Helpers to allow apt to share cache properly

# Private tmpfs location
_cc_tmpfs_location=/codecomet/apt-get-private/tmp

# Location of the list cache
_cc_apt_list_store_location=/codecomet/apt-get-shared/lists
# And pack cache
_cc_apt_pack_local_location=/codecomet/apt-get-shared/packs

# Location of the packages cache
_cc_apt_pack_store_location=/codecomet/apt-get-shared/cache

# Location of our private lists files - by default, Debian normal location, which means state will persist
_cc_apt_list_local_location=/var/lib/apt/lists

# Location of the config file
export APT_CONFIG=$_cc_tmpfs_location/apt-get.conf

# Hash of the sources.list, which dictates the cache location to share
# Different sources means different cache location
# Caveats: this will likely not work with a future debian release as they change the sources.list format
# XXX this wracking the debugger output
cc::apt_get::shard(){
  sha256sum <<< "$(uname -m)$(grep --no-filename -Ev "^#" /etc/apt/sources.list /etc/apt/sources.list.d/* 2>/dev/null | sed -E 's/#.+$//' | sort || true)" | sed -E 's/  .*//'
}

# Set the tmp location, initiliaze APT_CONFIG and shared and private locations
cc::apt_get::init(){
  # Get the desired tmpfs mount point
  _cc_tmpfs_location="$1"

  mkdir -p "$_cc_tmpfs_location"

  # Point configuration there
  export APT_CONFIG="$_cc_tmpfs_location"/apt-get.conf

  # Sharding by sources list content, cleaned-up and sorted to maximize cache hits
	_cc_apt_list_store_location="$2/$(cc::apt_get::shard)"

  # Technically, we should not be sharding the architecture
  # But then, the only upside would be when installing cross-arch packages
	_cc_apt_pack_store_location="$3/$(cc::apt_get::shard)"

  # If we do not want lists to persist, use the tmp storage
  [ "${4:-}" == true ] || _cc_apt_list_local_location="$_cc_tmpfs_location"/lists

  # Finally, local pack location
  _cc_apt_pack_local_location="$_cc_tmpfs_location"/packs

  # Make sure they all exist
  mkdir -p "$_cc_apt_list_local_location"
  mkdir -p "$_cc_apt_pack_local_location"

  mkdir -p "$_cc_apt_list_store_location"
  mkdir -p "$_cc_apt_pack_store_location"
}

# Create the configuration file for APT
cc::apt_get::configure(){
  local config_extra="${1:-}"
  local persist="${2:-}"

  mkdir -p "$_cc_tmpfs_location/logs"
  cat << EOF > "$APT_CONFIG"
# Divert both lists and archives location
Dir::Cache::Archives "$_cc_apt_pack_local_location";
Dir::State::Lists "$_cc_apt_list_local_location";
# Prevent the default apt config to be used
Dir::Etc::parts "";
# Put the logs in the tmp zone
Dir::Log "$_cc_tmpfs_location/logs";
# Put the bin cache files in the private mount
Dir::Cache::srcpkgcache "$_cc_tmpfs_location/srcpkgcache.bin";
Dir::Cache::pkgcache "$_cc_tmpfs_location/pkgcache.bin";

$config_extra
EOF

  # If asked to persist the config, copy over the generated file
  [ "$persist" == "false" ] || cp "$APT_CONFIG" /etc/apt/apt.conf
}

#cc::apt_get::cleanup(){
  # This is only necessary if we were not using an tmpfs mount...
  # rm "$APT_CONFIG"
#}

cc::apt_get::update(){
  # Remove our marker if here
  rm -f "$_cc_apt_list_local_location"/.cc_updated

  # Retrieve existing data
  cc::storage::retrieve "$_cc_apt_list_store_location" "$_cc_apt_list_local_location" copy

	# Do the deed, same restriction applies
	apt-get update "$@"

  # Save it back (storage will decide)
  cc::storage::store "$_cc_apt_list_local_location" "$_cc_apt_list_store_location" erase

  # Now, flag it
  date > "$_cc_apt_list_local_location"/.cc_updated
}

cc::apt_get::do(){
  # Bring in any cache
  cc::storage::retrieve "$_cc_apt_pack_store_location" "$_cc_apt_pack_local_location"

	apt-get "$@"

  # Store the packages permanently
  cc::storage::store "$_cc_apt_pack_local_location" "$_cc_apt_pack_store_location"
}

# XXX what if sources are being modified, or config, or something else that materially impacts update?
cc::high::update(){
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "$nooutput"

  args+=("$@")
  time cc::apt_get::update "${args[@]}"
}

cc::high::install(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists has been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  args+=("$@")
  time cc::apt_get::do install "${args[@]}"
}

cc::high::upgrade(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists have been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  # ls -lAR "$_cc_tmpfs_location"/packs || true
  # time cc::apt_get::do upgrade "$nooutput" "$@"

  # XXX WIP here
  # Bust cache - delete this
  #time cc::apt_get::do upgrade --download-only "$nooutput" "$@"
  #time cc::apt_get::do upgrade --no-download "$nooutput" "$@"
  args+=("$@")
  time cc::apt_get::do upgrade "${args[@]}"
}

cc::high::purge(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")

  args+=("$@")
  time cc::apt_get::do purge --auto-remove "${args[@]}"
}(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
’"øºˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*£

/action.sh¿Ü#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::upgrade

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f7942
 



Z 
fR
5docker-image://docker.io/library/debian:bullseye-slim
image.resolvemodepullR
amd64linuxZ 
£
I
Gsha256:f65fec6162c8d70fc2311c3d20f1b6a91a87c9203547e280f276fe349ca18ac5
I
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
amd64linuxZ 
Í"‘—ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∏

/action.sh¿õ#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::install eatmydata nano socat

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c2
 



Z 
£
I
Gsha256:7a830e01dd5926f63eee241a37f13de580dac91af765ea3a0c027e5dc01a70b0
I
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
amd64linuxZ 
K
I
Gsha256:7675b821844b304f3dfa86c81f7648559f41024b3a59c7bda03b191a177910cdü
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library2.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library1.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupŒ
Gsha256:7675b821844b304f3dfa86c81f7648559f41024b3a59c7bda03b191a177910cdÇ!
codecomet.optest codecomet op6
llb.customname$apt-get install eatmydata nano socat*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeπ
Gsha256:7a830e01dd5926f63eee241a37f13de580dac91af765ea3a0c027e5dc01a70b0Ì!
codecomet.optest codecomet op!
llb.customnameapt-get upgrade*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeù
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962—!
codecomet.optest codecomet op0
llb.customname[action:addfile] codecomet in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupê
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edfƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library0.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupê
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8aƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupË
Gsha256:f65fec6162c8d70fc2311c3d20f1b6a91a87c9203547e280f276fe349ca18ac5ú!
codecomet.optest codecomet opG
llb.customname5[source:image] docker.io/library/debian:bullseye-slim*
source.image*
source.image.resolvemodeÄ
Gsha256:fe08b103bce4ea5603cb864c3b8f0394fee85e8253501e3a7d3fd8fc5b3008405*
constraints*
meta.description*
platformœ
K
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f 
K
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7 
K
Gsha256:7675b821844b304f3dfa86c81f7648559f41024b3a59c7bda03b191a177910cd 
K
Gsha256:7a830e01dd5926f63eee241a37f13de580dac91af765ea3a0c027e5dc01a70b0 
K
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962 
K
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c 
K
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf 
K
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c 
K
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794 
K
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a 
K
Gsha256:f65fec6162c8d70fc2311c3d20f1b6a91a87c9203547e280f276fe349ca18ac5 
fR
5docker-image://docker.io/library/debian:bullseye-slim
image.resolvemodepullR
arm64linuxZ 
æ›"ß›£›ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*â›

/codecomet¿Î‹#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Defines the supported color palette, and our color scheme
########################################################################################################################

# Supported color palette
readonly _CC_PV_COLOR_BLACK=0
readonly _CC_PV_COLOR_RED=1
readonly _CC_PV_COLOR_GREEN=2
readonly _CC_PV_COLOR_YELLOW=3
# shellcheck disable=SC2034
readonly _CC_PV_COLOR_BLUE=4
readonly _CC_PV_COLOR_MAGENTA=5
readonly _CC_PV_COLOR_CYAN=6
readonly _CC_PV_COLOR_WHITE=7

# Colors scheme definition - can evidently be customized at runtime by setting these variables to other values from the palette
export CC_COLOR_DEFAULT_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEFAULT_BACK="$_CC_PV_COLOR_BLACK"

export CC_COLOR_BODY="$_CC_PV_COLOR_WHITE"
export CC_COLOR_COMMENT="$_CC_PV_COLOR_CYAN"
export CC_COLOR_HUMPF="$_CC_PV_COLOR_MAGENTA"

# Logger
export CC_COLOR_ERROR_FRONT="$_CC_PV_COLOR_RED"
export CC_COLOR_ERROR_BACK="$_CC_PV_COLOR_WHITE"
export CC_COLOR_WARNING_FRONT="$_CC_PV_COLOR_YELLOW"
export CC_COLOR_WARNING_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_INFO_FRONT="$_CC_PV_COLOR_GREEN"
export CC_COLOR_INFO_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_DEBUG_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEBUG_BACK="$_CC_PV_COLOR_BLACK"

# Tracer
export CC_COLOR_TRACER_HUMPF="$_CC_PV_COLOR_GREEN"
export CC_COLOR_TRACER_COMMAND_LABEL="$_CC_PV_COLOR_BLUE"
export CC_COLOR_TRACER_OUTPUT_LABEL="$_CC_PV_COLOR_RED"
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provide helpers to print colorful text
#
# Depends on:
# defaults.sh
# colors.sh
########################################################################################################################

_cc_private::tput(){
  [ ! "$CC_CAP_HAS_TERM" ] || [ "$CC_CAP_NO_COLOR" != "" ] || tput "$@" 2>/dev/null || true
}

_cc_private::console::inline(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it and pad to 7 chars, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"
}

_cc_private::console(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-7s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    # Otherwise, just a plain front/back
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"

  # Restore console to default before we \n so that we do not leak over into BK timestamp display
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::error(){
  _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_ERROR_BACK" "error" "$@"
}

cc::console::warning(){
  _cc_private::console "$CC_COLOR_WARNING_FRONT" "$CC_COLOR_WARNING_BACK" "warning" "$@"
}

cc::console::info(){
  _cc_private::console "$CC_COLOR_INFO_FRONT" "$CC_COLOR_INFO_BACK" "info" "$@"
}

cc::console::debug(){
  _cc_private::console "$CC_COLOR_DEBUG_FRONT" "$CC_COLOR_DEBUG_BACK" "debug" "$@"
}

cc::console::body(){
  _cc_private::console "$CC_COLOR_BODY" "" "" "$@"
}

cc::console::comment(){
  _cc_private::console "$CC_COLOR_COMMENT" "" "" "$@"
}

cc::console::humpf(){
  _cc_private::console "$CC_COLOR_HUMPF" "" "" "$@"
}

cc::console::reset(){
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::end(){
  _cc_private::tput op
  printf "\n"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Debugger based on socat
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
# logger.sh
########################################################################################################################

# Fancy prompt adapted from https://github.com/pombadev/fancy-linux-prompt/blob/master/LICENSE under MIT License
__powerline() {
    # Unicode symbols
    readonly GIT_NEED_PULL_SYMBOL='‚á£'
    readonly GIT_NEED_PUSH_SYMBOL='‚á°'
    readonly PS_SYMBOL='ü™ê' # üêß‚òÑ'‚ñ∂‚èµ‚ñ∂‚èµ

    # Solarized colorscheme
    readonly BG_BLUE="\\[$(tput setab 4)\\]"
    readonly BG_COLOR5="\\[\\e[48;5;31m\\]"
    readonly BG_COLOR8="\\[\\e[48;5;161m\\]"
    readonly BG_GREEN="\\[$(tput setab 2)\\]"
    readonly BG_RED="\\[$(tput setab 1)\\]"
    readonly FG_BASE3="\\[$(tput setaf 15)\\]"
    readonly FG_BLUE="\\[$(tput setaf 4)\\]"
    readonly FG_COLOR1="\\[\\e[38;5;250m\\]"
    readonly FG_COLOR6="\\[\\e[38;5;31m\\]"
    readonly FG_COLOR9="\\[\\e[38;5;161m\\]"
    readonly FG_GREEN="\\[$(tput setaf 2)\\]"
    readonly FG_RED="\\[$(tput setaf 1)\\]"
    readonly RESET="\\[$(tput sgr0)\\]"

    __git_info() {
        # has a .git directory and a git binary
    	[ -d .git ] || command -v git >/dev/null || return 0

        local aheadN
        local behindN
        local branch
        local marks=""
        local stats

        # get current branch name or short SHA1 hash for detached head
        branch="$(git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --always 2>/dev/null)"
        [ -n "$branch" ] || return 0 # git branch not found

        # how many commits local branch is ahead/behind of remote?
        stats="$(git status --porcelain --branch | grep '^##' | grep -o '\[.\+\]$')"
        aheadN="$(echo "$stats" | grep -o 'ahead \d\+' | grep -o '\d\+')"
        behindN="$(echo "$stats" | grep -o 'behind \d\+' | grep -o '\d\+')"
        [ -n "$aheadN" ] && marks+=" $GIT_NEED_PUSH_SYMBOL$aheadN"
        [ -n "$behindN" ] && marks+=" $GIT_NEED_PULL_SYMBOL$behindN"

        # print the git branch segment without a trailing newline
        # branch is modified?
        if [ -n "$(git status --porcelain)" ]; then
            printf "%s" "${BG_COLOR8}‚ñ∂$RESET$BG_COLOR8 $branch$marks $FG_COLOR9"
        else
            printf "%s" "${BG_BLUE}‚ñ∂$RESET$BG_BLUE $branch$marks $RESET$FG_BLUE"
        fi
    }


    ps1() {
        # Check the exit code of the previous command and display different
        # colors in the prompt accordingly.
        if [ "$?" -eq 0 ]; then
            local BG_EXIT="$BG_GREEN"
            local FG_EXIT="$FG_GREEN"
        else
            local BG_EXIT="$BG_RED"
            local FG_EXIT="$FG_RED"
        fi

        PS1="$FG_COLOR1$BG_COLOR5 CodeComet \\w "
        PS1+="$RESET${FG_COLOR6}"
        PS1+="$(__git_info)"
        PS1+="$BG_EXIT‚ñ∂$RESET"
        PS1+="$BG_EXIT$FG_BASE3 ${PS_SYMBOL} ${RESET}${FG_EXIT}‚ñ∂${RESET} "
    }

    PROMPT_COMMAND=ps1
}

_cc_private::debugger::setup(){
  # Set-up PS1
  cat << EOF > "$CC_TMPFS"/.profile
# export PS1='\[\033[01;32m\]CodeComet\[\033[00m\] \w \$ '
alias l="ls -lA"
source ${BASH_SOURCE[0]}
umask 077
export LSCOLORS=exfxcxdxbxegedabagacad
export CLICOLOR=1

_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Welcome!" printf "You are now debugging your pipeline at the point it stopped.\n"
printf "\n"
#_cc_private::console::inline "$_CC_PV_COLOR_BLACK" "$_CC_PV_COLOR_BLACK" "         " printf ""
printf "Environment, pwd, and filesystem, are exactly as they were when the last action failed.\n"
printf "You can call the following helpers:\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdout" printf "will output your action stdout\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stderr" printf "will output your action stderr\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdex " printf "will output your action exit code\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_action" printf "will output the location of your action script\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Tip           " printf "If you want to re-run your action, just call \\\$(ccdebug_action)\n"

# touch "$CC_TMPFS/.codecomet/connected"
__powerline

EOF

  cat << EOF >> "$CC_TMPFS"/.inputrc
"\e[A": history-search-backward
"\e[B": history-search-forward
set show-all-if-ambiguous on
set completion-ignore-case on

EOF

}

# "on demand
# "Abnormal exit, with non zero grace:
# - start debugger repeatedly, with grace
# - once the other end exits, bail out

# "live", with non zero grace
# - start debugger, with infinity grace
# - if the other end was connected and exited, that is it, end of story
# - if the other end is still running, bring socat forward and wait for the end to exit
# - if there was no other end, we should branch back to the first scenario

# This is called on trap ERR, if a live debugger has been running, and will make a decision to bring it back forward and keep it alive,
# or to drop it
cc::debugger::front(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  cc::logger::debug "[debugger-front] socat is here"
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  cc::logger::debug "[debugger-front] grace is fine"


  # Debugger still live? Bail out if not
  jobs | grep -q -v Done || {
    cc::logger::debug "[debugger-front] no jobs detected. Bailing out."
    return 0
  }

  # Ok, it is live. Do we have a client?
  # XXX unfortunately, this does not work as expected... socat does start the process first, bash sources the files and create the stamp file...
  local lasttry
  local current
  lasttry="$(cat $CC_TMPFS/.codecomet/lasttry 2>/dev/null)" || true
  current="$(date +%s)"
  # The older an unconnected socat could be is 2 seconds - if greater than that, then we definitely have a client
  # However, it is possible that a client has been connected for less than 2 seconds (since socat call) when the failure happens,
  # which means the client will wrongly get the boot... no good solution right now
  [ $(( current - lasttry)) -gt 2 ] && {
  # [ -e "$CC_TMPFS/.codecomet/connected" ] && {
    cc::logger::debug "[debugger-front] we have a connected client"
    # Yes, then foreground and let it sit
    fg 2>/dev/null
  } || {
    cc::logger::debug "[debugger-front] no live client. Kick it out restart."
    # No live client. Kill it, and start again the normal process with timeout and message
    kill %%
    cc::debugger::start "$ex"
  }
}

# XXX this is largely broken
cc::debugger::live(){
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  while true; do
    lasttry="$(date +%s)"
    printf "%s" "$lasttry" > "$CC_TMPFS/.codecomet/lasttry"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-live] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Break if we have been hanging out more than a second (meaning the other end did connect, but exit in error)
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-live] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
    }
    x=$(( x + 1 ))
    cc::logger::debug "[debugger-live] sleeping"
    sleep 1
  done
}

cc::debugger::start(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  # Prep-up profile
  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  cc::logger::error "Abnormal exit code $ex. If you want to inspect manually, start codecomet-debugger. Otherwise, we will exit after $CC_DEBUGGER_GRACE seconds"
  cc::logger::error "You can also restart the build with CODECOMET_DEBUG=true"

  >&2 _cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "waiting" printf "Waiting %s seconds for debugger to connect" "$CC_DEBUGGER_GRACE"
  # cc::logger::warning "Waiting "


  # https://medium.com/@JAlblas/tryhackme-what-the-shell-walkthrough-6c0ebe8f854e
  #pty, allocates a pseudoterminal on the target ‚Äî part of the stabilisation process
  #stderr, makes sure that any error messages get shown in the shell (often a problem with non-interactive shells)
  #sigint, passes any Ctrl + C commands through into the sub-process, allowing us to kill commands inside the shell
  #setsid, creates the process in a new session
  #sane, stabilises the terminal, attempting to ‚Äúnormalise‚Äù it.

  while [ "$x" -lt "$CC_DEBUGGER_GRACE" ]; do
    lasttry="$(date +%s)"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-stat] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Timeing out means we wait for a second. Any more than that should mean the connection was succesful
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-stat] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
      >&2 printf "."
    }
    x=$(( x + 1 ))
    sleep 1
  done
}

ccdebug_stdout(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stdout.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stdout.log
  fi
}

ccdebug_stderr(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stderr.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stderr.log
  fi
}

ccdebug_stdex(){
  [ -e "$CC_TMPFS"/.codecomet/logs/ex.log ] && {
    cat "$CC_TMPFS"/.codecomet/logs/ex.log
  } || {
    cc::logger::warning "Action is in progress, no exit code yet"
  }
}

ccdebug_action(){
  echo "$_CC_PV_SCRIPT"
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# List all environment variables we depend on, possibly providing defaults
########################################################################################################################

#############
# Generic controls
#############
# Log level to start with (error, warning, info, debug or 4, 3, 2, 1, 0 <- mute)
readonly CC_LOG_LEVEL="${CC_LOG_LEVEL:-}"
# Where is the tempfs mounted
readonly CC_TMPFS="${CC_TMPFS:-}"
# Honors NO_COLOR (see https://no-color.org/)
# shellcheck disable=SC2034
readonly CC_CAP_NO_COLOR="${NO_COLOR:-}"
# About detection
# https://stackoverflow.com/questions/911168/how-can-i-detect-if-my-shell-script-is-running-through-a-pipe
# Could also test for [ ! -t 2 ]
# Or could be: `test -t 0` (formerly `tty -s`)
# In our context though, this probably does not matter much
# shellcheck disable=SC2034
readonly CC_CAP_HAS_TERM="${TERM:-}"

#############
# Action execution flow control
#############
# Whether the action can fail or not
readonly CC_ACTION_CAN_FAIL="${CC_ACTION_CAN_FAIL:-}"

#############
# Tracing and debugging
#############
# Controls wether the tracer will also trace internal codecomet library or hide them
readonly CC_TRACER_CODECOMET_INTERNALS="${CC_TRACER_CODECOMET_INTERNALS:-}"
# How long to wait for a connection before dropping the debugger
export CC_DEBUGGER_GRACE="${CC_DEBUGGER_GRACE:-}"
# Port to connect to
readonly CC_DEBUGGER_PORT="${CC_DEBUGGER_PORT:-}"
# IP to connect to
readonly CC_DEBUGGER_IP="${CC_DEBUGGER_IP:-}"
# Whether a debugger should be started pre-emptively so that one can hook in "live" during the action. This is very wonky as soon as you have parallelism...
readonly CC_DEBUGGER_LIVE="${CC_DEBUGGER_LIVE:-}"


#############
# Error code used accross the codebase - rn, only the bland FAILED is used...
#############
# shellcheck disable=SC2034
readonly ERROR_NETWORK=200
# Thrown if a required argument is missing
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_MISSING=201
# Thrown if an argument does not match validation
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_INVALID=202
# Should be used to convey that a certain operation is not supported
# shellcheck disable=SC2034
readonly ERROR_UNSUPPORTED=203
# Generic error to denote that the operation has failed. More specific errors may be provided instead
# shellcheck disable=SC2034
readonly ERROR_FAILED=204
# Expectations failed on a file (not readable, writable, doesn't exist, can't be created)
# shellcheck disable=SC2034
readonly ERROR_FILESYSTEM=205
# System requirements
# shellcheck disable=SC2034
readonly ERROR_MISSING_REQUIREMENTS=206

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# A generic logger
#
# Depends on:
# console.sh
########################################################################################################################

readonly CC_LOGGER_DEBUG=4
readonly CC_LOGGER_INFO=3
readonly CC_LOGGER_WARNING=2
readonly CC_LOGGER_ERROR=1

_CC_PV_LOGGER_LEVEL="$CC_LOGGER_WARNING"

_cc_private::logger::log(){
  local prefix="$1"
  shift

  local level="CC_LOGGER_$prefix"
  local i

  [ "$_CC_PV_LOGGER_LEVEL" -ge "${!level}" ] || return 0

  # About the crazy shit: https://stackoverflow.com/questions/12674783/bash-double-process-substitution-gives-bad-file-descriptor
  exec 3>&2
  for i in "$@"; do
    >&2 cc::console::"$(printf "$prefix" | tr '[:upper:]' '[:lower:]')" printf "$i"
  done
  exec 3>&-
}

cc::logger::level::set() {
  local level
  level="$(printf "%s" "${1:-}" | tr '[:upper:]' '[:lower:]')"

  case "$level" in
    ''|*[!0-9]*)
      case "$level" in
          "debug")
            _CC_PV_LOGGER_LEVEL=4
            ;;
          "info")
            _CC_PV_LOGGER_LEVEL=3
            ;;
          "warning")
            _CC_PV_LOGGER_LEVEL=2
            ;;
          "error")
            _CC_PV_LOGGER_LEVEL=1
            ;;
          "mute")
            _CC_PV_LOGGER_LEVEL=0
            ;;
          *)
            _CC_PV_LOGGER_LEVEL=3
            ;;
      esac
      ;;
    *)
      if [ "$level" -gt "$CC_LOGGER_DEBUG" ]; then
        return "$ERROR_FAILED"
      fi
      _CC_PV_LOGGER_LEVEL="$level"
      ;;
  esac

  [ "$_CC_PV_LOGGER_LEVEL" != "$CC_LOGGER_DEBUG" ] || {
    cc::console::warning printf "YOU ARE LOGGING AT THE DEBUG LEVEL."
    cc::console::warning printf "This is NOT recommended for production use, and WILL LIKELY LEAK sensitive information to logs."
  }
}

# Sugar
cc::logger::level::set::debug(){
  cc::logger::level::set "$CC_LOGGER_DEBUG"
}

cc::logger::level::set::info(){
  cc::logger::level::set "$CC_LOGGER_INFO"
}

cc::logger::level::set::warning(){
  cc::logger::level::set "$CC_LOGGER_WARNING"
}

cc::logger::level::set::error(){
  cc::logger::level::set "$CC_LOGGER_ERROR"
}

cc::logger::mute() {
  _CC_PV_LOGGER_LEVEL=0
}

cc::logger::ismute() {
  [ "$_CC_PV_LOGGER_LEVEL" == 0 ] || return "$ERROR_FAILED"
}

cc::logger::debug(){
  _cc_private::logger::log "DEBUG" "$@"
}

cc::logger::info(){
  _cc_private::logger::log "INFO" "$@"
}

cc::logger::warning(){
  _cc_private::logger::log "WARNING" "$@"
}

cc::logger::error(){
  _cc_private::logger::log "ERROR" "$@"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provides fancy display for `set -x`
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
########################################################################################################################

cc::codecomet::tracer(){
  local length="${#BASH_SOURCE[@]}"

  #local indent=""
  local linenumber
  local filename
  local filecontent
  local funcname
  local col

  [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[1]}" == *"action.sh" ]] || return 0

  printf "\n"

  for (( j=$(( length - 1 )); j>0; j-- )); do
    [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[$j]}" == *"action.sh" ]] || {
      continue
    }

    linenumber="${BASH_LINENO[$(( j - 1 ))]}"
    filename="${BASH_SOURCE[$j]}"
    filecontent="$(cat -n "$filename" | grep -E "^\s+$linenumber\s" | sed -E "s/^\s+$linenumber\s+//")"
    funcname="${FUNCNAME[$j]}"

    # Why is this showing is a mystery for the times
    # [ "$filecontent" != "#!/usr/bin/env bash" ] || continue

    [ "$j" != 1 ] && {
      col="$CC_COLOR_DEFAULT_FRONT"
    } || {
      col="$CC_COLOR_TRACER_HUMPF"
    }

    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$filename"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$linenumber"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "function" printf "%-30s" "$funcname()"
    printf "\n"
    [ "$j" != 1 ] || {
      _cc_private::console "$CC_COLOR_TRACER_COMMAND_LABEL" "$CC_COLOR_DEFAULT_FRONT" "command" printf "%s" "$filecontent"
      _cc_private::console "$CC_COLOR_TRACER_OUTPUT_LABEL" "$CC_COLOR_DEFAULT_FRONT" "output" printf ""
    }

  done
}

cc::tracer::register(){
  # shellcheck disable=SC2016
  local ps=('$(' "$@" ')')
  export PS4="${ps[*]}"
}

cc::init::tracer(){
  cc::tracer::register cc::codecomet::tracer
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Trap management
#
# Depends on:
# colors.sh
# console.sh
########################################################################################################################

_CC_PV_TRAP_LISTENERS=()

_CC_PV_ERR_LNO=
_CC_PV_ERR_CMD=
_CC_PV_ERR_STACK=
_CC_PV_ERR_EX=

dc::trap::register(){
  _CC_PV_TRAP_LISTENERS+=( "$1" )
}

# Trap lno and cmd on ERR for future use
cc::trap::err(){
  _CC_PV_ERR_EX="$1"
  _CC_PV_ERR_LNO="$2"
  _CC_PV_ERR_CMD="$3"
  _CC_PV_ERR_STACK="$4"
  # Dropping the rest of the stack?

  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$_CC_PV_ERR_STACK"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$_CC_PV_ERR_LNO"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "exit" printf "%s" "$_CC_PV_ERR_EX"
  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "command" printf "%-30s" "$_CC_PV_ERR_CMD"
  >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  >&2 printf "\n"

  >&2 _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "source" printf ""
  prefix=" "
  for (( j=$(( _CC_PV_ERR_LNO - 3 )); j<$(( _CC_PV_ERR_LNO + 3 )); j++ )); do
    [ "$j" -gt 0 ] || continue
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=">"
      >&2 _cc_private::tput setaf "$CC_COLOR_ERROR_FRONT"
      #>&2 _cc_private::tput bold
    fi
    #  | sed -E "s/^\s+$j\s//"
    >&2 printf "%s%s" "$prefix" "$(cat -n "$_CC_PV_ERR_STACK" | grep -E "^\s+$j\s")" || true
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=" "
      >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
      #>&2 _cc_private::tput sgr0
    fi
    >&2 printf "\n"
  done
}

_CC_PV_NO_REENTRY=

# Trap exit for the actual cleanup
cc::trap::exit() {
  # { set +x; } 2>/dev/null

  local ex="$1"
  local i

  # Prevent reentrancy - XXX is this actually needed?
  [ ! "$_CC_PV_NO_REENTRY" ] || return 0
  _CC_PV_NO_REENTRY="exiting"

  printf "%s\n" "$ex" > "$CC_TMPFS"/.codecomet/logs/ex.log

  if [ "${#_CC_PV_TRAP_LISTENERS[@]}" -gt 0 ]; then
    for i in "${_CC_PV_TRAP_LISTENERS[@]}"; do
      cc::logger::debug "Calling exit hook $i"
#      >&2 printf "\n"
      "$i" "$ex" "$_CC_PV_ERR_CMD" "$_CC_PV_ERR_LNO" "$_CC_PV_ERR_STACK"
    done
  fi
  >&2 cc::console::reset
  >&2 printf "\n"
  cc::logger::debug "Exiting ($ex)"
  [ "$CC_ACTION_CAN_FAIL" == "true" ] && {
    [ "$ex" != "" ] || cc::logger::error "Action failed, but it is marked as 'can fail', so, exiting successfully"
    exit 0
  } || exit "$ex"
}

# Forking to disable xtrace when entering traps
cc::init::trap(){
  # Signals are caught by buildkit already - and only SIGKILL triggers a failure
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::err "$ex" "$LINENO" "$BASH_COMMAND" "${BASH_SOURCE[@]}"' ERR
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::exit "$ex"' EXIT
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# See https://manpages.ubuntu.com/manpages/xenial/man1/eatmydata.1.html
# Technically, we get a 10% speedup with apt operations for eg
# XXX careful here if this is going to be used in a chroot
cc::init::speedup(){
  ! command -v eatmydata >/dev/null || export LD_PRELOAD=libeatmydata.so
}

# Boot if we have an argument - otherwise, we are being sourced
if [ "$#" -gt 0 ]; then
  mkdir -p "$TMPDIR"
  rm -Rf "$CC_TMPFS"/.codecomet
  mkdir -p "$CC_TMPFS"/.codecomet/bin
  mkdir -p "$CC_TMPFS"/.codecomet/logs

  # Set logger to env var from the Bash helper
  cc::logger::level::set "$CC_LOG_LEVEL"

  # Eat data, trap, register tracer, register debugger on exit trap
  cc::init::speedup
  cc::init::trap
  cc::init::tracer
  # Live debugger is really wonky
  if [ "${CC_DEBUGGER_LIVE:-}" != "" ]; then
    cc::debugger::live &
    dc::trap::register cc::debugger::front
  else
    [ "$CC_ACTION_CAN_FAIL" == true ] || dc::trap::register cc::debugger::start
  fi

  # XXX technically, we receive a bunch of scripts, and we could just play them all - use case is not completely clear yet
  out="$CC_TMPFS"/.codecomet/logs/stdout.log
  err="$CC_TMPFS"/.codecomet/logs/stderr.log

  # Unpack libraries path and source them
  while [ "$#" -gt 1 ]; do
    cp "$1" "$CC_TMPFS"/.codecomet/bin
    # shellcheck disable=SC1090
    source "$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
    shift
  done
  cp "$1" "$CC_TMPFS"/.codecomet/bin
  _CC_PV_SCRIPT="$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
  export _CC_PV_SCRIPT

  # Run the actual action
  # shellcheck disable=SC1090
  source "$_CC_PV_SCRIPT" > >(tee -a "$out") 2> >(tee -a "$err" >&2)
else
  # If we are a library, toss this one so we do not exit on any error...
  # This is especially important for the reverse debugger
  set +o errexit
fi
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
â"Ûˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*◊
/library0.sh¿∏#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# A generic lock mechanism that supports exclusive locks, shared locks, and a simplistic queueing mechanism
_cc_lockindex=9
_cc_lock_location="/_cc/share/locks"

# Sets our locks location. Must be called to guarantee that the lock location exist.
cc::lock::init(){
	_cc_lock_location="${1:-.}"
	mkdir -p "${_cc_lock_location}"
}

# Acquire a lock with a given name, and a share mode (shared or exclusive (which is the default))
# If the lock is already acquired in a different mode, or the mode is exclusive, the function will wait until the lock is released.
# Return the lock id that you need to carry around to release the lock later on.
cc::lock::acquire(){
	local lockfile="$_cc_lock_location/$1"
	local shared="${2:-}"
	[ "$shared" ] && shared=-s || shared=-x
	_cc_lockindex=$((_cc_lockindex+1))
	mkdir -p "$(dirname "$lockfile")"
	exec {_cc_lockindex}>"$lockfile"
	flock $shared $_cc_lockindex
	return $_cc_lockindex
}

# Release a previously acquire lock by its id
cc::lock::release(){
	local idx="$1"
	# This is essentially the same
	flock -u "$idx"
	# exec {idx}>&-
}

cc::lock::queue(){
	local basepath="${1:-.}"
	local shared1="${2:-}"
	local shared2="${3:-}"
	local qid
	local oid

	# Get into the queue first
	cc::lock::acquire "$basepath"/cc_queue.lock "$shared1" || qid=$?

	# Then when out of the queue, acquire an operation lock
	cc::lock::acquire "$basepath"/cc_op.lock "$shared2" || oid=$?

	# Now, leave the queue
	cc::lock::release $qid

	# Return the lock id
	return $oid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
˙"‰·ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*»
/library1.sh¿©#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Lessons learned:
# - find -exec is VERY SLOW - better off piping to read (almost 10x) (0.2 second vs 0.02 second for about 200 files)
# - then globbing and grepping is faster than find + read
# This matters not in case we are copying a large amount of data of course, but then
# - there is no way to get something stable out of ls without further processing - directories with different owners
# for eg will widen some columns
# this "works" right now (if we do not use --numeric-uid-gid) but will be problematic outside of this specific case

_cc::fingerprint(){
  local directory="$1"
  # Will fail if the directory is empty, so the guardrail
  # Ignore directories, links, and "total" (note: -d will not work for that)
  # --numeric-uid-gid < messes up the output width
  # shellcheck disable=SC2010
  ls --full-time --almost-all --ignore lock "$directory" 2>/dev/null | grep -v "^[d|l|t]" || true
}

# Copy or symlink data "from" storage "to" destination
# This assume that storage holds only files, and no lock
# Will not copy anything if there is no difference
cc::storage::retrieve(){
  local from="$1"
  local to="$2"
  local copy="${3:-}"
  local lid
  local fromState

  # Ensure destination exists
  mkdir -p "$to"

  # Lock origin and keep the lock id
  cc::lock::acquire "$from" shared || lid=$?

  # Ensure origin exists
  mkdir -p "$from"

  # If we are asked to copy (not expected for large amount of data - linking is prefered in that case)
  if [ "$copy" ]; then
    # Retrieve the state of it
    fromState="$(_cc::fingerprint "$from")"

    # Check that we have content in storage
    # Check that we have a difference between storage and destination (ignoring directories and lock file)
    # shellcheck disable=SC2010
    # shellcheck disable=SC2015
    [ "$fromState" ] && [ "$fromState" != "$(_cc::fingerprint "$to")" ] && {
      # Then cleanup destination
      rm -Rf "$to"
      mkdir -p "$to"
      # And copy over
      cp -p "$from"/* "$to"
      # Slower
      #find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
      #  cp -p "$fd" "$to"
      #done
    } || {
      # Otherwise, do nothing
      cc::logger::debug "Nothing to retrieve from storage"
    }
  else
    # We want links, so, lets check we have anything in the origin
    #[ ! "$fromState" ] || {
    # Get rid of possibly remaining files in our destination
    find "$to" -type f -delete
    ln -sf "$from"/* "$to" 2>/dev/null || true
    # Note: below is slower
    # find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
    #  ln -s "$fd" "$to"
    # done
    #}
  fi

  # Release the lock
	cc::lock::release $lid
}

cc::storage::store(){
  local from="$1"
  local to="$2"
  local erase="${3:-}"
  local lid
  local fd
  local toState

  # Ensure origin exists
  mkdir -p "$from"

  # Lock destination and keep the lock id
  cc::lock::acquire "$to" "" || lid=$?

  # Ensure destination exists
  mkdir -p "$to"
  # Retrieve the state of it
  # shellcheck disable=SC2010
  toState="$(_cc::fingerprint "$to")"

  # Compare state of the destination with the origin (origin ignores directories and lock files)
  # shellcheck disable=SC2010
  # shellcheck disable=SC2015
  [ "$toState" != "$(_cc::fingerprint "$from")" ] && {
    # We have changes - if asked to wipe out, do so
    if [ "$erase" ]; then
      rm -Rf "$to"
      mkdir -p "$to"
    fi
    # Now copy the files
    # This is probably slow-ish. The question is: will it be significant in a context where copy IO is the bottleneck?
    find "$from" -type f -not -iname "lock" -print0 | while IFS= read -r -d $'\0' fd; do
      cp -p "$fd" "$to"
    done
  } || {
    cc::logger::debug "Nothing to save to storage"
  }

  # Release the lock
	cc::lock::release $lid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
Ï*"÷*”*ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∫*
/library2.sh¿õ*#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Helpers to allow apt to share cache properly

# Private tmpfs location
_cc_tmpfs_location=/codecomet/apt-get-private/tmp

# Location of the list cache
_cc_apt_list_store_location=/codecomet/apt-get-shared/lists
# And pack cache
_cc_apt_pack_local_location=/codecomet/apt-get-shared/packs

# Location of the packages cache
_cc_apt_pack_store_location=/codecomet/apt-get-shared/cache

# Location of our private lists files - by default, Debian normal location, which means state will persist
_cc_apt_list_local_location=/var/lib/apt/lists

# Location of the config file
export APT_CONFIG=$_cc_tmpfs_location/apt-get.conf

# Hash of the sources.list, which dictates the cache location to share
# Different sources means different cache location
# Caveats: this will likely not work with a future debian release as they change the sources.list format
# XXX this wracking the debugger output
cc::apt_get::shard(){
  sha256sum <<< "$(uname -m)$(grep --no-filename -Ev "^#" /etc/apt/sources.list /etc/apt/sources.list.d/* 2>/dev/null | sed -E 's/#.+$//' | sort || true)" | sed -E 's/  .*//'
}

# Set the tmp location, initiliaze APT_CONFIG and shared and private locations
cc::apt_get::init(){
  # Get the desired tmpfs mount point
  _cc_tmpfs_location="$1"

  mkdir -p "$_cc_tmpfs_location"

  # Point configuration there
  export APT_CONFIG="$_cc_tmpfs_location"/apt-get.conf

  # Sharding by sources list content, cleaned-up and sorted to maximize cache hits
	_cc_apt_list_store_location="$2/$(cc::apt_get::shard)"

  # Technically, we should not be sharding the architecture
  # But then, the only upside would be when installing cross-arch packages
	_cc_apt_pack_store_location="$3/$(cc::apt_get::shard)"

  # If we do not want lists to persist, use the tmp storage
  [ "${4:-}" == true ] || _cc_apt_list_local_location="$_cc_tmpfs_location"/lists

  # Finally, local pack location
  _cc_apt_pack_local_location="$_cc_tmpfs_location"/packs

  # Make sure they all exist
  mkdir -p "$_cc_apt_list_local_location"
  mkdir -p "$_cc_apt_pack_local_location"

  mkdir -p "$_cc_apt_list_store_location"
  mkdir -p "$_cc_apt_pack_store_location"
}

# Create the configuration file for APT
cc::apt_get::configure(){
  local config_extra="${1:-}"
  local persist="${2:-}"

  mkdir -p "$_cc_tmpfs_location/logs"
  cat << EOF > "$APT_CONFIG"
# Divert both lists and archives location
Dir::Cache::Archives "$_cc_apt_pack_local_location";
Dir::State::Lists "$_cc_apt_list_local_location";
# Prevent the default apt config to be used
Dir::Etc::parts "";
# Put the logs in the tmp zone
Dir::Log "$_cc_tmpfs_location/logs";
# Put the bin cache files in the private mount
Dir::Cache::srcpkgcache "$_cc_tmpfs_location/srcpkgcache.bin";
Dir::Cache::pkgcache "$_cc_tmpfs_location/pkgcache.bin";

$config_extra
EOF

  # If asked to persist the config, copy over the generated file
  [ "$persist" == "false" ] || cp "$APT_CONFIG" /etc/apt/apt.conf
}

#cc::apt_get::cleanup(){
  # This is only necessary if we were not using an tmpfs mount...
  # rm "$APT_CONFIG"
#}

cc::apt_get::update(){
  # Remove our marker if here
  rm -f "$_cc_apt_list_local_location"/.cc_updated

  # Retrieve existing data
  cc::storage::retrieve "$_cc_apt_list_store_location" "$_cc_apt_list_local_location" copy

	# Do the deed, same restriction applies
	apt-get update "$@"

  # Save it back (storage will decide)
  cc::storage::store "$_cc_apt_list_local_location" "$_cc_apt_list_store_location" erase

  # Now, flag it
  date > "$_cc_apt_list_local_location"/.cc_updated
}

cc::apt_get::do(){
  # Bring in any cache
  cc::storage::retrieve "$_cc_apt_pack_store_location" "$_cc_apt_pack_local_location"

	apt-get "$@"

  # Store the packages permanently
  cc::storage::store "$_cc_apt_pack_local_location" "$_cc_apt_pack_store_location"
}

# XXX what if sources are being modified, or config, or something else that materially impacts update?
cc::high::update(){
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "$nooutput"

  args+=("$@")
  time cc::apt_get::update "${args[@]}"
}

cc::high::install(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists has been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  args+=("$@")
  time cc::apt_get::do install "${args[@]}"
}

cc::high::upgrade(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists have been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  # ls -lAR "$_cc_tmpfs_location"/packs || true
  # time cc::apt_get::do upgrade "$nooutput" "$@"

  # XXX WIP here
  # Bust cache - delete this
  #time cc::apt_get::do upgrade --download-only "$nooutput" "$@"
  #time cc::apt_get::do upgrade --no-download "$nooutput" "$@"
  args+=("$@")
  time cc::apt_get::do upgrade "${args[@]}"
}

cc::high::purge(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")

  args+=("$@")
  time cc::apt_get::do purge --auto-remove "${args[@]}"
}(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
’"øºˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*£

/action.sh¿Ü#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::upgrade

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f7942
 



Z 
£
I
Gsha256:aba97bce52cb75c817d06fec2353f811940c416a472ab6b0fab8ae0a54511d83
I
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
arm64linuxZ 
Í"‘—ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∏

/action.sh¿õ#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::install eatmydata nano socat

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c2
 



Z 
£
I
Gsha256:1f71c46c8f58462f657331fc0617521fb54f9990f04397320f86547435ca03f3
I
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
arm64linuxZ 
K
I
Gsha256:c7759768f7674d770a8a4ef7c18d38e5c0deb872d612f1f8102e8bdebc9bcf0eπ
Gsha256:1f71c46c8f58462f657331fc0617521fb54f9990f04397320f86547435ca03f3Ì!
codecomet.optest codecomet op!
llb.customnameapt-get upgrade*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeü
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library2.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library1.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962—!
codecomet.optest codecomet op0
llb.customname[action:addfile] codecomet in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupË
Gsha256:aba97bce52cb75c817d06fec2353f811940c416a472ab6b0fab8ae0a54511d83ú!
codecomet.optest codecomet opG
llb.customname5[source:image] docker.io/library/debian:bullseye-slim*
source.image*
source.image.resolvemodeê
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edfƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library0.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupŒ
Gsha256:c7759768f7674d770a8a4ef7c18d38e5c0deb872d612f1f8102e8bdebc9bcf0eÇ!
codecomet.optest codecomet op6
llb.customname$apt-get install eatmydata nano socat*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeÄ
Gsha256:e0223abffd3a522e48edba08a44b777ad6b5b53eaafcfe5f5f7ae63aaa1097405*
constraints*
meta.description*
platformê
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8aƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupœ
K
Gsha256:1f71c46c8f58462f657331fc0617521fb54f9990f04397320f86547435ca03f3 
K
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f 
K
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7 
K
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962 
K
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c 
K
Gsha256:aba97bce52cb75c817d06fec2353f811940c416a472ab6b0fab8ae0a54511d83 
K
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf 
K
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c 
K
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794 
K
Gsha256:c7759768f7674d770a8a4ef7c18d38e5c0deb872d612f1f8102e8bdebc9bcf0e 
K
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a 
hR
5docker-image://docker.io/library/debian:bullseye-slim
image.resolvemodepullR
armlinuxv7Z 
æ›"ß›£›ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*â›

/codecomet¿Î‹#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Defines the supported color palette, and our color scheme
########################################################################################################################

# Supported color palette
readonly _CC_PV_COLOR_BLACK=0
readonly _CC_PV_COLOR_RED=1
readonly _CC_PV_COLOR_GREEN=2
readonly _CC_PV_COLOR_YELLOW=3
# shellcheck disable=SC2034
readonly _CC_PV_COLOR_BLUE=4
readonly _CC_PV_COLOR_MAGENTA=5
readonly _CC_PV_COLOR_CYAN=6
readonly _CC_PV_COLOR_WHITE=7

# Colors scheme definition - can evidently be customized at runtime by setting these variables to other values from the palette
export CC_COLOR_DEFAULT_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEFAULT_BACK="$_CC_PV_COLOR_BLACK"

export CC_COLOR_BODY="$_CC_PV_COLOR_WHITE"
export CC_COLOR_COMMENT="$_CC_PV_COLOR_CYAN"
export CC_COLOR_HUMPF="$_CC_PV_COLOR_MAGENTA"

# Logger
export CC_COLOR_ERROR_FRONT="$_CC_PV_COLOR_RED"
export CC_COLOR_ERROR_BACK="$_CC_PV_COLOR_WHITE"
export CC_COLOR_WARNING_FRONT="$_CC_PV_COLOR_YELLOW"
export CC_COLOR_WARNING_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_INFO_FRONT="$_CC_PV_COLOR_GREEN"
export CC_COLOR_INFO_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_DEBUG_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEBUG_BACK="$_CC_PV_COLOR_BLACK"

# Tracer
export CC_COLOR_TRACER_HUMPF="$_CC_PV_COLOR_GREEN"
export CC_COLOR_TRACER_COMMAND_LABEL="$_CC_PV_COLOR_BLUE"
export CC_COLOR_TRACER_OUTPUT_LABEL="$_CC_PV_COLOR_RED"
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provide helpers to print colorful text
#
# Depends on:
# defaults.sh
# colors.sh
########################################################################################################################

_cc_private::tput(){
  [ ! "$CC_CAP_HAS_TERM" ] || [ "$CC_CAP_NO_COLOR" != "" ] || tput "$@" 2>/dev/null || true
}

_cc_private::console::inline(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it and pad to 7 chars, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"
}

_cc_private::console(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-7s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    # Otherwise, just a plain front/back
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"

  # Restore console to default before we \n so that we do not leak over into BK timestamp display
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::error(){
  _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_ERROR_BACK" "error" "$@"
}

cc::console::warning(){
  _cc_private::console "$CC_COLOR_WARNING_FRONT" "$CC_COLOR_WARNING_BACK" "warning" "$@"
}

cc::console::info(){
  _cc_private::console "$CC_COLOR_INFO_FRONT" "$CC_COLOR_INFO_BACK" "info" "$@"
}

cc::console::debug(){
  _cc_private::console "$CC_COLOR_DEBUG_FRONT" "$CC_COLOR_DEBUG_BACK" "debug" "$@"
}

cc::console::body(){
  _cc_private::console "$CC_COLOR_BODY" "" "" "$@"
}

cc::console::comment(){
  _cc_private::console "$CC_COLOR_COMMENT" "" "" "$@"
}

cc::console::humpf(){
  _cc_private::console "$CC_COLOR_HUMPF" "" "" "$@"
}

cc::console::reset(){
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::end(){
  _cc_private::tput op
  printf "\n"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Debugger based on socat
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
# logger.sh
########################################################################################################################

# Fancy prompt adapted from https://github.com/pombadev/fancy-linux-prompt/blob/master/LICENSE under MIT License
__powerline() {
    # Unicode symbols
    readonly GIT_NEED_PULL_SYMBOL='‚á£'
    readonly GIT_NEED_PUSH_SYMBOL='‚á°'
    readonly PS_SYMBOL='ü™ê' # üêß‚òÑ'‚ñ∂‚èµ‚ñ∂‚èµ

    # Solarized colorscheme
    readonly BG_BLUE="\\[$(tput setab 4)\\]"
    readonly BG_COLOR5="\\[\\e[48;5;31m\\]"
    readonly BG_COLOR8="\\[\\e[48;5;161m\\]"
    readonly BG_GREEN="\\[$(tput setab 2)\\]"
    readonly BG_RED="\\[$(tput setab 1)\\]"
    readonly FG_BASE3="\\[$(tput setaf 15)\\]"
    readonly FG_BLUE="\\[$(tput setaf 4)\\]"
    readonly FG_COLOR1="\\[\\e[38;5;250m\\]"
    readonly FG_COLOR6="\\[\\e[38;5;31m\\]"
    readonly FG_COLOR9="\\[\\e[38;5;161m\\]"
    readonly FG_GREEN="\\[$(tput setaf 2)\\]"
    readonly FG_RED="\\[$(tput setaf 1)\\]"
    readonly RESET="\\[$(tput sgr0)\\]"

    __git_info() {
        # has a .git directory and a git binary
    	[ -d .git ] || command -v git >/dev/null || return 0

        local aheadN
        local behindN
        local branch
        local marks=""
        local stats

        # get current branch name or short SHA1 hash for detached head
        branch="$(git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --always 2>/dev/null)"
        [ -n "$branch" ] || return 0 # git branch not found

        # how many commits local branch is ahead/behind of remote?
        stats="$(git status --porcelain --branch | grep '^##' | grep -o '\[.\+\]$')"
        aheadN="$(echo "$stats" | grep -o 'ahead \d\+' | grep -o '\d\+')"
        behindN="$(echo "$stats" | grep -o 'behind \d\+' | grep -o '\d\+')"
        [ -n "$aheadN" ] && marks+=" $GIT_NEED_PUSH_SYMBOL$aheadN"
        [ -n "$behindN" ] && marks+=" $GIT_NEED_PULL_SYMBOL$behindN"

        # print the git branch segment without a trailing newline
        # branch is modified?
        if [ -n "$(git status --porcelain)" ]; then
            printf "%s" "${BG_COLOR8}‚ñ∂$RESET$BG_COLOR8 $branch$marks $FG_COLOR9"
        else
            printf "%s" "${BG_BLUE}‚ñ∂$RESET$BG_BLUE $branch$marks $RESET$FG_BLUE"
        fi
    }


    ps1() {
        # Check the exit code of the previous command and display different
        # colors in the prompt accordingly.
        if [ "$?" -eq 0 ]; then
            local BG_EXIT="$BG_GREEN"
            local FG_EXIT="$FG_GREEN"
        else
            local BG_EXIT="$BG_RED"
            local FG_EXIT="$FG_RED"
        fi

        PS1="$FG_COLOR1$BG_COLOR5 CodeComet \\w "
        PS1+="$RESET${FG_COLOR6}"
        PS1+="$(__git_info)"
        PS1+="$BG_EXIT‚ñ∂$RESET"
        PS1+="$BG_EXIT$FG_BASE3 ${PS_SYMBOL} ${RESET}${FG_EXIT}‚ñ∂${RESET} "
    }

    PROMPT_COMMAND=ps1
}

_cc_private::debugger::setup(){
  # Set-up PS1
  cat << EOF > "$CC_TMPFS"/.profile
# export PS1='\[\033[01;32m\]CodeComet\[\033[00m\] \w \$ '
alias l="ls -lA"
source ${BASH_SOURCE[0]}
umask 077
export LSCOLORS=exfxcxdxbxegedabagacad
export CLICOLOR=1

_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Welcome!" printf "You are now debugging your pipeline at the point it stopped.\n"
printf "\n"
#_cc_private::console::inline "$_CC_PV_COLOR_BLACK" "$_CC_PV_COLOR_BLACK" "         " printf ""
printf "Environment, pwd, and filesystem, are exactly as they were when the last action failed.\n"
printf "You can call the following helpers:\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdout" printf "will output your action stdout\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stderr" printf "will output your action stderr\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdex " printf "will output your action exit code\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_action" printf "will output the location of your action script\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Tip           " printf "If you want to re-run your action, just call \\\$(ccdebug_action)\n"

# touch "$CC_TMPFS/.codecomet/connected"
__powerline

EOF

  cat << EOF >> "$CC_TMPFS"/.inputrc
"\e[A": history-search-backward
"\e[B": history-search-forward
set show-all-if-ambiguous on
set completion-ignore-case on

EOF

}

# "on demand
# "Abnormal exit, with non zero grace:
# - start debugger repeatedly, with grace
# - once the other end exits, bail out

# "live", with non zero grace
# - start debugger, with infinity grace
# - if the other end was connected and exited, that is it, end of story
# - if the other end is still running, bring socat forward and wait for the end to exit
# - if there was no other end, we should branch back to the first scenario

# This is called on trap ERR, if a live debugger has been running, and will make a decision to bring it back forward and keep it alive,
# or to drop it
cc::debugger::front(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  cc::logger::debug "[debugger-front] socat is here"
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  cc::logger::debug "[debugger-front] grace is fine"


  # Debugger still live? Bail out if not
  jobs | grep -q -v Done || {
    cc::logger::debug "[debugger-front] no jobs detected. Bailing out."
    return 0
  }

  # Ok, it is live. Do we have a client?
  # XXX unfortunately, this does not work as expected... socat does start the process first, bash sources the files and create the stamp file...
  local lasttry
  local current
  lasttry="$(cat $CC_TMPFS/.codecomet/lasttry 2>/dev/null)" || true
  current="$(date +%s)"
  # The older an unconnected socat could be is 2 seconds - if greater than that, then we definitely have a client
  # However, it is possible that a client has been connected for less than 2 seconds (since socat call) when the failure happens,
  # which means the client will wrongly get the boot... no good solution right now
  [ $(( current - lasttry)) -gt 2 ] && {
  # [ -e "$CC_TMPFS/.codecomet/connected" ] && {
    cc::logger::debug "[debugger-front] we have a connected client"
    # Yes, then foreground and let it sit
    fg 2>/dev/null
  } || {
    cc::logger::debug "[debugger-front] no live client. Kick it out restart."
    # No live client. Kill it, and start again the normal process with timeout and message
    kill %%
    cc::debugger::start "$ex"
  }
}

# XXX this is largely broken
cc::debugger::live(){
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  while true; do
    lasttry="$(date +%s)"
    printf "%s" "$lasttry" > "$CC_TMPFS/.codecomet/lasttry"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-live] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Break if we have been hanging out more than a second (meaning the other end did connect, but exit in error)
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-live] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
    }
    x=$(( x + 1 ))
    cc::logger::debug "[debugger-live] sleeping"
    sleep 1
  done
}

cc::debugger::start(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  # Prep-up profile
  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  cc::logger::error "Abnormal exit code $ex. If you want to inspect manually, start codecomet-debugger. Otherwise, we will exit after $CC_DEBUGGER_GRACE seconds"
  cc::logger::error "You can also restart the build with CODECOMET_DEBUG=true"

  >&2 _cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "waiting" printf "Waiting %s seconds for debugger to connect" "$CC_DEBUGGER_GRACE"
  # cc::logger::warning "Waiting "


  # https://medium.com/@JAlblas/tryhackme-what-the-shell-walkthrough-6c0ebe8f854e
  #pty, allocates a pseudoterminal on the target ‚Äî part of the stabilisation process
  #stderr, makes sure that any error messages get shown in the shell (often a problem with non-interactive shells)
  #sigint, passes any Ctrl + C commands through into the sub-process, allowing us to kill commands inside the shell
  #setsid, creates the process in a new session
  #sane, stabilises the terminal, attempting to ‚Äúnormalise‚Äù it.

  while [ "$x" -lt "$CC_DEBUGGER_GRACE" ]; do
    lasttry="$(date +%s)"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-stat] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Timeing out means we wait for a second. Any more than that should mean the connection was succesful
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-stat] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
      >&2 printf "."
    }
    x=$(( x + 1 ))
    sleep 1
  done
}

ccdebug_stdout(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stdout.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stdout.log
  fi
}

ccdebug_stderr(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stderr.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stderr.log
  fi
}

ccdebug_stdex(){
  [ -e "$CC_TMPFS"/.codecomet/logs/ex.log ] && {
    cat "$CC_TMPFS"/.codecomet/logs/ex.log
  } || {
    cc::logger::warning "Action is in progress, no exit code yet"
  }
}

ccdebug_action(){
  echo "$_CC_PV_SCRIPT"
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# List all environment variables we depend on, possibly providing defaults
########################################################################################################################

#############
# Generic controls
#############
# Log level to start with (error, warning, info, debug or 4, 3, 2, 1, 0 <- mute)
readonly CC_LOG_LEVEL="${CC_LOG_LEVEL:-}"
# Where is the tempfs mounted
readonly CC_TMPFS="${CC_TMPFS:-}"
# Honors NO_COLOR (see https://no-color.org/)
# shellcheck disable=SC2034
readonly CC_CAP_NO_COLOR="${NO_COLOR:-}"
# About detection
# https://stackoverflow.com/questions/911168/how-can-i-detect-if-my-shell-script-is-running-through-a-pipe
# Could also test for [ ! -t 2 ]
# Or could be: `test -t 0` (formerly `tty -s`)
# In our context though, this probably does not matter much
# shellcheck disable=SC2034
readonly CC_CAP_HAS_TERM="${TERM:-}"

#############
# Action execution flow control
#############
# Whether the action can fail or not
readonly CC_ACTION_CAN_FAIL="${CC_ACTION_CAN_FAIL:-}"

#############
# Tracing and debugging
#############
# Controls wether the tracer will also trace internal codecomet library or hide them
readonly CC_TRACER_CODECOMET_INTERNALS="${CC_TRACER_CODECOMET_INTERNALS:-}"
# How long to wait for a connection before dropping the debugger
export CC_DEBUGGER_GRACE="${CC_DEBUGGER_GRACE:-}"
# Port to connect to
readonly CC_DEBUGGER_PORT="${CC_DEBUGGER_PORT:-}"
# IP to connect to
readonly CC_DEBUGGER_IP="${CC_DEBUGGER_IP:-}"
# Whether a debugger should be started pre-emptively so that one can hook in "live" during the action. This is very wonky as soon as you have parallelism...
readonly CC_DEBUGGER_LIVE="${CC_DEBUGGER_LIVE:-}"


#############
# Error code used accross the codebase - rn, only the bland FAILED is used...
#############
# shellcheck disable=SC2034
readonly ERROR_NETWORK=200
# Thrown if a required argument is missing
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_MISSING=201
# Thrown if an argument does not match validation
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_INVALID=202
# Should be used to convey that a certain operation is not supported
# shellcheck disable=SC2034
readonly ERROR_UNSUPPORTED=203
# Generic error to denote that the operation has failed. More specific errors may be provided instead
# shellcheck disable=SC2034
readonly ERROR_FAILED=204
# Expectations failed on a file (not readable, writable, doesn't exist, can't be created)
# shellcheck disable=SC2034
readonly ERROR_FILESYSTEM=205
# System requirements
# shellcheck disable=SC2034
readonly ERROR_MISSING_REQUIREMENTS=206

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# A generic logger
#
# Depends on:
# console.sh
########################################################################################################################

readonly CC_LOGGER_DEBUG=4
readonly CC_LOGGER_INFO=3
readonly CC_LOGGER_WARNING=2
readonly CC_LOGGER_ERROR=1

_CC_PV_LOGGER_LEVEL="$CC_LOGGER_WARNING"

_cc_private::logger::log(){
  local prefix="$1"
  shift

  local level="CC_LOGGER_$prefix"
  local i

  [ "$_CC_PV_LOGGER_LEVEL" -ge "${!level}" ] || return 0

  # About the crazy shit: https://stackoverflow.com/questions/12674783/bash-double-process-substitution-gives-bad-file-descriptor
  exec 3>&2
  for i in "$@"; do
    >&2 cc::console::"$(printf "$prefix" | tr '[:upper:]' '[:lower:]')" printf "$i"
  done
  exec 3>&-
}

cc::logger::level::set() {
  local level
  level="$(printf "%s" "${1:-}" | tr '[:upper:]' '[:lower:]')"

  case "$level" in
    ''|*[!0-9]*)
      case "$level" in
          "debug")
            _CC_PV_LOGGER_LEVEL=4
            ;;
          "info")
            _CC_PV_LOGGER_LEVEL=3
            ;;
          "warning")
            _CC_PV_LOGGER_LEVEL=2
            ;;
          "error")
            _CC_PV_LOGGER_LEVEL=1
            ;;
          "mute")
            _CC_PV_LOGGER_LEVEL=0
            ;;
          *)
            _CC_PV_LOGGER_LEVEL=3
            ;;
      esac
      ;;
    *)
      if [ "$level" -gt "$CC_LOGGER_DEBUG" ]; then
        return "$ERROR_FAILED"
      fi
      _CC_PV_LOGGER_LEVEL="$level"
      ;;
  esac

  [ "$_CC_PV_LOGGER_LEVEL" != "$CC_LOGGER_DEBUG" ] || {
    cc::console::warning printf "YOU ARE LOGGING AT THE DEBUG LEVEL."
    cc::console::warning printf "This is NOT recommended for production use, and WILL LIKELY LEAK sensitive information to logs."
  }
}

# Sugar
cc::logger::level::set::debug(){
  cc::logger::level::set "$CC_LOGGER_DEBUG"
}

cc::logger::level::set::info(){
  cc::logger::level::set "$CC_LOGGER_INFO"
}

cc::logger::level::set::warning(){
  cc::logger::level::set "$CC_LOGGER_WARNING"
}

cc::logger::level::set::error(){
  cc::logger::level::set "$CC_LOGGER_ERROR"
}

cc::logger::mute() {
  _CC_PV_LOGGER_LEVEL=0
}

cc::logger::ismute() {
  [ "$_CC_PV_LOGGER_LEVEL" == 0 ] || return "$ERROR_FAILED"
}

cc::logger::debug(){
  _cc_private::logger::log "DEBUG" "$@"
}

cc::logger::info(){
  _cc_private::logger::log "INFO" "$@"
}

cc::logger::warning(){
  _cc_private::logger::log "WARNING" "$@"
}

cc::logger::error(){
  _cc_private::logger::log "ERROR" "$@"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provides fancy display for `set -x`
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
########################################################################################################################

cc::codecomet::tracer(){
  local length="${#BASH_SOURCE[@]}"

  #local indent=""
  local linenumber
  local filename
  local filecontent
  local funcname
  local col

  [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[1]}" == *"action.sh" ]] || return 0

  printf "\n"

  for (( j=$(( length - 1 )); j>0; j-- )); do
    [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[$j]}" == *"action.sh" ]] || {
      continue
    }

    linenumber="${BASH_LINENO[$(( j - 1 ))]}"
    filename="${BASH_SOURCE[$j]}"
    filecontent="$(cat -n "$filename" | grep -E "^\s+$linenumber\s" | sed -E "s/^\s+$linenumber\s+//")"
    funcname="${FUNCNAME[$j]}"

    # Why is this showing is a mystery for the times
    # [ "$filecontent" != "#!/usr/bin/env bash" ] || continue

    [ "$j" != 1 ] && {
      col="$CC_COLOR_DEFAULT_FRONT"
    } || {
      col="$CC_COLOR_TRACER_HUMPF"
    }

    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$filename"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$linenumber"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "function" printf "%-30s" "$funcname()"
    printf "\n"
    [ "$j" != 1 ] || {
      _cc_private::console "$CC_COLOR_TRACER_COMMAND_LABEL" "$CC_COLOR_DEFAULT_FRONT" "command" printf "%s" "$filecontent"
      _cc_private::console "$CC_COLOR_TRACER_OUTPUT_LABEL" "$CC_COLOR_DEFAULT_FRONT" "output" printf ""
    }

  done
}

cc::tracer::register(){
  # shellcheck disable=SC2016
  local ps=('$(' "$@" ')')
  export PS4="${ps[*]}"
}

cc::init::tracer(){
  cc::tracer::register cc::codecomet::tracer
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Trap management
#
# Depends on:
# colors.sh
# console.sh
########################################################################################################################

_CC_PV_TRAP_LISTENERS=()

_CC_PV_ERR_LNO=
_CC_PV_ERR_CMD=
_CC_PV_ERR_STACK=
_CC_PV_ERR_EX=

dc::trap::register(){
  _CC_PV_TRAP_LISTENERS+=( "$1" )
}

# Trap lno and cmd on ERR for future use
cc::trap::err(){
  _CC_PV_ERR_EX="$1"
  _CC_PV_ERR_LNO="$2"
  _CC_PV_ERR_CMD="$3"
  _CC_PV_ERR_STACK="$4"
  # Dropping the rest of the stack?

  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$_CC_PV_ERR_STACK"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$_CC_PV_ERR_LNO"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "exit" printf "%s" "$_CC_PV_ERR_EX"
  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "command" printf "%-30s" "$_CC_PV_ERR_CMD"
  >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  >&2 printf "\n"

  >&2 _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "source" printf ""
  prefix=" "
  for (( j=$(( _CC_PV_ERR_LNO - 3 )); j<$(( _CC_PV_ERR_LNO + 3 )); j++ )); do
    [ "$j" -gt 0 ] || continue
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=">"
      >&2 _cc_private::tput setaf "$CC_COLOR_ERROR_FRONT"
      #>&2 _cc_private::tput bold
    fi
    #  | sed -E "s/^\s+$j\s//"
    >&2 printf "%s%s" "$prefix" "$(cat -n "$_CC_PV_ERR_STACK" | grep -E "^\s+$j\s")" || true
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=" "
      >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
      #>&2 _cc_private::tput sgr0
    fi
    >&2 printf "\n"
  done
}

_CC_PV_NO_REENTRY=

# Trap exit for the actual cleanup
cc::trap::exit() {
  # { set +x; } 2>/dev/null

  local ex="$1"
  local i

  # Prevent reentrancy - XXX is this actually needed?
  [ ! "$_CC_PV_NO_REENTRY" ] || return 0
  _CC_PV_NO_REENTRY="exiting"

  printf "%s\n" "$ex" > "$CC_TMPFS"/.codecomet/logs/ex.log

  if [ "${#_CC_PV_TRAP_LISTENERS[@]}" -gt 0 ]; then
    for i in "${_CC_PV_TRAP_LISTENERS[@]}"; do
      cc::logger::debug "Calling exit hook $i"
#      >&2 printf "\n"
      "$i" "$ex" "$_CC_PV_ERR_CMD" "$_CC_PV_ERR_LNO" "$_CC_PV_ERR_STACK"
    done
  fi
  >&2 cc::console::reset
  >&2 printf "\n"
  cc::logger::debug "Exiting ($ex)"
  [ "$CC_ACTION_CAN_FAIL" == "true" ] && {
    [ "$ex" != "" ] || cc::logger::error "Action failed, but it is marked as 'can fail', so, exiting successfully"
    exit 0
  } || exit "$ex"
}

# Forking to disable xtrace when entering traps
cc::init::trap(){
  # Signals are caught by buildkit already - and only SIGKILL triggers a failure
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::err "$ex" "$LINENO" "$BASH_COMMAND" "${BASH_SOURCE[@]}"' ERR
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::exit "$ex"' EXIT
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# See https://manpages.ubuntu.com/manpages/xenial/man1/eatmydata.1.html
# Technically, we get a 10% speedup with apt operations for eg
# XXX careful here if this is going to be used in a chroot
cc::init::speedup(){
  ! command -v eatmydata >/dev/null || export LD_PRELOAD=libeatmydata.so
}

# Boot if we have an argument - otherwise, we are being sourced
if [ "$#" -gt 0 ]; then
  mkdir -p "$TMPDIR"
  rm -Rf "$CC_TMPFS"/.codecomet
  mkdir -p "$CC_TMPFS"/.codecomet/bin
  mkdir -p "$CC_TMPFS"/.codecomet/logs

  # Set logger to env var from the Bash helper
  cc::logger::level::set "$CC_LOG_LEVEL"

  # Eat data, trap, register tracer, register debugger on exit trap
  cc::init::speedup
  cc::init::trap
  cc::init::tracer
  # Live debugger is really wonky
  if [ "${CC_DEBUGGER_LIVE:-}" != "" ]; then
    cc::debugger::live &
    dc::trap::register cc::debugger::front
  else
    [ "$CC_ACTION_CAN_FAIL" == true ] || dc::trap::register cc::debugger::start
  fi

  # XXX technically, we receive a bunch of scripts, and we could just play them all - use case is not completely clear yet
  out="$CC_TMPFS"/.codecomet/logs/stdout.log
  err="$CC_TMPFS"/.codecomet/logs/stderr.log

  # Unpack libraries path and source them
  while [ "$#" -gt 1 ]; do
    cp "$1" "$CC_TMPFS"/.codecomet/bin
    # shellcheck disable=SC1090
    source "$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
    shift
  done
  cp "$1" "$CC_TMPFS"/.codecomet/bin
  _CC_PV_SCRIPT="$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
  export _CC_PV_SCRIPT

  # Run the actual action
  # shellcheck disable=SC1090
  source "$_CC_PV_SCRIPT" > >(tee -a "$out") 2> >(tee -a "$err" >&2)
else
  # If we are a library, toss this one so we do not exit on any error...
  # This is especially important for the reverse debugger
  set +o errexit
fi
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
â"Ûˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*◊
/library0.sh¿∏#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# A generic lock mechanism that supports exclusive locks, shared locks, and a simplistic queueing mechanism
_cc_lockindex=9
_cc_lock_location="/_cc/share/locks"

# Sets our locks location. Must be called to guarantee that the lock location exist.
cc::lock::init(){
	_cc_lock_location="${1:-.}"
	mkdir -p "${_cc_lock_location}"
}

# Acquire a lock with a given name, and a share mode (shared or exclusive (which is the default))
# If the lock is already acquired in a different mode, or the mode is exclusive, the function will wait until the lock is released.
# Return the lock id that you need to carry around to release the lock later on.
cc::lock::acquire(){
	local lockfile="$_cc_lock_location/$1"
	local shared="${2:-}"
	[ "$shared" ] && shared=-s || shared=-x
	_cc_lockindex=$((_cc_lockindex+1))
	mkdir -p "$(dirname "$lockfile")"
	exec {_cc_lockindex}>"$lockfile"
	flock $shared $_cc_lockindex
	return $_cc_lockindex
}

# Release a previously acquire lock by its id
cc::lock::release(){
	local idx="$1"
	# This is essentially the same
	flock -u "$idx"
	# exec {idx}>&-
}

cc::lock::queue(){
	local basepath="${1:-.}"
	local shared1="${2:-}"
	local shared2="${3:-}"
	local qid
	local oid

	# Get into the queue first
	cc::lock::acquire "$basepath"/cc_queue.lock "$shared1" || qid=$?

	# Then when out of the queue, acquire an operation lock
	cc::lock::acquire "$basepath"/cc_op.lock "$shared2" || oid=$?

	# Now, leave the queue
	cc::lock::release $qid

	# Return the lock id
	return $oid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
˙"‰·ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*»
/library1.sh¿©#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Lessons learned:
# - find -exec is VERY SLOW - better off piping to read (almost 10x) (0.2 second vs 0.02 second for about 200 files)
# - then globbing and grepping is faster than find + read
# This matters not in case we are copying a large amount of data of course, but then
# - there is no way to get something stable out of ls without further processing - directories with different owners
# for eg will widen some columns
# this "works" right now (if we do not use --numeric-uid-gid) but will be problematic outside of this specific case

_cc::fingerprint(){
  local directory="$1"
  # Will fail if the directory is empty, so the guardrail
  # Ignore directories, links, and "total" (note: -d will not work for that)
  # --numeric-uid-gid < messes up the output width
  # shellcheck disable=SC2010
  ls --full-time --almost-all --ignore lock "$directory" 2>/dev/null | grep -v "^[d|l|t]" || true
}

# Copy or symlink data "from" storage "to" destination
# This assume that storage holds only files, and no lock
# Will not copy anything if there is no difference
cc::storage::retrieve(){
  local from="$1"
  local to="$2"
  local copy="${3:-}"
  local lid
  local fromState

  # Ensure destination exists
  mkdir -p "$to"

  # Lock origin and keep the lock id
  cc::lock::acquire "$from" shared || lid=$?

  # Ensure origin exists
  mkdir -p "$from"

  # If we are asked to copy (not expected for large amount of data - linking is prefered in that case)
  if [ "$copy" ]; then
    # Retrieve the state of it
    fromState="$(_cc::fingerprint "$from")"

    # Check that we have content in storage
    # Check that we have a difference between storage and destination (ignoring directories and lock file)
    # shellcheck disable=SC2010
    # shellcheck disable=SC2015
    [ "$fromState" ] && [ "$fromState" != "$(_cc::fingerprint "$to")" ] && {
      # Then cleanup destination
      rm -Rf "$to"
      mkdir -p "$to"
      # And copy over
      cp -p "$from"/* "$to"
      # Slower
      #find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
      #  cp -p "$fd" "$to"
      #done
    } || {
      # Otherwise, do nothing
      cc::logger::debug "Nothing to retrieve from storage"
    }
  else
    # We want links, so, lets check we have anything in the origin
    #[ ! "$fromState" ] || {
    # Get rid of possibly remaining files in our destination
    find "$to" -type f -delete
    ln -sf "$from"/* "$to" 2>/dev/null || true
    # Note: below is slower
    # find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
    #  ln -s "$fd" "$to"
    # done
    #}
  fi

  # Release the lock
	cc::lock::release $lid
}

cc::storage::store(){
  local from="$1"
  local to="$2"
  local erase="${3:-}"
  local lid
  local fd
  local toState

  # Ensure origin exists
  mkdir -p "$from"

  # Lock destination and keep the lock id
  cc::lock::acquire "$to" "" || lid=$?

  # Ensure destination exists
  mkdir -p "$to"
  # Retrieve the state of it
  # shellcheck disable=SC2010
  toState="$(_cc::fingerprint "$to")"

  # Compare state of the destination with the origin (origin ignores directories and lock files)
  # shellcheck disable=SC2010
  # shellcheck disable=SC2015
  [ "$toState" != "$(_cc::fingerprint "$from")" ] && {
    # We have changes - if asked to wipe out, do so
    if [ "$erase" ]; then
      rm -Rf "$to"
      mkdir -p "$to"
    fi
    # Now copy the files
    # This is probably slow-ish. The question is: will it be significant in a context where copy IO is the bottleneck?
    find "$from" -type f -not -iname "lock" -print0 | while IFS= read -r -d $'\0' fd; do
      cp -p "$fd" "$to"
    done
  } || {
    cc::logger::debug "Nothing to save to storage"
  }

  # Release the lock
	cc::lock::release $lid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
Ï*"÷*”*ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∫*
/library2.sh¿õ*#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Helpers to allow apt to share cache properly

# Private tmpfs location
_cc_tmpfs_location=/codecomet/apt-get-private/tmp

# Location of the list cache
_cc_apt_list_store_location=/codecomet/apt-get-shared/lists
# And pack cache
_cc_apt_pack_local_location=/codecomet/apt-get-shared/packs

# Location of the packages cache
_cc_apt_pack_store_location=/codecomet/apt-get-shared/cache

# Location of our private lists files - by default, Debian normal location, which means state will persist
_cc_apt_list_local_location=/var/lib/apt/lists

# Location of the config file
export APT_CONFIG=$_cc_tmpfs_location/apt-get.conf

# Hash of the sources.list, which dictates the cache location to share
# Different sources means different cache location
# Caveats: this will likely not work with a future debian release as they change the sources.list format
# XXX this wracking the debugger output
cc::apt_get::shard(){
  sha256sum <<< "$(uname -m)$(grep --no-filename -Ev "^#" /etc/apt/sources.list /etc/apt/sources.list.d/* 2>/dev/null | sed -E 's/#.+$//' | sort || true)" | sed -E 's/  .*//'
}

# Set the tmp location, initiliaze APT_CONFIG and shared and private locations
cc::apt_get::init(){
  # Get the desired tmpfs mount point
  _cc_tmpfs_location="$1"

  mkdir -p "$_cc_tmpfs_location"

  # Point configuration there
  export APT_CONFIG="$_cc_tmpfs_location"/apt-get.conf

  # Sharding by sources list content, cleaned-up and sorted to maximize cache hits
	_cc_apt_list_store_location="$2/$(cc::apt_get::shard)"

  # Technically, we should not be sharding the architecture
  # But then, the only upside would be when installing cross-arch packages
	_cc_apt_pack_store_location="$3/$(cc::apt_get::shard)"

  # If we do not want lists to persist, use the tmp storage
  [ "${4:-}" == true ] || _cc_apt_list_local_location="$_cc_tmpfs_location"/lists

  # Finally, local pack location
  _cc_apt_pack_local_location="$_cc_tmpfs_location"/packs

  # Make sure they all exist
  mkdir -p "$_cc_apt_list_local_location"
  mkdir -p "$_cc_apt_pack_local_location"

  mkdir -p "$_cc_apt_list_store_location"
  mkdir -p "$_cc_apt_pack_store_location"
}

# Create the configuration file for APT
cc::apt_get::configure(){
  local config_extra="${1:-}"
  local persist="${2:-}"

  mkdir -p "$_cc_tmpfs_location/logs"
  cat << EOF > "$APT_CONFIG"
# Divert both lists and archives location
Dir::Cache::Archives "$_cc_apt_pack_local_location";
Dir::State::Lists "$_cc_apt_list_local_location";
# Prevent the default apt config to be used
Dir::Etc::parts "";
# Put the logs in the tmp zone
Dir::Log "$_cc_tmpfs_location/logs";
# Put the bin cache files in the private mount
Dir::Cache::srcpkgcache "$_cc_tmpfs_location/srcpkgcache.bin";
Dir::Cache::pkgcache "$_cc_tmpfs_location/pkgcache.bin";

$config_extra
EOF

  # If asked to persist the config, copy over the generated file
  [ "$persist" == "false" ] || cp "$APT_CONFIG" /etc/apt/apt.conf
}

#cc::apt_get::cleanup(){
  # This is only necessary if we were not using an tmpfs mount...
  # rm "$APT_CONFIG"
#}

cc::apt_get::update(){
  # Remove our marker if here
  rm -f "$_cc_apt_list_local_location"/.cc_updated

  # Retrieve existing data
  cc::storage::retrieve "$_cc_apt_list_store_location" "$_cc_apt_list_local_location" copy

	# Do the deed, same restriction applies
	apt-get update "$@"

  # Save it back (storage will decide)
  cc::storage::store "$_cc_apt_list_local_location" "$_cc_apt_list_store_location" erase

  # Now, flag it
  date > "$_cc_apt_list_local_location"/.cc_updated
}

cc::apt_get::do(){
  # Bring in any cache
  cc::storage::retrieve "$_cc_apt_pack_store_location" "$_cc_apt_pack_local_location"

	apt-get "$@"

  # Store the packages permanently
  cc::storage::store "$_cc_apt_pack_local_location" "$_cc_apt_pack_store_location"
}

# XXX what if sources are being modified, or config, or something else that materially impacts update?
cc::high::update(){
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "$nooutput"

  args+=("$@")
  time cc::apt_get::update "${args[@]}"
}

cc::high::install(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists has been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  args+=("$@")
  time cc::apt_get::do install "${args[@]}"
}

cc::high::upgrade(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists have been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  # ls -lAR "$_cc_tmpfs_location"/packs || true
  # time cc::apt_get::do upgrade "$nooutput" "$@"

  # XXX WIP here
  # Bust cache - delete this
  #time cc::apt_get::do upgrade --download-only "$nooutput" "$@"
  #time cc::apt_get::do upgrade --no-download "$nooutput" "$@"
  args+=("$@")
  time cc::apt_get::do upgrade "${args[@]}"
}

cc::high::purge(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")

  args+=("$@")
  time cc::apt_get::do purge --auto-remove "${args[@]}"
}(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
’"øºˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*£

/action.sh¿Ü#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::upgrade

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f7942
 



Z 
•
I
Gsha256:1fbbc4badd25a127fd4fadc9695046d27c048e2401041b62bedf36d229e45f77
I
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
armlinuxv7Z 
Í"‘—ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∏

/action.sh¿õ#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::install eatmydata nano socat

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c2
 



Z 
•
I
Gsha256:55ec848cf7d65106bee358f2ac6a5bba29563bf30924f0ee03dac01e2cbbc43e
I
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
armlinuxv7Z 
K
I
Gsha256:7d56e94b3beb356751a3e6f559295c2e360361498efd4103e6dd6dc5063a8e84Ë
Gsha256:1fbbc4badd25a127fd4fadc9695046d27c048e2401041b62bedf36d229e45f77ú!
codecomet.optest codecomet opG
llb.customname5[source:image] docker.io/library/debian:bullseye-slim*
source.image*
source.image.resolvemodeü
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library2.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library1.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupπ
Gsha256:55ec848cf7d65106bee358f2ac6a5bba29563bf30924f0ee03dac01e2cbbc43eÌ!
codecomet.optest codecomet op!
llb.customnameapt-get upgrade*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeŒ
Gsha256:7d56e94b3beb356751a3e6f559295c2e360361498efd4103e6dd6dc5063a8e84Ç!
codecomet.optest codecomet op6
llb.customname$apt-get install eatmydata nano socat*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeù
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962—!
codecomet.optest codecomet op0
llb.customname[action:addfile] codecomet in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupê
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edfƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library0.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupÄ
Gsha256:d8bbf2a7da2fc3ca36bc870ec340d424817c686cb2f622f469f5329d4532732b5*
constraints*
meta.description*
platformê
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8aƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupœ
K
Gsha256:1fbbc4badd25a127fd4fadc9695046d27c048e2401041b62bedf36d229e45f77 
K
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f 
K
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7 
K
Gsha256:55ec848cf7d65106bee358f2ac6a5bba29563bf30924f0ee03dac01e2cbbc43e 
K
Gsha256:7d56e94b3beb356751a3e6f559295c2e360361498efd4103e6dd6dc5063a8e84 
K
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962 
K
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c 
K
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf 
K
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c 
K
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794 
K
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a 
æ›"ß›£›ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*â›

/codecomet¿Î‹#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Defines the supported color palette, and our color scheme
########################################################################################################################

# Supported color palette
readonly _CC_PV_COLOR_BLACK=0
readonly _CC_PV_COLOR_RED=1
readonly _CC_PV_COLOR_GREEN=2
readonly _CC_PV_COLOR_YELLOW=3
# shellcheck disable=SC2034
readonly _CC_PV_COLOR_BLUE=4
readonly _CC_PV_COLOR_MAGENTA=5
readonly _CC_PV_COLOR_CYAN=6
readonly _CC_PV_COLOR_WHITE=7

# Colors scheme definition - can evidently be customized at runtime by setting these variables to other values from the palette
export CC_COLOR_DEFAULT_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEFAULT_BACK="$_CC_PV_COLOR_BLACK"

export CC_COLOR_BODY="$_CC_PV_COLOR_WHITE"
export CC_COLOR_COMMENT="$_CC_PV_COLOR_CYAN"
export CC_COLOR_HUMPF="$_CC_PV_COLOR_MAGENTA"

# Logger
export CC_COLOR_ERROR_FRONT="$_CC_PV_COLOR_RED"
export CC_COLOR_ERROR_BACK="$_CC_PV_COLOR_WHITE"
export CC_COLOR_WARNING_FRONT="$_CC_PV_COLOR_YELLOW"
export CC_COLOR_WARNING_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_INFO_FRONT="$_CC_PV_COLOR_GREEN"
export CC_COLOR_INFO_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_DEBUG_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEBUG_BACK="$_CC_PV_COLOR_BLACK"

# Tracer
export CC_COLOR_TRACER_HUMPF="$_CC_PV_COLOR_GREEN"
export CC_COLOR_TRACER_COMMAND_LABEL="$_CC_PV_COLOR_BLUE"
export CC_COLOR_TRACER_OUTPUT_LABEL="$_CC_PV_COLOR_RED"
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provide helpers to print colorful text
#
# Depends on:
# defaults.sh
# colors.sh
########################################################################################################################

_cc_private::tput(){
  [ ! "$CC_CAP_HAS_TERM" ] || [ "$CC_CAP_NO_COLOR" != "" ] || tput "$@" 2>/dev/null || true
}

_cc_private::console::inline(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it and pad to 7 chars, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"
}

_cc_private::console(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-7s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    # Otherwise, just a plain front/back
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"

  # Restore console to default before we \n so that we do not leak over into BK timestamp display
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::error(){
  _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_ERROR_BACK" "error" "$@"
}

cc::console::warning(){
  _cc_private::console "$CC_COLOR_WARNING_FRONT" "$CC_COLOR_WARNING_BACK" "warning" "$@"
}

cc::console::info(){
  _cc_private::console "$CC_COLOR_INFO_FRONT" "$CC_COLOR_INFO_BACK" "info" "$@"
}

cc::console::debug(){
  _cc_private::console "$CC_COLOR_DEBUG_FRONT" "$CC_COLOR_DEBUG_BACK" "debug" "$@"
}

cc::console::body(){
  _cc_private::console "$CC_COLOR_BODY" "" "" "$@"
}

cc::console::comment(){
  _cc_private::console "$CC_COLOR_COMMENT" "" "" "$@"
}

cc::console::humpf(){
  _cc_private::console "$CC_COLOR_HUMPF" "" "" "$@"
}

cc::console::reset(){
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::end(){
  _cc_private::tput op
  printf "\n"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Debugger based on socat
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
# logger.sh
########################################################################################################################

# Fancy prompt adapted from https://github.com/pombadev/fancy-linux-prompt/blob/master/LICENSE under MIT License
__powerline() {
    # Unicode symbols
    readonly GIT_NEED_PULL_SYMBOL='‚á£'
    readonly GIT_NEED_PUSH_SYMBOL='‚á°'
    readonly PS_SYMBOL='ü™ê' # üêß‚òÑ'‚ñ∂‚èµ‚ñ∂‚èµ

    # Solarized colorscheme
    readonly BG_BLUE="\\[$(tput setab 4)\\]"
    readonly BG_COLOR5="\\[\\e[48;5;31m\\]"
    readonly BG_COLOR8="\\[\\e[48;5;161m\\]"
    readonly BG_GREEN="\\[$(tput setab 2)\\]"
    readonly BG_RED="\\[$(tput setab 1)\\]"
    readonly FG_BASE3="\\[$(tput setaf 15)\\]"
    readonly FG_BLUE="\\[$(tput setaf 4)\\]"
    readonly FG_COLOR1="\\[\\e[38;5;250m\\]"
    readonly FG_COLOR6="\\[\\e[38;5;31m\\]"
    readonly FG_COLOR9="\\[\\e[38;5;161m\\]"
    readonly FG_GREEN="\\[$(tput setaf 2)\\]"
    readonly FG_RED="\\[$(tput setaf 1)\\]"
    readonly RESET="\\[$(tput sgr0)\\]"

    __git_info() {
        # has a .git directory and a git binary
    	[ -d .git ] || command -v git >/dev/null || return 0

        local aheadN
        local behindN
        local branch
        local marks=""
        local stats

        # get current branch name or short SHA1 hash for detached head
        branch="$(git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --always 2>/dev/null)"
        [ -n "$branch" ] || return 0 # git branch not found

        # how many commits local branch is ahead/behind of remote?
        stats="$(git status --porcelain --branch | grep '^##' | grep -o '\[.\+\]$')"
        aheadN="$(echo "$stats" | grep -o 'ahead \d\+' | grep -o '\d\+')"
        behindN="$(echo "$stats" | grep -o 'behind \d\+' | grep -o '\d\+')"
        [ -n "$aheadN" ] && marks+=" $GIT_NEED_PUSH_SYMBOL$aheadN"
        [ -n "$behindN" ] && marks+=" $GIT_NEED_PULL_SYMBOL$behindN"

        # print the git branch segment without a trailing newline
        # branch is modified?
        if [ -n "$(git status --porcelain)" ]; then
            printf "%s" "${BG_COLOR8}‚ñ∂$RESET$BG_COLOR8 $branch$marks $FG_COLOR9"
        else
            printf "%s" "${BG_BLUE}‚ñ∂$RESET$BG_BLUE $branch$marks $RESET$FG_BLUE"
        fi
    }


    ps1() {
        # Check the exit code of the previous command and display different
        # colors in the prompt accordingly.
        if [ "$?" -eq 0 ]; then
            local BG_EXIT="$BG_GREEN"
            local FG_EXIT="$FG_GREEN"
        else
            local BG_EXIT="$BG_RED"
            local FG_EXIT="$FG_RED"
        fi

        PS1="$FG_COLOR1$BG_COLOR5 CodeComet \\w "
        PS1+="$RESET${FG_COLOR6}"
        PS1+="$(__git_info)"
        PS1+="$BG_EXIT‚ñ∂$RESET"
        PS1+="$BG_EXIT$FG_BASE3 ${PS_SYMBOL} ${RESET}${FG_EXIT}‚ñ∂${RESET} "
    }

    PROMPT_COMMAND=ps1
}

_cc_private::debugger::setup(){
  # Set-up PS1
  cat << EOF > "$CC_TMPFS"/.profile
# export PS1='\[\033[01;32m\]CodeComet\[\033[00m\] \w \$ '
alias l="ls -lA"
source ${BASH_SOURCE[0]}
umask 077
export LSCOLORS=exfxcxdxbxegedabagacad
export CLICOLOR=1

_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Welcome!" printf "You are now debugging your pipeline at the point it stopped.\n"
printf "\n"
#_cc_private::console::inline "$_CC_PV_COLOR_BLACK" "$_CC_PV_COLOR_BLACK" "         " printf ""
printf "Environment, pwd, and filesystem, are exactly as they were when the last action failed.\n"
printf "You can call the following helpers:\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdout" printf "will output your action stdout\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stderr" printf "will output your action stderr\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdex " printf "will output your action exit code\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_action" printf "will output the location of your action script\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Tip           " printf "If you want to re-run your action, just call \\\$(ccdebug_action)\n"

# touch "$CC_TMPFS/.codecomet/connected"
__powerline

EOF

  cat << EOF >> "$CC_TMPFS"/.inputrc
"\e[A": history-search-backward
"\e[B": history-search-forward
set show-all-if-ambiguous on
set completion-ignore-case on

EOF

}

# "on demand
# "Abnormal exit, with non zero grace:
# - start debugger repeatedly, with grace
# - once the other end exits, bail out

# "live", with non zero grace
# - start debugger, with infinity grace
# - if the other end was connected and exited, that is it, end of story
# - if the other end is still running, bring socat forward and wait for the end to exit
# - if there was no other end, we should branch back to the first scenario

# This is called on trap ERR, if a live debugger has been running, and will make a decision to bring it back forward and keep it alive,
# or to drop it
cc::debugger::front(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  cc::logger::debug "[debugger-front] socat is here"
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  cc::logger::debug "[debugger-front] grace is fine"


  # Debugger still live? Bail out if not
  jobs | grep -q -v Done || {
    cc::logger::debug "[debugger-front] no jobs detected. Bailing out."
    return 0
  }

  # Ok, it is live. Do we have a client?
  # XXX unfortunately, this does not work as expected... socat does start the process first, bash sources the files and create the stamp file...
  local lasttry
  local current
  lasttry="$(cat $CC_TMPFS/.codecomet/lasttry 2>/dev/null)" || true
  current="$(date +%s)"
  # The older an unconnected socat could be is 2 seconds - if greater than that, then we definitely have a client
  # However, it is possible that a client has been connected for less than 2 seconds (since socat call) when the failure happens,
  # which means the client will wrongly get the boot... no good solution right now
  [ $(( current - lasttry)) -gt 2 ] && {
  # [ -e "$CC_TMPFS/.codecomet/connected" ] && {
    cc::logger::debug "[debugger-front] we have a connected client"
    # Yes, then foreground and let it sit
    fg 2>/dev/null
  } || {
    cc::logger::debug "[debugger-front] no live client. Kick it out restart."
    # No live client. Kill it, and start again the normal process with timeout and message
    kill %%
    cc::debugger::start "$ex"
  }
}

# XXX this is largely broken
cc::debugger::live(){
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  while true; do
    lasttry="$(date +%s)"
    printf "%s" "$lasttry" > "$CC_TMPFS/.codecomet/lasttry"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-live] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Break if we have been hanging out more than a second (meaning the other end did connect, but exit in error)
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-live] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
    }
    x=$(( x + 1 ))
    cc::logger::debug "[debugger-live] sleeping"
    sleep 1
  done
}

cc::debugger::start(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  # Prep-up profile
  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  cc::logger::error "Abnormal exit code $ex. If you want to inspect manually, start codecomet-debugger. Otherwise, we will exit after $CC_DEBUGGER_GRACE seconds"
  cc::logger::error "You can also restart the build with CODECOMET_DEBUG=true"

  >&2 _cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "waiting" printf "Waiting %s seconds for debugger to connect" "$CC_DEBUGGER_GRACE"
  # cc::logger::warning "Waiting "


  # https://medium.com/@JAlblas/tryhackme-what-the-shell-walkthrough-6c0ebe8f854e
  #pty, allocates a pseudoterminal on the target ‚Äî part of the stabilisation process
  #stderr, makes sure that any error messages get shown in the shell (often a problem with non-interactive shells)
  #sigint, passes any Ctrl + C commands through into the sub-process, allowing us to kill commands inside the shell
  #setsid, creates the process in a new session
  #sane, stabilises the terminal, attempting to ‚Äúnormalise‚Äù it.

  while [ "$x" -lt "$CC_DEBUGGER_GRACE" ]; do
    lasttry="$(date +%s)"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-stat] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Timeing out means we wait for a second. Any more than that should mean the connection was succesful
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-stat] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
      >&2 printf "."
    }
    x=$(( x + 1 ))
    sleep 1
  done
}

ccdebug_stdout(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stdout.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stdout.log
  fi
}

ccdebug_stderr(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stderr.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stderr.log
  fi
}

ccdebug_stdex(){
  [ -e "$CC_TMPFS"/.codecomet/logs/ex.log ] && {
    cat "$CC_TMPFS"/.codecomet/logs/ex.log
  } || {
    cc::logger::warning "Action is in progress, no exit code yet"
  }
}

ccdebug_action(){
  echo "$_CC_PV_SCRIPT"
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# List all environment variables we depend on, possibly providing defaults
########################################################################################################################

#############
# Generic controls
#############
# Log level to start with (error, warning, info, debug or 4, 3, 2, 1, 0 <- mute)
readonly CC_LOG_LEVEL="${CC_LOG_LEVEL:-}"
# Where is the tempfs mounted
readonly CC_TMPFS="${CC_TMPFS:-}"
# Honors NO_COLOR (see https://no-color.org/)
# shellcheck disable=SC2034
readonly CC_CAP_NO_COLOR="${NO_COLOR:-}"
# About detection
# https://stackoverflow.com/questions/911168/how-can-i-detect-if-my-shell-script-is-running-through-a-pipe
# Could also test for [ ! -t 2 ]
# Or could be: `test -t 0` (formerly `tty -s`)
# In our context though, this probably does not matter much
# shellcheck disable=SC2034
readonly CC_CAP_HAS_TERM="${TERM:-}"

#############
# Action execution flow control
#############
# Whether the action can fail or not
readonly CC_ACTION_CAN_FAIL="${CC_ACTION_CAN_FAIL:-}"

#############
# Tracing and debugging
#############
# Controls wether the tracer will also trace internal codecomet library or hide them
readonly CC_TRACER_CODECOMET_INTERNALS="${CC_TRACER_CODECOMET_INTERNALS:-}"
# How long to wait for a connection before dropping the debugger
export CC_DEBUGGER_GRACE="${CC_DEBUGGER_GRACE:-}"
# Port to connect to
readonly CC_DEBUGGER_PORT="${CC_DEBUGGER_PORT:-}"
# IP to connect to
readonly CC_DEBUGGER_IP="${CC_DEBUGGER_IP:-}"
# Whether a debugger should be started pre-emptively so that one can hook in "live" during the action. This is very wonky as soon as you have parallelism...
readonly CC_DEBUGGER_LIVE="${CC_DEBUGGER_LIVE:-}"


#############
# Error code used accross the codebase - rn, only the bland FAILED is used...
#############
# shellcheck disable=SC2034
readonly ERROR_NETWORK=200
# Thrown if a required argument is missing
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_MISSING=201
# Thrown if an argument does not match validation
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_INVALID=202
# Should be used to convey that a certain operation is not supported
# shellcheck disable=SC2034
readonly ERROR_UNSUPPORTED=203
# Generic error to denote that the operation has failed. More specific errors may be provided instead
# shellcheck disable=SC2034
readonly ERROR_FAILED=204
# Expectations failed on a file (not readable, writable, doesn't exist, can't be created)
# shellcheck disable=SC2034
readonly ERROR_FILESYSTEM=205
# System requirements
# shellcheck disable=SC2034
readonly ERROR_MISSING_REQUIREMENTS=206

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# A generic logger
#
# Depends on:
# console.sh
########################################################################################################################

readonly CC_LOGGER_DEBUG=4
readonly CC_LOGGER_INFO=3
readonly CC_LOGGER_WARNING=2
readonly CC_LOGGER_ERROR=1

_CC_PV_LOGGER_LEVEL="$CC_LOGGER_WARNING"

_cc_private::logger::log(){
  local prefix="$1"
  shift

  local level="CC_LOGGER_$prefix"
  local i

  [ "$_CC_PV_LOGGER_LEVEL" -ge "${!level}" ] || return 0

  # About the crazy shit: https://stackoverflow.com/questions/12674783/bash-double-process-substitution-gives-bad-file-descriptor
  exec 3>&2
  for i in "$@"; do
    >&2 cc::console::"$(printf "$prefix" | tr '[:upper:]' '[:lower:]')" printf "$i"
  done
  exec 3>&-
}

cc::logger::level::set() {
  local level
  level="$(printf "%s" "${1:-}" | tr '[:upper:]' '[:lower:]')"

  case "$level" in
    ''|*[!0-9]*)
      case "$level" in
          "debug")
            _CC_PV_LOGGER_LEVEL=4
            ;;
          "info")
            _CC_PV_LOGGER_LEVEL=3
            ;;
          "warning")
            _CC_PV_LOGGER_LEVEL=2
            ;;
          "error")
            _CC_PV_LOGGER_LEVEL=1
            ;;
          "mute")
            _CC_PV_LOGGER_LEVEL=0
            ;;
          *)
            _CC_PV_LOGGER_LEVEL=3
            ;;
      esac
      ;;
    *)
      if [ "$level" -gt "$CC_LOGGER_DEBUG" ]; then
        return "$ERROR_FAILED"
      fi
      _CC_PV_LOGGER_LEVEL="$level"
      ;;
  esac

  [ "$_CC_PV_LOGGER_LEVEL" != "$CC_LOGGER_DEBUG" ] || {
    cc::console::warning printf "YOU ARE LOGGING AT THE DEBUG LEVEL."
    cc::console::warning printf "This is NOT recommended for production use, and WILL LIKELY LEAK sensitive information to logs."
  }
}

# Sugar
cc::logger::level::set::debug(){
  cc::logger::level::set "$CC_LOGGER_DEBUG"
}

cc::logger::level::set::info(){
  cc::logger::level::set "$CC_LOGGER_INFO"
}

cc::logger::level::set::warning(){
  cc::logger::level::set "$CC_LOGGER_WARNING"
}

cc::logger::level::set::error(){
  cc::logger::level::set "$CC_LOGGER_ERROR"
}

cc::logger::mute() {
  _CC_PV_LOGGER_LEVEL=0
}

cc::logger::ismute() {
  [ "$_CC_PV_LOGGER_LEVEL" == 0 ] || return "$ERROR_FAILED"
}

cc::logger::debug(){
  _cc_private::logger::log "DEBUG" "$@"
}

cc::logger::info(){
  _cc_private::logger::log "INFO" "$@"
}

cc::logger::warning(){
  _cc_private::logger::log "WARNING" "$@"
}

cc::logger::error(){
  _cc_private::logger::log "ERROR" "$@"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provides fancy display for `set -x`
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
########################################################################################################################

cc::codecomet::tracer(){
  local length="${#BASH_SOURCE[@]}"

  #local indent=""
  local linenumber
  local filename
  local filecontent
  local funcname
  local col

  [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[1]}" == *"action.sh" ]] || return 0

  printf "\n"

  for (( j=$(( length - 1 )); j>0; j-- )); do
    [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[$j]}" == *"action.sh" ]] || {
      continue
    }

    linenumber="${BASH_LINENO[$(( j - 1 ))]}"
    filename="${BASH_SOURCE[$j]}"
    filecontent="$(cat -n "$filename" | grep -E "^\s+$linenumber\s" | sed -E "s/^\s+$linenumber\s+//")"
    funcname="${FUNCNAME[$j]}"

    # Why is this showing is a mystery for the times
    # [ "$filecontent" != "#!/usr/bin/env bash" ] || continue

    [ "$j" != 1 ] && {
      col="$CC_COLOR_DEFAULT_FRONT"
    } || {
      col="$CC_COLOR_TRACER_HUMPF"
    }

    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$filename"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$linenumber"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "function" printf "%-30s" "$funcname()"
    printf "\n"
    [ "$j" != 1 ] || {
      _cc_private::console "$CC_COLOR_TRACER_COMMAND_LABEL" "$CC_COLOR_DEFAULT_FRONT" "command" printf "%s" "$filecontent"
      _cc_private::console "$CC_COLOR_TRACER_OUTPUT_LABEL" "$CC_COLOR_DEFAULT_FRONT" "output" printf ""
    }

  done
}

cc::tracer::register(){
  # shellcheck disable=SC2016
  local ps=('$(' "$@" ')')
  export PS4="${ps[*]}"
}

cc::init::tracer(){
  cc::tracer::register cc::codecomet::tracer
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Trap management
#
# Depends on:
# colors.sh
# console.sh
########################################################################################################################

_CC_PV_TRAP_LISTENERS=()

_CC_PV_ERR_LNO=
_CC_PV_ERR_CMD=
_CC_PV_ERR_STACK=
_CC_PV_ERR_EX=

dc::trap::register(){
  _CC_PV_TRAP_LISTENERS+=( "$1" )
}

# Trap lno and cmd on ERR for future use
cc::trap::err(){
  _CC_PV_ERR_EX="$1"
  _CC_PV_ERR_LNO="$2"
  _CC_PV_ERR_CMD="$3"
  _CC_PV_ERR_STACK="$4"
  # Dropping the rest of the stack?

  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$_CC_PV_ERR_STACK"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$_CC_PV_ERR_LNO"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "exit" printf "%s" "$_CC_PV_ERR_EX"
  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "command" printf "%-30s" "$_CC_PV_ERR_CMD"
  >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  >&2 printf "\n"

  >&2 _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "source" printf ""
  prefix=" "
  for (( j=$(( _CC_PV_ERR_LNO - 3 )); j<$(( _CC_PV_ERR_LNO + 3 )); j++ )); do
    [ "$j" -gt 0 ] || continue
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=">"
      >&2 _cc_private::tput setaf "$CC_COLOR_ERROR_FRONT"
      #>&2 _cc_private::tput bold
    fi
    #  | sed -E "s/^\s+$j\s//"
    >&2 printf "%s%s" "$prefix" "$(cat -n "$_CC_PV_ERR_STACK" | grep -E "^\s+$j\s")" || true
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=" "
      >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
      #>&2 _cc_private::tput sgr0
    fi
    >&2 printf "\n"
  done
}

_CC_PV_NO_REENTRY=

# Trap exit for the actual cleanup
cc::trap::exit() {
  # { set +x; } 2>/dev/null

  local ex="$1"
  local i

  # Prevent reentrancy - XXX is this actually needed?
  [ ! "$_CC_PV_NO_REENTRY" ] || return 0
  _CC_PV_NO_REENTRY="exiting"

  printf "%s\n" "$ex" > "$CC_TMPFS"/.codecomet/logs/ex.log

  if [ "${#_CC_PV_TRAP_LISTENERS[@]}" -gt 0 ]; then
    for i in "${_CC_PV_TRAP_LISTENERS[@]}"; do
      cc::logger::debug "Calling exit hook $i"
#      >&2 printf "\n"
      "$i" "$ex" "$_CC_PV_ERR_CMD" "$_CC_PV_ERR_LNO" "$_CC_PV_ERR_STACK"
    done
  fi
  >&2 cc::console::reset
  >&2 printf "\n"
  cc::logger::debug "Exiting ($ex)"
  [ "$CC_ACTION_CAN_FAIL" == "true" ] && {
    [ "$ex" != "" ] || cc::logger::error "Action failed, but it is marked as 'can fail', so, exiting successfully"
    exit 0
  } || exit "$ex"
}

# Forking to disable xtrace when entering traps
cc::init::trap(){
  # Signals are caught by buildkit already - and only SIGKILL triggers a failure
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::err "$ex" "$LINENO" "$BASH_COMMAND" "${BASH_SOURCE[@]}"' ERR
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::exit "$ex"' EXIT
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# See https://manpages.ubuntu.com/manpages/xenial/man1/eatmydata.1.html
# Technically, we get a 10% speedup with apt operations for eg
# XXX careful here if this is going to be used in a chroot
cc::init::speedup(){
  ! command -v eatmydata >/dev/null || export LD_PRELOAD=libeatmydata.so
}

# Boot if we have an argument - otherwise, we are being sourced
if [ "$#" -gt 0 ]; then
  mkdir -p "$TMPDIR"
  rm -Rf "$CC_TMPFS"/.codecomet
  mkdir -p "$CC_TMPFS"/.codecomet/bin
  mkdir -p "$CC_TMPFS"/.codecomet/logs

  # Set logger to env var from the Bash helper
  cc::logger::level::set "$CC_LOG_LEVEL"

  # Eat data, trap, register tracer, register debugger on exit trap
  cc::init::speedup
  cc::init::trap
  cc::init::tracer
  # Live debugger is really wonky
  if [ "${CC_DEBUGGER_LIVE:-}" != "" ]; then
    cc::debugger::live &
    dc::trap::register cc::debugger::front
  else
    [ "$CC_ACTION_CAN_FAIL" == true ] || dc::trap::register cc::debugger::start
  fi

  # XXX technically, we receive a bunch of scripts, and we could just play them all - use case is not completely clear yet
  out="$CC_TMPFS"/.codecomet/logs/stdout.log
  err="$CC_TMPFS"/.codecomet/logs/stderr.log

  # Unpack libraries path and source them
  while [ "$#" -gt 1 ]; do
    cp "$1" "$CC_TMPFS"/.codecomet/bin
    # shellcheck disable=SC1090
    source "$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
    shift
  done
  cp "$1" "$CC_TMPFS"/.codecomet/bin
  _CC_PV_SCRIPT="$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
  export _CC_PV_SCRIPT

  # Run the actual action
  # shellcheck disable=SC1090
  source "$_CC_PV_SCRIPT" > >(tee -a "$out") 2> >(tee -a "$err" >&2)
else
  # If we are a library, toss this one so we do not exit on any error...
  # This is especially important for the reverse debugger
  set +o errexit
fi
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
â"Ûˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*◊
/library0.sh¿∏#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# A generic lock mechanism that supports exclusive locks, shared locks, and a simplistic queueing mechanism
_cc_lockindex=9
_cc_lock_location="/_cc/share/locks"

# Sets our locks location. Must be called to guarantee that the lock location exist.
cc::lock::init(){
	_cc_lock_location="${1:-.}"
	mkdir -p "${_cc_lock_location}"
}

# Acquire a lock with a given name, and a share mode (shared or exclusive (which is the default))
# If the lock is already acquired in a different mode, or the mode is exclusive, the function will wait until the lock is released.
# Return the lock id that you need to carry around to release the lock later on.
cc::lock::acquire(){
	local lockfile="$_cc_lock_location/$1"
	local shared="${2:-}"
	[ "$shared" ] && shared=-s || shared=-x
	_cc_lockindex=$((_cc_lockindex+1))
	mkdir -p "$(dirname "$lockfile")"
	exec {_cc_lockindex}>"$lockfile"
	flock $shared $_cc_lockindex
	return $_cc_lockindex
}

# Release a previously acquire lock by its id
cc::lock::release(){
	local idx="$1"
	# This is essentially the same
	flock -u "$idx"
	# exec {idx}>&-
}

cc::lock::queue(){
	local basepath="${1:-.}"
	local shared1="${2:-}"
	local shared2="${3:-}"
	local qid
	local oid

	# Get into the queue first
	cc::lock::acquire "$basepath"/cc_queue.lock "$shared1" || qid=$?

	# Then when out of the queue, acquire an operation lock
	cc::lock::acquire "$basepath"/cc_op.lock "$shared2" || oid=$?

	# Now, leave the queue
	cc::lock::release $qid

	# Return the lock id
	return $oid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
˙"‰·ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*»
/library1.sh¿©#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Lessons learned:
# - find -exec is VERY SLOW - better off piping to read (almost 10x) (0.2 second vs 0.02 second for about 200 files)
# - then globbing and grepping is faster than find + read
# This matters not in case we are copying a large amount of data of course, but then
# - there is no way to get something stable out of ls without further processing - directories with different owners
# for eg will widen some columns
# this "works" right now (if we do not use --numeric-uid-gid) but will be problematic outside of this specific case

_cc::fingerprint(){
  local directory="$1"
  # Will fail if the directory is empty, so the guardrail
  # Ignore directories, links, and "total" (note: -d will not work for that)
  # --numeric-uid-gid < messes up the output width
  # shellcheck disable=SC2010
  ls --full-time --almost-all --ignore lock "$directory" 2>/dev/null | grep -v "^[d|l|t]" || true
}

# Copy or symlink data "from" storage "to" destination
# This assume that storage holds only files, and no lock
# Will not copy anything if there is no difference
cc::storage::retrieve(){
  local from="$1"
  local to="$2"
  local copy="${3:-}"
  local lid
  local fromState

  # Ensure destination exists
  mkdir -p "$to"

  # Lock origin and keep the lock id
  cc::lock::acquire "$from" shared || lid=$?

  # Ensure origin exists
  mkdir -p "$from"

  # If we are asked to copy (not expected for large amount of data - linking is prefered in that case)
  if [ "$copy" ]; then
    # Retrieve the state of it
    fromState="$(_cc::fingerprint "$from")"

    # Check that we have content in storage
    # Check that we have a difference between storage and destination (ignoring directories and lock file)
    # shellcheck disable=SC2010
    # shellcheck disable=SC2015
    [ "$fromState" ] && [ "$fromState" != "$(_cc::fingerprint "$to")" ] && {
      # Then cleanup destination
      rm -Rf "$to"
      mkdir -p "$to"
      # And copy over
      cp -p "$from"/* "$to"
      # Slower
      #find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
      #  cp -p "$fd" "$to"
      #done
    } || {
      # Otherwise, do nothing
      cc::logger::debug "Nothing to retrieve from storage"
    }
  else
    # We want links, so, lets check we have anything in the origin
    #[ ! "$fromState" ] || {
    # Get rid of possibly remaining files in our destination
    find "$to" -type f -delete
    ln -sf "$from"/* "$to" 2>/dev/null || true
    # Note: below is slower
    # find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
    #  ln -s "$fd" "$to"
    # done
    #}
  fi

  # Release the lock
	cc::lock::release $lid
}

cc::storage::store(){
  local from="$1"
  local to="$2"
  local erase="${3:-}"
  local lid
  local fd
  local toState

  # Ensure origin exists
  mkdir -p "$from"

  # Lock destination and keep the lock id
  cc::lock::acquire "$to" "" || lid=$?

  # Ensure destination exists
  mkdir -p "$to"
  # Retrieve the state of it
  # shellcheck disable=SC2010
  toState="$(_cc::fingerprint "$to")"

  # Compare state of the destination with the origin (origin ignores directories and lock files)
  # shellcheck disable=SC2010
  # shellcheck disable=SC2015
  [ "$toState" != "$(_cc::fingerprint "$from")" ] && {
    # We have changes - if asked to wipe out, do so
    if [ "$erase" ]; then
      rm -Rf "$to"
      mkdir -p "$to"
    fi
    # Now copy the files
    # This is probably slow-ish. The question is: will it be significant in a context where copy IO is the bottleneck?
    find "$from" -type f -not -iname "lock" -print0 | while IFS= read -r -d $'\0' fd; do
      cp -p "$fd" "$to"
    done
  } || {
    cc::logger::debug "Nothing to save to storage"
  }

  # Release the lock
	cc::lock::release $lid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
Ï*"÷*”*ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∫*
/library2.sh¿õ*#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Helpers to allow apt to share cache properly

# Private tmpfs location
_cc_tmpfs_location=/codecomet/apt-get-private/tmp

# Location of the list cache
_cc_apt_list_store_location=/codecomet/apt-get-shared/lists
# And pack cache
_cc_apt_pack_local_location=/codecomet/apt-get-shared/packs

# Location of the packages cache
_cc_apt_pack_store_location=/codecomet/apt-get-shared/cache

# Location of our private lists files - by default, Debian normal location, which means state will persist
_cc_apt_list_local_location=/var/lib/apt/lists

# Location of the config file
export APT_CONFIG=$_cc_tmpfs_location/apt-get.conf

# Hash of the sources.list, which dictates the cache location to share
# Different sources means different cache location
# Caveats: this will likely not work with a future debian release as they change the sources.list format
# XXX this wracking the debugger output
cc::apt_get::shard(){
  sha256sum <<< "$(uname -m)$(grep --no-filename -Ev "^#" /etc/apt/sources.list /etc/apt/sources.list.d/* 2>/dev/null | sed -E 's/#.+$//' | sort || true)" | sed -E 's/  .*//'
}

# Set the tmp location, initiliaze APT_CONFIG and shared and private locations
cc::apt_get::init(){
  # Get the desired tmpfs mount point
  _cc_tmpfs_location="$1"

  mkdir -p "$_cc_tmpfs_location"

  # Point configuration there
  export APT_CONFIG="$_cc_tmpfs_location"/apt-get.conf

  # Sharding by sources list content, cleaned-up and sorted to maximize cache hits
	_cc_apt_list_store_location="$2/$(cc::apt_get::shard)"

  # Technically, we should not be sharding the architecture
  # But then, the only upside would be when installing cross-arch packages
	_cc_apt_pack_store_location="$3/$(cc::apt_get::shard)"

  # If we do not want lists to persist, use the tmp storage
  [ "${4:-}" == true ] || _cc_apt_list_local_location="$_cc_tmpfs_location"/lists

  # Finally, local pack location
  _cc_apt_pack_local_location="$_cc_tmpfs_location"/packs

  # Make sure they all exist
  mkdir -p "$_cc_apt_list_local_location"
  mkdir -p "$_cc_apt_pack_local_location"

  mkdir -p "$_cc_apt_list_store_location"
  mkdir -p "$_cc_apt_pack_store_location"
}

# Create the configuration file for APT
cc::apt_get::configure(){
  local config_extra="${1:-}"
  local persist="${2:-}"

  mkdir -p "$_cc_tmpfs_location/logs"
  cat << EOF > "$APT_CONFIG"
# Divert both lists and archives location
Dir::Cache::Archives "$_cc_apt_pack_local_location";
Dir::State::Lists "$_cc_apt_list_local_location";
# Prevent the default apt config to be used
Dir::Etc::parts "";
# Put the logs in the tmp zone
Dir::Log "$_cc_tmpfs_location/logs";
# Put the bin cache files in the private mount
Dir::Cache::srcpkgcache "$_cc_tmpfs_location/srcpkgcache.bin";
Dir::Cache::pkgcache "$_cc_tmpfs_location/pkgcache.bin";

$config_extra
EOF

  # If asked to persist the config, copy over the generated file
  [ "$persist" == "false" ] || cp "$APT_CONFIG" /etc/apt/apt.conf
}

#cc::apt_get::cleanup(){
  # This is only necessary if we were not using an tmpfs mount...
  # rm "$APT_CONFIG"
#}

cc::apt_get::update(){
  # Remove our marker if here
  rm -f "$_cc_apt_list_local_location"/.cc_updated

  # Retrieve existing data
  cc::storage::retrieve "$_cc_apt_list_store_location" "$_cc_apt_list_local_location" copy

	# Do the deed, same restriction applies
	apt-get update "$@"

  # Save it back (storage will decide)
  cc::storage::store "$_cc_apt_list_local_location" "$_cc_apt_list_store_location" erase

  # Now, flag it
  date > "$_cc_apt_list_local_location"/.cc_updated
}

cc::apt_get::do(){
  # Bring in any cache
  cc::storage::retrieve "$_cc_apt_pack_store_location" "$_cc_apt_pack_local_location"

	apt-get "$@"

  # Store the packages permanently
  cc::storage::store "$_cc_apt_pack_local_location" "$_cc_apt_pack_store_location"
}

# XXX what if sources are being modified, or config, or something else that materially impacts update?
cc::high::update(){
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "$nooutput"

  args+=("$@")
  time cc::apt_get::update "${args[@]}"
}

cc::high::install(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists has been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  args+=("$@")
  time cc::apt_get::do install "${args[@]}"
}

cc::high::upgrade(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists have been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  # ls -lAR "$_cc_tmpfs_location"/packs || true
  # time cc::apt_get::do upgrade "$nooutput" "$@"

  # XXX WIP here
  # Bust cache - delete this
  #time cc::apt_get::do upgrade --download-only "$nooutput" "$@"
  #time cc::apt_get::do upgrade --no-download "$nooutput" "$@"
  args+=("$@")
  time cc::apt_get::do upgrade "${args[@]}"
}

cc::high::purge(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")

  args+=("$@")
  time cc::apt_get::do purge --auto-remove "${args[@]}"
}(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
Í"‘—ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∏

/action.sh¿õ#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::install eatmydata nano socat

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c2
 



Z 
fR
5docker-image://docker.io/library/debian:bullseye-slim
image.resolvemodepullR
amd64linuxZ 
’"øºˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*£

/action.sh¿Ü#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::upgrade

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f7942
 



Z 
£
I
Gsha256:f65fec6162c8d70fc2311c3d20f1b6a91a87c9203547e280f276fe349ca18ac5
I
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
amd64linuxZ 
£
I
Gsha256:7a830e01dd5926f63eee241a37f13de580dac91af765ea3a0c027e5dc01a70b0
I
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
amd64linuxZ 
K
I
Gsha256:7675b821844b304f3dfa86c81f7648559f41024b3a59c7bda03b191a177910cdü
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library2.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library1.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupŒ
Gsha256:7675b821844b304f3dfa86c81f7648559f41024b3a59c7bda03b191a177910cdÇ!
codecomet.optest codecomet op6
llb.customname$apt-get install eatmydata nano socat*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeπ
Gsha256:7a830e01dd5926f63eee241a37f13de580dac91af765ea3a0c027e5dc01a70b0Ì!
codecomet.optest codecomet op!
llb.customnameapt-get upgrade*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeù
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962—!
codecomet.optest codecomet op0
llb.customname[action:addfile] codecomet in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupê
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edfƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library0.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupê
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8aƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupË
Gsha256:f65fec6162c8d70fc2311c3d20f1b6a91a87c9203547e280f276fe349ca18ac5ú!
codecomet.optest codecomet opG
llb.customname5[source:image] docker.io/library/debian:bullseye-slim*
source.image*
source.image.resolvemodeÄ
Gsha256:fe08b103bce4ea5603cb864c3b8f0394fee85e8253501e3a7d3fd8fc5b3008405*
constraints*
meta.description*
platformœ
K
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f 
K
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7 
K
Gsha256:7675b821844b304f3dfa86c81f7648559f41024b3a59c7bda03b191a177910cd 
K
Gsha256:7a830e01dd5926f63eee241a37f13de580dac91af765ea3a0c027e5dc01a70b0 
K
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962 
K
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c 
K
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf 
K
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c 
K
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794 
K
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a 
K
Gsha256:f65fec6162c8d70fc2311c3d20f1b6a91a87c9203547e280f276fe349ca18ac5 
fR
5docker-image://docker.io/library/debian:bullseye-slim
image.resolvemodepullR
arm64linuxZ 
æ›"ß›£›ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*â›

/codecomet¿Î‹#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Defines the supported color palette, and our color scheme
########################################################################################################################

# Supported color palette
readonly _CC_PV_COLOR_BLACK=0
readonly _CC_PV_COLOR_RED=1
readonly _CC_PV_COLOR_GREEN=2
readonly _CC_PV_COLOR_YELLOW=3
# shellcheck disable=SC2034
readonly _CC_PV_COLOR_BLUE=4
readonly _CC_PV_COLOR_MAGENTA=5
readonly _CC_PV_COLOR_CYAN=6
readonly _CC_PV_COLOR_WHITE=7

# Colors scheme definition - can evidently be customized at runtime by setting these variables to other values from the palette
export CC_COLOR_DEFAULT_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEFAULT_BACK="$_CC_PV_COLOR_BLACK"

export CC_COLOR_BODY="$_CC_PV_COLOR_WHITE"
export CC_COLOR_COMMENT="$_CC_PV_COLOR_CYAN"
export CC_COLOR_HUMPF="$_CC_PV_COLOR_MAGENTA"

# Logger
export CC_COLOR_ERROR_FRONT="$_CC_PV_COLOR_RED"
export CC_COLOR_ERROR_BACK="$_CC_PV_COLOR_WHITE"
export CC_COLOR_WARNING_FRONT="$_CC_PV_COLOR_YELLOW"
export CC_COLOR_WARNING_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_INFO_FRONT="$_CC_PV_COLOR_GREEN"
export CC_COLOR_INFO_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_DEBUG_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEBUG_BACK="$_CC_PV_COLOR_BLACK"

# Tracer
export CC_COLOR_TRACER_HUMPF="$_CC_PV_COLOR_GREEN"
export CC_COLOR_TRACER_COMMAND_LABEL="$_CC_PV_COLOR_BLUE"
export CC_COLOR_TRACER_OUTPUT_LABEL="$_CC_PV_COLOR_RED"
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provide helpers to print colorful text
#
# Depends on:
# defaults.sh
# colors.sh
########################################################################################################################

_cc_private::tput(){
  [ ! "$CC_CAP_HAS_TERM" ] || [ "$CC_CAP_NO_COLOR" != "" ] || tput "$@" 2>/dev/null || true
}

_cc_private::console::inline(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it and pad to 7 chars, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"
}

_cc_private::console(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-7s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    # Otherwise, just a plain front/back
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"

  # Restore console to default before we \n so that we do not leak over into BK timestamp display
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::error(){
  _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_ERROR_BACK" "error" "$@"
}

cc::console::warning(){
  _cc_private::console "$CC_COLOR_WARNING_FRONT" "$CC_COLOR_WARNING_BACK" "warning" "$@"
}

cc::console::info(){
  _cc_private::console "$CC_COLOR_INFO_FRONT" "$CC_COLOR_INFO_BACK" "info" "$@"
}

cc::console::debug(){
  _cc_private::console "$CC_COLOR_DEBUG_FRONT" "$CC_COLOR_DEBUG_BACK" "debug" "$@"
}

cc::console::body(){
  _cc_private::console "$CC_COLOR_BODY" "" "" "$@"
}

cc::console::comment(){
  _cc_private::console "$CC_COLOR_COMMENT" "" "" "$@"
}

cc::console::humpf(){
  _cc_private::console "$CC_COLOR_HUMPF" "" "" "$@"
}

cc::console::reset(){
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::end(){
  _cc_private::tput op
  printf "\n"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Debugger based on socat
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
# logger.sh
########################################################################################################################

# Fancy prompt adapted from https://github.com/pombadev/fancy-linux-prompt/blob/master/LICENSE under MIT License
__powerline() {
    # Unicode symbols
    readonly GIT_NEED_PULL_SYMBOL='‚á£'
    readonly GIT_NEED_PUSH_SYMBOL='‚á°'
    readonly PS_SYMBOL='ü™ê' # üêß‚òÑ'‚ñ∂‚èµ‚ñ∂‚èµ

    # Solarized colorscheme
    readonly BG_BLUE="\\[$(tput setab 4)\\]"
    readonly BG_COLOR5="\\[\\e[48;5;31m\\]"
    readonly BG_COLOR8="\\[\\e[48;5;161m\\]"
    readonly BG_GREEN="\\[$(tput setab 2)\\]"
    readonly BG_RED="\\[$(tput setab 1)\\]"
    readonly FG_BASE3="\\[$(tput setaf 15)\\]"
    readonly FG_BLUE="\\[$(tput setaf 4)\\]"
    readonly FG_COLOR1="\\[\\e[38;5;250m\\]"
    readonly FG_COLOR6="\\[\\e[38;5;31m\\]"
    readonly FG_COLOR9="\\[\\e[38;5;161m\\]"
    readonly FG_GREEN="\\[$(tput setaf 2)\\]"
    readonly FG_RED="\\[$(tput setaf 1)\\]"
    readonly RESET="\\[$(tput sgr0)\\]"

    __git_info() {
        # has a .git directory and a git binary
    	[ -d .git ] || command -v git >/dev/null || return 0

        local aheadN
        local behindN
        local branch
        local marks=""
        local stats

        # get current branch name or short SHA1 hash for detached head
        branch="$(git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --always 2>/dev/null)"
        [ -n "$branch" ] || return 0 # git branch not found

        # how many commits local branch is ahead/behind of remote?
        stats="$(git status --porcelain --branch | grep '^##' | grep -o '\[.\+\]$')"
        aheadN="$(echo "$stats" | grep -o 'ahead \d\+' | grep -o '\d\+')"
        behindN="$(echo "$stats" | grep -o 'behind \d\+' | grep -o '\d\+')"
        [ -n "$aheadN" ] && marks+=" $GIT_NEED_PUSH_SYMBOL$aheadN"
        [ -n "$behindN" ] && marks+=" $GIT_NEED_PULL_SYMBOL$behindN"

        # print the git branch segment without a trailing newline
        # branch is modified?
        if [ -n "$(git status --porcelain)" ]; then
            printf "%s" "${BG_COLOR8}‚ñ∂$RESET$BG_COLOR8 $branch$marks $FG_COLOR9"
        else
            printf "%s" "${BG_BLUE}‚ñ∂$RESET$BG_BLUE $branch$marks $RESET$FG_BLUE"
        fi
    }


    ps1() {
        # Check the exit code of the previous command and display different
        # colors in the prompt accordingly.
        if [ "$?" -eq 0 ]; then
            local BG_EXIT="$BG_GREEN"
            local FG_EXIT="$FG_GREEN"
        else
            local BG_EXIT="$BG_RED"
            local FG_EXIT="$FG_RED"
        fi

        PS1="$FG_COLOR1$BG_COLOR5 CodeComet \\w "
        PS1+="$RESET${FG_COLOR6}"
        PS1+="$(__git_info)"
        PS1+="$BG_EXIT‚ñ∂$RESET"
        PS1+="$BG_EXIT$FG_BASE3 ${PS_SYMBOL} ${RESET}${FG_EXIT}‚ñ∂${RESET} "
    }

    PROMPT_COMMAND=ps1
}

_cc_private::debugger::setup(){
  # Set-up PS1
  cat << EOF > "$CC_TMPFS"/.profile
# export PS1='\[\033[01;32m\]CodeComet\[\033[00m\] \w \$ '
alias l="ls -lA"
source ${BASH_SOURCE[0]}
umask 077
export LSCOLORS=exfxcxdxbxegedabagacad
export CLICOLOR=1

_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Welcome!" printf "You are now debugging your pipeline at the point it stopped.\n"
printf "\n"
#_cc_private::console::inline "$_CC_PV_COLOR_BLACK" "$_CC_PV_COLOR_BLACK" "         " printf ""
printf "Environment, pwd, and filesystem, are exactly as they were when the last action failed.\n"
printf "You can call the following helpers:\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdout" printf "will output your action stdout\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stderr" printf "will output your action stderr\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdex " printf "will output your action exit code\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_action" printf "will output the location of your action script\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Tip           " printf "If you want to re-run your action, just call \\\$(ccdebug_action)\n"

# touch "$CC_TMPFS/.codecomet/connected"
__powerline

EOF

  cat << EOF >> "$CC_TMPFS"/.inputrc
"\e[A": history-search-backward
"\e[B": history-search-forward
set show-all-if-ambiguous on
set completion-ignore-case on

EOF

}

# "on demand
# "Abnormal exit, with non zero grace:
# - start debugger repeatedly, with grace
# - once the other end exits, bail out

# "live", with non zero grace
# - start debugger, with infinity grace
# - if the other end was connected and exited, that is it, end of story
# - if the other end is still running, bring socat forward and wait for the end to exit
# - if there was no other end, we should branch back to the first scenario

# This is called on trap ERR, if a live debugger has been running, and will make a decision to bring it back forward and keep it alive,
# or to drop it
cc::debugger::front(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  cc::logger::debug "[debugger-front] socat is here"
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  cc::logger::debug "[debugger-front] grace is fine"


  # Debugger still live? Bail out if not
  jobs | grep -q -v Done || {
    cc::logger::debug "[debugger-front] no jobs detected. Bailing out."
    return 0
  }

  # Ok, it is live. Do we have a client?
  # XXX unfortunately, this does not work as expected... socat does start the process first, bash sources the files and create the stamp file...
  local lasttry
  local current
  lasttry="$(cat $CC_TMPFS/.codecomet/lasttry 2>/dev/null)" || true
  current="$(date +%s)"
  # The older an unconnected socat could be is 2 seconds - if greater than that, then we definitely have a client
  # However, it is possible that a client has been connected for less than 2 seconds (since socat call) when the failure happens,
  # which means the client will wrongly get the boot... no good solution right now
  [ $(( current - lasttry)) -gt 2 ] && {
  # [ -e "$CC_TMPFS/.codecomet/connected" ] && {
    cc::logger::debug "[debugger-front] we have a connected client"
    # Yes, then foreground and let it sit
    fg 2>/dev/null
  } || {
    cc::logger::debug "[debugger-front] no live client. Kick it out restart."
    # No live client. Kill it, and start again the normal process with timeout and message
    kill %%
    cc::debugger::start "$ex"
  }
}

# XXX this is largely broken
cc::debugger::live(){
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  while true; do
    lasttry="$(date +%s)"
    printf "%s" "$lasttry" > "$CC_TMPFS/.codecomet/lasttry"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-live] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Break if we have been hanging out more than a second (meaning the other end did connect, but exit in error)
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-live] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
    }
    x=$(( x + 1 ))
    cc::logger::debug "[debugger-live] sleeping"
    sleep 1
  done
}

cc::debugger::start(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  # Prep-up profile
  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  cc::logger::error "Abnormal exit code $ex. If you want to inspect manually, start codecomet-debugger. Otherwise, we will exit after $CC_DEBUGGER_GRACE seconds"
  cc::logger::error "You can also restart the build with CODECOMET_DEBUG=true"

  >&2 _cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "waiting" printf "Waiting %s seconds for debugger to connect" "$CC_DEBUGGER_GRACE"
  # cc::logger::warning "Waiting "


  # https://medium.com/@JAlblas/tryhackme-what-the-shell-walkthrough-6c0ebe8f854e
  #pty, allocates a pseudoterminal on the target ‚Äî part of the stabilisation process
  #stderr, makes sure that any error messages get shown in the shell (often a problem with non-interactive shells)
  #sigint, passes any Ctrl + C commands through into the sub-process, allowing us to kill commands inside the shell
  #setsid, creates the process in a new session
  #sane, stabilises the terminal, attempting to ‚Äúnormalise‚Äù it.

  while [ "$x" -lt "$CC_DEBUGGER_GRACE" ]; do
    lasttry="$(date +%s)"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-stat] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Timeing out means we wait for a second. Any more than that should mean the connection was succesful
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-stat] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
      >&2 printf "."
    }
    x=$(( x + 1 ))
    sleep 1
  done
}

ccdebug_stdout(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stdout.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stdout.log
  fi
}

ccdebug_stderr(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stderr.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stderr.log
  fi
}

ccdebug_stdex(){
  [ -e "$CC_TMPFS"/.codecomet/logs/ex.log ] && {
    cat "$CC_TMPFS"/.codecomet/logs/ex.log
  } || {
    cc::logger::warning "Action is in progress, no exit code yet"
  }
}

ccdebug_action(){
  echo "$_CC_PV_SCRIPT"
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# List all environment variables we depend on, possibly providing defaults
########################################################################################################################

#############
# Generic controls
#############
# Log level to start with (error, warning, info, debug or 4, 3, 2, 1, 0 <- mute)
readonly CC_LOG_LEVEL="${CC_LOG_LEVEL:-}"
# Where is the tempfs mounted
readonly CC_TMPFS="${CC_TMPFS:-}"
# Honors NO_COLOR (see https://no-color.org/)
# shellcheck disable=SC2034
readonly CC_CAP_NO_COLOR="${NO_COLOR:-}"
# About detection
# https://stackoverflow.com/questions/911168/how-can-i-detect-if-my-shell-script-is-running-through-a-pipe
# Could also test for [ ! -t 2 ]
# Or could be: `test -t 0` (formerly `tty -s`)
# In our context though, this probably does not matter much
# shellcheck disable=SC2034
readonly CC_CAP_HAS_TERM="${TERM:-}"

#############
# Action execution flow control
#############
# Whether the action can fail or not
readonly CC_ACTION_CAN_FAIL="${CC_ACTION_CAN_FAIL:-}"

#############
# Tracing and debugging
#############
# Controls wether the tracer will also trace internal codecomet library or hide them
readonly CC_TRACER_CODECOMET_INTERNALS="${CC_TRACER_CODECOMET_INTERNALS:-}"
# How long to wait for a connection before dropping the debugger
export CC_DEBUGGER_GRACE="${CC_DEBUGGER_GRACE:-}"
# Port to connect to
readonly CC_DEBUGGER_PORT="${CC_DEBUGGER_PORT:-}"
# IP to connect to
readonly CC_DEBUGGER_IP="${CC_DEBUGGER_IP:-}"
# Whether a debugger should be started pre-emptively so that one can hook in "live" during the action. This is very wonky as soon as you have parallelism...
readonly CC_DEBUGGER_LIVE="${CC_DEBUGGER_LIVE:-}"


#############
# Error code used accross the codebase - rn, only the bland FAILED is used...
#############
# shellcheck disable=SC2034
readonly ERROR_NETWORK=200
# Thrown if a required argument is missing
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_MISSING=201
# Thrown if an argument does not match validation
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_INVALID=202
# Should be used to convey that a certain operation is not supported
# shellcheck disable=SC2034
readonly ERROR_UNSUPPORTED=203
# Generic error to denote that the operation has failed. More specific errors may be provided instead
# shellcheck disable=SC2034
readonly ERROR_FAILED=204
# Expectations failed on a file (not readable, writable, doesn't exist, can't be created)
# shellcheck disable=SC2034
readonly ERROR_FILESYSTEM=205
# System requirements
# shellcheck disable=SC2034
readonly ERROR_MISSING_REQUIREMENTS=206

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# A generic logger
#
# Depends on:
# console.sh
########################################################################################################################

readonly CC_LOGGER_DEBUG=4
readonly CC_LOGGER_INFO=3
readonly CC_LOGGER_WARNING=2
readonly CC_LOGGER_ERROR=1

_CC_PV_LOGGER_LEVEL="$CC_LOGGER_WARNING"

_cc_private::logger::log(){
  local prefix="$1"
  shift

  local level="CC_LOGGER_$prefix"
  local i

  [ "$_CC_PV_LOGGER_LEVEL" -ge "${!level}" ] || return 0

  # About the crazy shit: https://stackoverflow.com/questions/12674783/bash-double-process-substitution-gives-bad-file-descriptor
  exec 3>&2
  for i in "$@"; do
    >&2 cc::console::"$(printf "$prefix" | tr '[:upper:]' '[:lower:]')" printf "$i"
  done
  exec 3>&-
}

cc::logger::level::set() {
  local level
  level="$(printf "%s" "${1:-}" | tr '[:upper:]' '[:lower:]')"

  case "$level" in
    ''|*[!0-9]*)
      case "$level" in
          "debug")
            _CC_PV_LOGGER_LEVEL=4
            ;;
          "info")
            _CC_PV_LOGGER_LEVEL=3
            ;;
          "warning")
            _CC_PV_LOGGER_LEVEL=2
            ;;
          "error")
            _CC_PV_LOGGER_LEVEL=1
            ;;
          "mute")
            _CC_PV_LOGGER_LEVEL=0
            ;;
          *)
            _CC_PV_LOGGER_LEVEL=3
            ;;
      esac
      ;;
    *)
      if [ "$level" -gt "$CC_LOGGER_DEBUG" ]; then
        return "$ERROR_FAILED"
      fi
      _CC_PV_LOGGER_LEVEL="$level"
      ;;
  esac

  [ "$_CC_PV_LOGGER_LEVEL" != "$CC_LOGGER_DEBUG" ] || {
    cc::console::warning printf "YOU ARE LOGGING AT THE DEBUG LEVEL."
    cc::console::warning printf "This is NOT recommended for production use, and WILL LIKELY LEAK sensitive information to logs."
  }
}

# Sugar
cc::logger::level::set::debug(){
  cc::logger::level::set "$CC_LOGGER_DEBUG"
}

cc::logger::level::set::info(){
  cc::logger::level::set "$CC_LOGGER_INFO"
}

cc::logger::level::set::warning(){
  cc::logger::level::set "$CC_LOGGER_WARNING"
}

cc::logger::level::set::error(){
  cc::logger::level::set "$CC_LOGGER_ERROR"
}

cc::logger::mute() {
  _CC_PV_LOGGER_LEVEL=0
}

cc::logger::ismute() {
  [ "$_CC_PV_LOGGER_LEVEL" == 0 ] || return "$ERROR_FAILED"
}

cc::logger::debug(){
  _cc_private::logger::log "DEBUG" "$@"
}

cc::logger::info(){
  _cc_private::logger::log "INFO" "$@"
}

cc::logger::warning(){
  _cc_private::logger::log "WARNING" "$@"
}

cc::logger::error(){
  _cc_private::logger::log "ERROR" "$@"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provides fancy display for `set -x`
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
########################################################################################################################

cc::codecomet::tracer(){
  local length="${#BASH_SOURCE[@]}"

  #local indent=""
  local linenumber
  local filename
  local filecontent
  local funcname
  local col

  [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[1]}" == *"action.sh" ]] || return 0

  printf "\n"

  for (( j=$(( length - 1 )); j>0; j-- )); do
    [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[$j]}" == *"action.sh" ]] || {
      continue
    }

    linenumber="${BASH_LINENO[$(( j - 1 ))]}"
    filename="${BASH_SOURCE[$j]}"
    filecontent="$(cat -n "$filename" | grep -E "^\s+$linenumber\s" | sed -E "s/^\s+$linenumber\s+//")"
    funcname="${FUNCNAME[$j]}"

    # Why is this showing is a mystery for the times
    # [ "$filecontent" != "#!/usr/bin/env bash" ] || continue

    [ "$j" != 1 ] && {
      col="$CC_COLOR_DEFAULT_FRONT"
    } || {
      col="$CC_COLOR_TRACER_HUMPF"
    }

    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$filename"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$linenumber"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "function" printf "%-30s" "$funcname()"
    printf "\n"
    [ "$j" != 1 ] || {
      _cc_private::console "$CC_COLOR_TRACER_COMMAND_LABEL" "$CC_COLOR_DEFAULT_FRONT" "command" printf "%s" "$filecontent"
      _cc_private::console "$CC_COLOR_TRACER_OUTPUT_LABEL" "$CC_COLOR_DEFAULT_FRONT" "output" printf ""
    }

  done
}

cc::tracer::register(){
  # shellcheck disable=SC2016
  local ps=('$(' "$@" ')')
  export PS4="${ps[*]}"
}

cc::init::tracer(){
  cc::tracer::register cc::codecomet::tracer
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Trap management
#
# Depends on:
# colors.sh
# console.sh
########################################################################################################################

_CC_PV_TRAP_LISTENERS=()

_CC_PV_ERR_LNO=
_CC_PV_ERR_CMD=
_CC_PV_ERR_STACK=
_CC_PV_ERR_EX=

dc::trap::register(){
  _CC_PV_TRAP_LISTENERS+=( "$1" )
}

# Trap lno and cmd on ERR for future use
cc::trap::err(){
  _CC_PV_ERR_EX="$1"
  _CC_PV_ERR_LNO="$2"
  _CC_PV_ERR_CMD="$3"
  _CC_PV_ERR_STACK="$4"
  # Dropping the rest of the stack?

  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$_CC_PV_ERR_STACK"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$_CC_PV_ERR_LNO"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "exit" printf "%s" "$_CC_PV_ERR_EX"
  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "command" printf "%-30s" "$_CC_PV_ERR_CMD"
  >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  >&2 printf "\n"

  >&2 _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "source" printf ""
  prefix=" "
  for (( j=$(( _CC_PV_ERR_LNO - 3 )); j<$(( _CC_PV_ERR_LNO + 3 )); j++ )); do
    [ "$j" -gt 0 ] || continue
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=">"
      >&2 _cc_private::tput setaf "$CC_COLOR_ERROR_FRONT"
      #>&2 _cc_private::tput bold
    fi
    #  | sed -E "s/^\s+$j\s//"
    >&2 printf "%s%s" "$prefix" "$(cat -n "$_CC_PV_ERR_STACK" | grep -E "^\s+$j\s")" || true
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=" "
      >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
      #>&2 _cc_private::tput sgr0
    fi
    >&2 printf "\n"
  done
}

_CC_PV_NO_REENTRY=

# Trap exit for the actual cleanup
cc::trap::exit() {
  # { set +x; } 2>/dev/null

  local ex="$1"
  local i

  # Prevent reentrancy - XXX is this actually needed?
  [ ! "$_CC_PV_NO_REENTRY" ] || return 0
  _CC_PV_NO_REENTRY="exiting"

  printf "%s\n" "$ex" > "$CC_TMPFS"/.codecomet/logs/ex.log

  if [ "${#_CC_PV_TRAP_LISTENERS[@]}" -gt 0 ]; then
    for i in "${_CC_PV_TRAP_LISTENERS[@]}"; do
      cc::logger::debug "Calling exit hook $i"
#      >&2 printf "\n"
      "$i" "$ex" "$_CC_PV_ERR_CMD" "$_CC_PV_ERR_LNO" "$_CC_PV_ERR_STACK"
    done
  fi
  >&2 cc::console::reset
  >&2 printf "\n"
  cc::logger::debug "Exiting ($ex)"
  [ "$CC_ACTION_CAN_FAIL" == "true" ] && {
    [ "$ex" != "" ] || cc::logger::error "Action failed, but it is marked as 'can fail', so, exiting successfully"
    exit 0
  } || exit "$ex"
}

# Forking to disable xtrace when entering traps
cc::init::trap(){
  # Signals are caught by buildkit already - and only SIGKILL triggers a failure
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::err "$ex" "$LINENO" "$BASH_COMMAND" "${BASH_SOURCE[@]}"' ERR
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::exit "$ex"' EXIT
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# See https://manpages.ubuntu.com/manpages/xenial/man1/eatmydata.1.html
# Technically, we get a 10% speedup with apt operations for eg
# XXX careful here if this is going to be used in a chroot
cc::init::speedup(){
  ! command -v eatmydata >/dev/null || export LD_PRELOAD=libeatmydata.so
}

# Boot if we have an argument - otherwise, we are being sourced
if [ "$#" -gt 0 ]; then
  mkdir -p "$TMPDIR"
  rm -Rf "$CC_TMPFS"/.codecomet
  mkdir -p "$CC_TMPFS"/.codecomet/bin
  mkdir -p "$CC_TMPFS"/.codecomet/logs

  # Set logger to env var from the Bash helper
  cc::logger::level::set "$CC_LOG_LEVEL"

  # Eat data, trap, register tracer, register debugger on exit trap
  cc::init::speedup
  cc::init::trap
  cc::init::tracer
  # Live debugger is really wonky
  if [ "${CC_DEBUGGER_LIVE:-}" != "" ]; then
    cc::debugger::live &
    dc::trap::register cc::debugger::front
  else
    [ "$CC_ACTION_CAN_FAIL" == true ] || dc::trap::register cc::debugger::start
  fi

  # XXX technically, we receive a bunch of scripts, and we could just play them all - use case is not completely clear yet
  out="$CC_TMPFS"/.codecomet/logs/stdout.log
  err="$CC_TMPFS"/.codecomet/logs/stderr.log

  # Unpack libraries path and source them
  while [ "$#" -gt 1 ]; do
    cp "$1" "$CC_TMPFS"/.codecomet/bin
    # shellcheck disable=SC1090
    source "$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
    shift
  done
  cp "$1" "$CC_TMPFS"/.codecomet/bin
  _CC_PV_SCRIPT="$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
  export _CC_PV_SCRIPT

  # Run the actual action
  # shellcheck disable=SC1090
  source "$_CC_PV_SCRIPT" > >(tee -a "$out") 2> >(tee -a "$err" >&2)
else
  # If we are a library, toss this one so we do not exit on any error...
  # This is especially important for the reverse debugger
  set +o errexit
fi
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
â"Ûˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*◊
/library0.sh¿∏#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# A generic lock mechanism that supports exclusive locks, shared locks, and a simplistic queueing mechanism
_cc_lockindex=9
_cc_lock_location="/_cc/share/locks"

# Sets our locks location. Must be called to guarantee that the lock location exist.
cc::lock::init(){
	_cc_lock_location="${1:-.}"
	mkdir -p "${_cc_lock_location}"
}

# Acquire a lock with a given name, and a share mode (shared or exclusive (which is the default))
# If the lock is already acquired in a different mode, or the mode is exclusive, the function will wait until the lock is released.
# Return the lock id that you need to carry around to release the lock later on.
cc::lock::acquire(){
	local lockfile="$_cc_lock_location/$1"
	local shared="${2:-}"
	[ "$shared" ] && shared=-s || shared=-x
	_cc_lockindex=$((_cc_lockindex+1))
	mkdir -p "$(dirname "$lockfile")"
	exec {_cc_lockindex}>"$lockfile"
	flock $shared $_cc_lockindex
	return $_cc_lockindex
}

# Release a previously acquire lock by its id
cc::lock::release(){
	local idx="$1"
	# This is essentially the same
	flock -u "$idx"
	# exec {idx}>&-
}

cc::lock::queue(){
	local basepath="${1:-.}"
	local shared1="${2:-}"
	local shared2="${3:-}"
	local qid
	local oid

	# Get into the queue first
	cc::lock::acquire "$basepath"/cc_queue.lock "$shared1" || qid=$?

	# Then when out of the queue, acquire an operation lock
	cc::lock::acquire "$basepath"/cc_op.lock "$shared2" || oid=$?

	# Now, leave the queue
	cc::lock::release $qid

	# Return the lock id
	return $oid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
˙"‰·ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*»
/library1.sh¿©#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Lessons learned:
# - find -exec is VERY SLOW - better off piping to read (almost 10x) (0.2 second vs 0.02 second for about 200 files)
# - then globbing and grepping is faster than find + read
# This matters not in case we are copying a large amount of data of course, but then
# - there is no way to get something stable out of ls without further processing - directories with different owners
# for eg will widen some columns
# this "works" right now (if we do not use --numeric-uid-gid) but will be problematic outside of this specific case

_cc::fingerprint(){
  local directory="$1"
  # Will fail if the directory is empty, so the guardrail
  # Ignore directories, links, and "total" (note: -d will not work for that)
  # --numeric-uid-gid < messes up the output width
  # shellcheck disable=SC2010
  ls --full-time --almost-all --ignore lock "$directory" 2>/dev/null | grep -v "^[d|l|t]" || true
}

# Copy or symlink data "from" storage "to" destination
# This assume that storage holds only files, and no lock
# Will not copy anything if there is no difference
cc::storage::retrieve(){
  local from="$1"
  local to="$2"
  local copy="${3:-}"
  local lid
  local fromState

  # Ensure destination exists
  mkdir -p "$to"

  # Lock origin and keep the lock id
  cc::lock::acquire "$from" shared || lid=$?

  # Ensure origin exists
  mkdir -p "$from"

  # If we are asked to copy (not expected for large amount of data - linking is prefered in that case)
  if [ "$copy" ]; then
    # Retrieve the state of it
    fromState="$(_cc::fingerprint "$from")"

    # Check that we have content in storage
    # Check that we have a difference between storage and destination (ignoring directories and lock file)
    # shellcheck disable=SC2010
    # shellcheck disable=SC2015
    [ "$fromState" ] && [ "$fromState" != "$(_cc::fingerprint "$to")" ] && {
      # Then cleanup destination
      rm -Rf "$to"
      mkdir -p "$to"
      # And copy over
      cp -p "$from"/* "$to"
      # Slower
      #find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
      #  cp -p "$fd" "$to"
      #done
    } || {
      # Otherwise, do nothing
      cc::logger::debug "Nothing to retrieve from storage"
    }
  else
    # We want links, so, lets check we have anything in the origin
    #[ ! "$fromState" ] || {
    # Get rid of possibly remaining files in our destination
    find "$to" -type f -delete
    ln -sf "$from"/* "$to" 2>/dev/null || true
    # Note: below is slower
    # find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
    #  ln -s "$fd" "$to"
    # done
    #}
  fi

  # Release the lock
	cc::lock::release $lid
}

cc::storage::store(){
  local from="$1"
  local to="$2"
  local erase="${3:-}"
  local lid
  local fd
  local toState

  # Ensure origin exists
  mkdir -p "$from"

  # Lock destination and keep the lock id
  cc::lock::acquire "$to" "" || lid=$?

  # Ensure destination exists
  mkdir -p "$to"
  # Retrieve the state of it
  # shellcheck disable=SC2010
  toState="$(_cc::fingerprint "$to")"

  # Compare state of the destination with the origin (origin ignores directories and lock files)
  # shellcheck disable=SC2010
  # shellcheck disable=SC2015
  [ "$toState" != "$(_cc::fingerprint "$from")" ] && {
    # We have changes - if asked to wipe out, do so
    if [ "$erase" ]; then
      rm -Rf "$to"
      mkdir -p "$to"
    fi
    # Now copy the files
    # This is probably slow-ish. The question is: will it be significant in a context where copy IO is the bottleneck?
    find "$from" -type f -not -iname "lock" -print0 | while IFS= read -r -d $'\0' fd; do
      cp -p "$fd" "$to"
    done
  } || {
    cc::logger::debug "Nothing to save to storage"
  }

  # Release the lock
	cc::lock::release $lid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
Ï*"÷*”*ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∫*
/library2.sh¿õ*#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Helpers to allow apt to share cache properly

# Private tmpfs location
_cc_tmpfs_location=/codecomet/apt-get-private/tmp

# Location of the list cache
_cc_apt_list_store_location=/codecomet/apt-get-shared/lists
# And pack cache
_cc_apt_pack_local_location=/codecomet/apt-get-shared/packs

# Location of the packages cache
_cc_apt_pack_store_location=/codecomet/apt-get-shared/cache

# Location of our private lists files - by default, Debian normal location, which means state will persist
_cc_apt_list_local_location=/var/lib/apt/lists

# Location of the config file
export APT_CONFIG=$_cc_tmpfs_location/apt-get.conf

# Hash of the sources.list, which dictates the cache location to share
# Different sources means different cache location
# Caveats: this will likely not work with a future debian release as they change the sources.list format
# XXX this wracking the debugger output
cc::apt_get::shard(){
  sha256sum <<< "$(uname -m)$(grep --no-filename -Ev "^#" /etc/apt/sources.list /etc/apt/sources.list.d/* 2>/dev/null | sed -E 's/#.+$//' | sort || true)" | sed -E 's/  .*//'
}

# Set the tmp location, initiliaze APT_CONFIG and shared and private locations
cc::apt_get::init(){
  # Get the desired tmpfs mount point
  _cc_tmpfs_location="$1"

  mkdir -p "$_cc_tmpfs_location"

  # Point configuration there
  export APT_CONFIG="$_cc_tmpfs_location"/apt-get.conf

  # Sharding by sources list content, cleaned-up and sorted to maximize cache hits
	_cc_apt_list_store_location="$2/$(cc::apt_get::shard)"

  # Technically, we should not be sharding the architecture
  # But then, the only upside would be when installing cross-arch packages
	_cc_apt_pack_store_location="$3/$(cc::apt_get::shard)"

  # If we do not want lists to persist, use the tmp storage
  [ "${4:-}" == true ] || _cc_apt_list_local_location="$_cc_tmpfs_location"/lists

  # Finally, local pack location
  _cc_apt_pack_local_location="$_cc_tmpfs_location"/packs

  # Make sure they all exist
  mkdir -p "$_cc_apt_list_local_location"
  mkdir -p "$_cc_apt_pack_local_location"

  mkdir -p "$_cc_apt_list_store_location"
  mkdir -p "$_cc_apt_pack_store_location"
}

# Create the configuration file for APT
cc::apt_get::configure(){
  local config_extra="${1:-}"
  local persist="${2:-}"

  mkdir -p "$_cc_tmpfs_location/logs"
  cat << EOF > "$APT_CONFIG"
# Divert both lists and archives location
Dir::Cache::Archives "$_cc_apt_pack_local_location";
Dir::State::Lists "$_cc_apt_list_local_location";
# Prevent the default apt config to be used
Dir::Etc::parts "";
# Put the logs in the tmp zone
Dir::Log "$_cc_tmpfs_location/logs";
# Put the bin cache files in the private mount
Dir::Cache::srcpkgcache "$_cc_tmpfs_location/srcpkgcache.bin";
Dir::Cache::pkgcache "$_cc_tmpfs_location/pkgcache.bin";

$config_extra
EOF

  # If asked to persist the config, copy over the generated file
  [ "$persist" == "false" ] || cp "$APT_CONFIG" /etc/apt/apt.conf
}

#cc::apt_get::cleanup(){
  # This is only necessary if we were not using an tmpfs mount...
  # rm "$APT_CONFIG"
#}

cc::apt_get::update(){
  # Remove our marker if here
  rm -f "$_cc_apt_list_local_location"/.cc_updated

  # Retrieve existing data
  cc::storage::retrieve "$_cc_apt_list_store_location" "$_cc_apt_list_local_location" copy

	# Do the deed, same restriction applies
	apt-get update "$@"

  # Save it back (storage will decide)
  cc::storage::store "$_cc_apt_list_local_location" "$_cc_apt_list_store_location" erase

  # Now, flag it
  date > "$_cc_apt_list_local_location"/.cc_updated
}

cc::apt_get::do(){
  # Bring in any cache
  cc::storage::retrieve "$_cc_apt_pack_store_location" "$_cc_apt_pack_local_location"

	apt-get "$@"

  # Store the packages permanently
  cc::storage::store "$_cc_apt_pack_local_location" "$_cc_apt_pack_store_location"
}

# XXX what if sources are being modified, or config, or something else that materially impacts update?
cc::high::update(){
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "$nooutput"

  args+=("$@")
  time cc::apt_get::update "${args[@]}"
}

cc::high::install(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists has been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  args+=("$@")
  time cc::apt_get::do install "${args[@]}"
}

cc::high::upgrade(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists have been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  # ls -lAR "$_cc_tmpfs_location"/packs || true
  # time cc::apt_get::do upgrade "$nooutput" "$@"

  # XXX WIP here
  # Bust cache - delete this
  #time cc::apt_get::do upgrade --download-only "$nooutput" "$@"
  #time cc::apt_get::do upgrade --no-download "$nooutput" "$@"
  args+=("$@")
  time cc::apt_get::do upgrade "${args[@]}"
}

cc::high::purge(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")

  args+=("$@")
  time cc::apt_get::do purge --auto-remove "${args[@]}"
}(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
’"øºˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*£

/action.sh¿Ü#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::upgrade

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f7942
 



Z 
£
I
Gsha256:aba97bce52cb75c817d06fec2353f811940c416a472ab6b0fab8ae0a54511d83
I
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
arm64linuxZ 
Í"‘—ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∏

/action.sh¿õ#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::install eatmydata nano socat

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c2
 



Z 
£
I
Gsha256:1f71c46c8f58462f657331fc0617521fb54f9990f04397320f86547435ca03f3
I
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
arm64linuxZ 
K
I
Gsha256:c7759768f7674d770a8a4ef7c18d38e5c0deb872d612f1f8102e8bdebc9bcf0eπ
Gsha256:1f71c46c8f58462f657331fc0617521fb54f9990f04397320f86547435ca03f3Ì!
codecomet.optest codecomet op!
llb.customnameapt-get upgrade*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeü
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library2.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library1.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962—!
codecomet.optest codecomet op0
llb.customname[action:addfile] codecomet in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupË
Gsha256:aba97bce52cb75c817d06fec2353f811940c416a472ab6b0fab8ae0a54511d83ú!
codecomet.optest codecomet opG
llb.customname5[source:image] docker.io/library/debian:bullseye-slim*
source.image*
source.image.resolvemodeê
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edfƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library0.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupŒ
Gsha256:c7759768f7674d770a8a4ef7c18d38e5c0deb872d612f1f8102e8bdebc9bcf0eÇ!
codecomet.optest codecomet op6
llb.customname$apt-get install eatmydata nano socat*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeÄ
Gsha256:e0223abffd3a522e48edba08a44b777ad6b5b53eaafcfe5f5f7ae63aaa1097405*
constraints*
meta.description*
platformê
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8aƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupœ
K
Gsha256:1f71c46c8f58462f657331fc0617521fb54f9990f04397320f86547435ca03f3 
K
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f 
K
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7 
K
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962 
K
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c 
K
Gsha256:aba97bce52cb75c817d06fec2353f811940c416a472ab6b0fab8ae0a54511d83 
K
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf 
K
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c 
K
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794 
K
Gsha256:c7759768f7674d770a8a4ef7c18d38e5c0deb872d612f1f8102e8bdebc9bcf0e 
K
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a 
hR
5docker-image://docker.io/library/debian:bullseye-slim
image.resolvemodepullR
armlinuxv7Z 
æ›"ß›£›ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*â›

/codecomet¿Î‹#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Defines the supported color palette, and our color scheme
########################################################################################################################

# Supported color palette
readonly _CC_PV_COLOR_BLACK=0
readonly _CC_PV_COLOR_RED=1
readonly _CC_PV_COLOR_GREEN=2
readonly _CC_PV_COLOR_YELLOW=3
# shellcheck disable=SC2034
readonly _CC_PV_COLOR_BLUE=4
readonly _CC_PV_COLOR_MAGENTA=5
readonly _CC_PV_COLOR_CYAN=6
readonly _CC_PV_COLOR_WHITE=7

# Colors scheme definition - can evidently be customized at runtime by setting these variables to other values from the palette
export CC_COLOR_DEFAULT_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEFAULT_BACK="$_CC_PV_COLOR_BLACK"

export CC_COLOR_BODY="$_CC_PV_COLOR_WHITE"
export CC_COLOR_COMMENT="$_CC_PV_COLOR_CYAN"
export CC_COLOR_HUMPF="$_CC_PV_COLOR_MAGENTA"

# Logger
export CC_COLOR_ERROR_FRONT="$_CC_PV_COLOR_RED"
export CC_COLOR_ERROR_BACK="$_CC_PV_COLOR_WHITE"
export CC_COLOR_WARNING_FRONT="$_CC_PV_COLOR_YELLOW"
export CC_COLOR_WARNING_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_INFO_FRONT="$_CC_PV_COLOR_GREEN"
export CC_COLOR_INFO_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_DEBUG_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEBUG_BACK="$_CC_PV_COLOR_BLACK"

# Tracer
export CC_COLOR_TRACER_HUMPF="$_CC_PV_COLOR_GREEN"
export CC_COLOR_TRACER_COMMAND_LABEL="$_CC_PV_COLOR_BLUE"
export CC_COLOR_TRACER_OUTPUT_LABEL="$_CC_PV_COLOR_RED"
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provide helpers to print colorful text
#
# Depends on:
# defaults.sh
# colors.sh
########################################################################################################################

_cc_private::tput(){
  [ ! "$CC_CAP_HAS_TERM" ] || [ "$CC_CAP_NO_COLOR" != "" ] || tput "$@" 2>/dev/null || true
}

_cc_private::console::inline(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it and pad to 7 chars, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"
}

_cc_private::console(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-7s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    # Otherwise, just a plain front/back
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"

  # Restore console to default before we \n so that we do not leak over into BK timestamp display
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::error(){
  _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_ERROR_BACK" "error" "$@"
}

cc::console::warning(){
  _cc_private::console "$CC_COLOR_WARNING_FRONT" "$CC_COLOR_WARNING_BACK" "warning" "$@"
}

cc::console::info(){
  _cc_private::console "$CC_COLOR_INFO_FRONT" "$CC_COLOR_INFO_BACK" "info" "$@"
}

cc::console::debug(){
  _cc_private::console "$CC_COLOR_DEBUG_FRONT" "$CC_COLOR_DEBUG_BACK" "debug" "$@"
}

cc::console::body(){
  _cc_private::console "$CC_COLOR_BODY" "" "" "$@"
}

cc::console::comment(){
  _cc_private::console "$CC_COLOR_COMMENT" "" "" "$@"
}

cc::console::humpf(){
  _cc_private::console "$CC_COLOR_HUMPF" "" "" "$@"
}

cc::console::reset(){
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::end(){
  _cc_private::tput op
  printf "\n"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Debugger based on socat
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
# logger.sh
########################################################################################################################

# Fancy prompt adapted from https://github.com/pombadev/fancy-linux-prompt/blob/master/LICENSE under MIT License
__powerline() {
    # Unicode symbols
    readonly GIT_NEED_PULL_SYMBOL='‚á£'
    readonly GIT_NEED_PUSH_SYMBOL='‚á°'
    readonly PS_SYMBOL='ü™ê' # üêß‚òÑ'‚ñ∂‚èµ‚ñ∂‚èµ

    # Solarized colorscheme
    readonly BG_BLUE="\\[$(tput setab 4)\\]"
    readonly BG_COLOR5="\\[\\e[48;5;31m\\]"
    readonly BG_COLOR8="\\[\\e[48;5;161m\\]"
    readonly BG_GREEN="\\[$(tput setab 2)\\]"
    readonly BG_RED="\\[$(tput setab 1)\\]"
    readonly FG_BASE3="\\[$(tput setaf 15)\\]"
    readonly FG_BLUE="\\[$(tput setaf 4)\\]"
    readonly FG_COLOR1="\\[\\e[38;5;250m\\]"
    readonly FG_COLOR6="\\[\\e[38;5;31m\\]"
    readonly FG_COLOR9="\\[\\e[38;5;161m\\]"
    readonly FG_GREEN="\\[$(tput setaf 2)\\]"
    readonly FG_RED="\\[$(tput setaf 1)\\]"
    readonly RESET="\\[$(tput sgr0)\\]"

    __git_info() {
        # has a .git directory and a git binary
    	[ -d .git ] || command -v git >/dev/null || return 0

        local aheadN
        local behindN
        local branch
        local marks=""
        local stats

        # get current branch name or short SHA1 hash for detached head
        branch="$(git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --always 2>/dev/null)"
        [ -n "$branch" ] || return 0 # git branch not found

        # how many commits local branch is ahead/behind of remote?
        stats="$(git status --porcelain --branch | grep '^##' | grep -o '\[.\+\]$')"
        aheadN="$(echo "$stats" | grep -o 'ahead \d\+' | grep -o '\d\+')"
        behindN="$(echo "$stats" | grep -o 'behind \d\+' | grep -o '\d\+')"
        [ -n "$aheadN" ] && marks+=" $GIT_NEED_PUSH_SYMBOL$aheadN"
        [ -n "$behindN" ] && marks+=" $GIT_NEED_PULL_SYMBOL$behindN"

        # print the git branch segment without a trailing newline
        # branch is modified?
        if [ -n "$(git status --porcelain)" ]; then
            printf "%s" "${BG_COLOR8}‚ñ∂$RESET$BG_COLOR8 $branch$marks $FG_COLOR9"
        else
            printf "%s" "${BG_BLUE}‚ñ∂$RESET$BG_BLUE $branch$marks $RESET$FG_BLUE"
        fi
    }


    ps1() {
        # Check the exit code of the previous command and display different
        # colors in the prompt accordingly.
        if [ "$?" -eq 0 ]; then
            local BG_EXIT="$BG_GREEN"
            local FG_EXIT="$FG_GREEN"
        else
            local BG_EXIT="$BG_RED"
            local FG_EXIT="$FG_RED"
        fi

        PS1="$FG_COLOR1$BG_COLOR5 CodeComet \\w "
        PS1+="$RESET${FG_COLOR6}"
        PS1+="$(__git_info)"
        PS1+="$BG_EXIT‚ñ∂$RESET"
        PS1+="$BG_EXIT$FG_BASE3 ${PS_SYMBOL} ${RESET}${FG_EXIT}‚ñ∂${RESET} "
    }

    PROMPT_COMMAND=ps1
}

_cc_private::debugger::setup(){
  # Set-up PS1
  cat << EOF > "$CC_TMPFS"/.profile
# export PS1='\[\033[01;32m\]CodeComet\[\033[00m\] \w \$ '
alias l="ls -lA"
source ${BASH_SOURCE[0]}
umask 077
export LSCOLORS=exfxcxdxbxegedabagacad
export CLICOLOR=1

_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Welcome!" printf "You are now debugging your pipeline at the point it stopped.\n"
printf "\n"
#_cc_private::console::inline "$_CC_PV_COLOR_BLACK" "$_CC_PV_COLOR_BLACK" "         " printf ""
printf "Environment, pwd, and filesystem, are exactly as they were when the last action failed.\n"
printf "You can call the following helpers:\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdout" printf "will output your action stdout\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stderr" printf "will output your action stderr\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdex " printf "will output your action exit code\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_action" printf "will output the location of your action script\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Tip           " printf "If you want to re-run your action, just call \\\$(ccdebug_action)\n"

# touch "$CC_TMPFS/.codecomet/connected"
__powerline

EOF

  cat << EOF >> "$CC_TMPFS"/.inputrc
"\e[A": history-search-backward
"\e[B": history-search-forward
set show-all-if-ambiguous on
set completion-ignore-case on

EOF

}

# "on demand
# "Abnormal exit, with non zero grace:
# - start debugger repeatedly, with grace
# - once the other end exits, bail out

# "live", with non zero grace
# - start debugger, with infinity grace
# - if the other end was connected and exited, that is it, end of story
# - if the other end is still running, bring socat forward and wait for the end to exit
# - if there was no other end, we should branch back to the first scenario

# This is called on trap ERR, if a live debugger has been running, and will make a decision to bring it back forward and keep it alive,
# or to drop it
cc::debugger::front(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  cc::logger::debug "[debugger-front] socat is here"
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  cc::logger::debug "[debugger-front] grace is fine"


  # Debugger still live? Bail out if not
  jobs | grep -q -v Done || {
    cc::logger::debug "[debugger-front] no jobs detected. Bailing out."
    return 0
  }

  # Ok, it is live. Do we have a client?
  # XXX unfortunately, this does not work as expected... socat does start the process first, bash sources the files and create the stamp file...
  local lasttry
  local current
  lasttry="$(cat $CC_TMPFS/.codecomet/lasttry 2>/dev/null)" || true
  current="$(date +%s)"
  # The older an unconnected socat could be is 2 seconds - if greater than that, then we definitely have a client
  # However, it is possible that a client has been connected for less than 2 seconds (since socat call) when the failure happens,
  # which means the client will wrongly get the boot... no good solution right now
  [ $(( current - lasttry)) -gt 2 ] && {
  # [ -e "$CC_TMPFS/.codecomet/connected" ] && {
    cc::logger::debug "[debugger-front] we have a connected client"
    # Yes, then foreground and let it sit
    fg 2>/dev/null
  } || {
    cc::logger::debug "[debugger-front] no live client. Kick it out restart."
    # No live client. Kill it, and start again the normal process with timeout and message
    kill %%
    cc::debugger::start "$ex"
  }
}

# XXX this is largely broken
cc::debugger::live(){
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  while true; do
    lasttry="$(date +%s)"
    printf "%s" "$lasttry" > "$CC_TMPFS/.codecomet/lasttry"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-live] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Break if we have been hanging out more than a second (meaning the other end did connect, but exit in error)
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-live] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
    }
    x=$(( x + 1 ))
    cc::logger::debug "[debugger-live] sleeping"
    sleep 1
  done
}

cc::debugger::start(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  # Prep-up profile
  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  cc::logger::error "Abnormal exit code $ex. If you want to inspect manually, start codecomet-debugger. Otherwise, we will exit after $CC_DEBUGGER_GRACE seconds"
  cc::logger::error "You can also restart the build with CODECOMET_DEBUG=true"

  >&2 _cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "waiting" printf "Waiting %s seconds for debugger to connect" "$CC_DEBUGGER_GRACE"
  # cc::logger::warning "Waiting "


  # https://medium.com/@JAlblas/tryhackme-what-the-shell-walkthrough-6c0ebe8f854e
  #pty, allocates a pseudoterminal on the target ‚Äî part of the stabilisation process
  #stderr, makes sure that any error messages get shown in the shell (often a problem with non-interactive shells)
  #sigint, passes any Ctrl + C commands through into the sub-process, allowing us to kill commands inside the shell
  #setsid, creates the process in a new session
  #sane, stabilises the terminal, attempting to ‚Äúnormalise‚Äù it.

  while [ "$x" -lt "$CC_DEBUGGER_GRACE" ]; do
    lasttry="$(date +%s)"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-stat] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Timeing out means we wait for a second. Any more than that should mean the connection was succesful
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-stat] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
      >&2 printf "."
    }
    x=$(( x + 1 ))
    sleep 1
  done
}

ccdebug_stdout(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stdout.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stdout.log
  fi
}

ccdebug_stderr(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stderr.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stderr.log
  fi
}

ccdebug_stdex(){
  [ -e "$CC_TMPFS"/.codecomet/logs/ex.log ] && {
    cat "$CC_TMPFS"/.codecomet/logs/ex.log
  } || {
    cc::logger::warning "Action is in progress, no exit code yet"
  }
}

ccdebug_action(){
  echo "$_CC_PV_SCRIPT"
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# List all environment variables we depend on, possibly providing defaults
########################################################################################################################

#############
# Generic controls
#############
# Log level to start with (error, warning, info, debug or 4, 3, 2, 1, 0 <- mute)
readonly CC_LOG_LEVEL="${CC_LOG_LEVEL:-}"
# Where is the tempfs mounted
readonly CC_TMPFS="${CC_TMPFS:-}"
# Honors NO_COLOR (see https://no-color.org/)
# shellcheck disable=SC2034
readonly CC_CAP_NO_COLOR="${NO_COLOR:-}"
# About detection
# https://stackoverflow.com/questions/911168/how-can-i-detect-if-my-shell-script-is-running-through-a-pipe
# Could also test for [ ! -t 2 ]
# Or could be: `test -t 0` (formerly `tty -s`)
# In our context though, this probably does not matter much
# shellcheck disable=SC2034
readonly CC_CAP_HAS_TERM="${TERM:-}"

#############
# Action execution flow control
#############
# Whether the action can fail or not
readonly CC_ACTION_CAN_FAIL="${CC_ACTION_CAN_FAIL:-}"

#############
# Tracing and debugging
#############
# Controls wether the tracer will also trace internal codecomet library or hide them
readonly CC_TRACER_CODECOMET_INTERNALS="${CC_TRACER_CODECOMET_INTERNALS:-}"
# How long to wait for a connection before dropping the debugger
export CC_DEBUGGER_GRACE="${CC_DEBUGGER_GRACE:-}"
# Port to connect to
readonly CC_DEBUGGER_PORT="${CC_DEBUGGER_PORT:-}"
# IP to connect to
readonly CC_DEBUGGER_IP="${CC_DEBUGGER_IP:-}"
# Whether a debugger should be started pre-emptively so that one can hook in "live" during the action. This is very wonky as soon as you have parallelism...
readonly CC_DEBUGGER_LIVE="${CC_DEBUGGER_LIVE:-}"


#############
# Error code used accross the codebase - rn, only the bland FAILED is used...
#############
# shellcheck disable=SC2034
readonly ERROR_NETWORK=200
# Thrown if a required argument is missing
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_MISSING=201
# Thrown if an argument does not match validation
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_INVALID=202
# Should be used to convey that a certain operation is not supported
# shellcheck disable=SC2034
readonly ERROR_UNSUPPORTED=203
# Generic error to denote that the operation has failed. More specific errors may be provided instead
# shellcheck disable=SC2034
readonly ERROR_FAILED=204
# Expectations failed on a file (not readable, writable, doesn't exist, can't be created)
# shellcheck disable=SC2034
readonly ERROR_FILESYSTEM=205
# System requirements
# shellcheck disable=SC2034
readonly ERROR_MISSING_REQUIREMENTS=206

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# A generic logger
#
# Depends on:
# console.sh
########################################################################################################################

readonly CC_LOGGER_DEBUG=4
readonly CC_LOGGER_INFO=3
readonly CC_LOGGER_WARNING=2
readonly CC_LOGGER_ERROR=1

_CC_PV_LOGGER_LEVEL="$CC_LOGGER_WARNING"

_cc_private::logger::log(){
  local prefix="$1"
  shift

  local level="CC_LOGGER_$prefix"
  local i

  [ "$_CC_PV_LOGGER_LEVEL" -ge "${!level}" ] || return 0

  # About the crazy shit: https://stackoverflow.com/questions/12674783/bash-double-process-substitution-gives-bad-file-descriptor
  exec 3>&2
  for i in "$@"; do
    >&2 cc::console::"$(printf "$prefix" | tr '[:upper:]' '[:lower:]')" printf "$i"
  done
  exec 3>&-
}

cc::logger::level::set() {
  local level
  level="$(printf "%s" "${1:-}" | tr '[:upper:]' '[:lower:]')"

  case "$level" in
    ''|*[!0-9]*)
      case "$level" in
          "debug")
            _CC_PV_LOGGER_LEVEL=4
            ;;
          "info")
            _CC_PV_LOGGER_LEVEL=3
            ;;
          "warning")
            _CC_PV_LOGGER_LEVEL=2
            ;;
          "error")
            _CC_PV_LOGGER_LEVEL=1
            ;;
          "mute")
            _CC_PV_LOGGER_LEVEL=0
            ;;
          *)
            _CC_PV_LOGGER_LEVEL=3
            ;;
      esac
      ;;
    *)
      if [ "$level" -gt "$CC_LOGGER_DEBUG" ]; then
        return "$ERROR_FAILED"
      fi
      _CC_PV_LOGGER_LEVEL="$level"
      ;;
  esac

  [ "$_CC_PV_LOGGER_LEVEL" != "$CC_LOGGER_DEBUG" ] || {
    cc::console::warning printf "YOU ARE LOGGING AT THE DEBUG LEVEL."
    cc::console::warning printf "This is NOT recommended for production use, and WILL LIKELY LEAK sensitive information to logs."
  }
}

# Sugar
cc::logger::level::set::debug(){
  cc::logger::level::set "$CC_LOGGER_DEBUG"
}

cc::logger::level::set::info(){
  cc::logger::level::set "$CC_LOGGER_INFO"
}

cc::logger::level::set::warning(){
  cc::logger::level::set "$CC_LOGGER_WARNING"
}

cc::logger::level::set::error(){
  cc::logger::level::set "$CC_LOGGER_ERROR"
}

cc::logger::mute() {
  _CC_PV_LOGGER_LEVEL=0
}

cc::logger::ismute() {
  [ "$_CC_PV_LOGGER_LEVEL" == 0 ] || return "$ERROR_FAILED"
}

cc::logger::debug(){
  _cc_private::logger::log "DEBUG" "$@"
}

cc::logger::info(){
  _cc_private::logger::log "INFO" "$@"
}

cc::logger::warning(){
  _cc_private::logger::log "WARNING" "$@"
}

cc::logger::error(){
  _cc_private::logger::log "ERROR" "$@"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provides fancy display for `set -x`
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
########################################################################################################################

cc::codecomet::tracer(){
  local length="${#BASH_SOURCE[@]}"

  #local indent=""
  local linenumber
  local filename
  local filecontent
  local funcname
  local col

  [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[1]}" == *"action.sh" ]] || return 0

  printf "\n"

  for (( j=$(( length - 1 )); j>0; j-- )); do
    [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[$j]}" == *"action.sh" ]] || {
      continue
    }

    linenumber="${BASH_LINENO[$(( j - 1 ))]}"
    filename="${BASH_SOURCE[$j]}"
    filecontent="$(cat -n "$filename" | grep -E "^\s+$linenumber\s" | sed -E "s/^\s+$linenumber\s+//")"
    funcname="${FUNCNAME[$j]}"

    # Why is this showing is a mystery for the times
    # [ "$filecontent" != "#!/usr/bin/env bash" ] || continue

    [ "$j" != 1 ] && {
      col="$CC_COLOR_DEFAULT_FRONT"
    } || {
      col="$CC_COLOR_TRACER_HUMPF"
    }

    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$filename"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$linenumber"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "function" printf "%-30s" "$funcname()"
    printf "\n"
    [ "$j" != 1 ] || {
      _cc_private::console "$CC_COLOR_TRACER_COMMAND_LABEL" "$CC_COLOR_DEFAULT_FRONT" "command" printf "%s" "$filecontent"
      _cc_private::console "$CC_COLOR_TRACER_OUTPUT_LABEL" "$CC_COLOR_DEFAULT_FRONT" "output" printf ""
    }

  done
}

cc::tracer::register(){
  # shellcheck disable=SC2016
  local ps=('$(' "$@" ')')
  export PS4="${ps[*]}"
}

cc::init::tracer(){
  cc::tracer::register cc::codecomet::tracer
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Trap management
#
# Depends on:
# colors.sh
# console.sh
########################################################################################################################

_CC_PV_TRAP_LISTENERS=()

_CC_PV_ERR_LNO=
_CC_PV_ERR_CMD=
_CC_PV_ERR_STACK=
_CC_PV_ERR_EX=

dc::trap::register(){
  _CC_PV_TRAP_LISTENERS+=( "$1" )
}

# Trap lno and cmd on ERR for future use
cc::trap::err(){
  _CC_PV_ERR_EX="$1"
  _CC_PV_ERR_LNO="$2"
  _CC_PV_ERR_CMD="$3"
  _CC_PV_ERR_STACK="$4"
  # Dropping the rest of the stack?

  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$_CC_PV_ERR_STACK"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$_CC_PV_ERR_LNO"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "exit" printf "%s" "$_CC_PV_ERR_EX"
  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "command" printf "%-30s" "$_CC_PV_ERR_CMD"
  >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  >&2 printf "\n"

  >&2 _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "source" printf ""
  prefix=" "
  for (( j=$(( _CC_PV_ERR_LNO - 3 )); j<$(( _CC_PV_ERR_LNO + 3 )); j++ )); do
    [ "$j" -gt 0 ] || continue
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=">"
      >&2 _cc_private::tput setaf "$CC_COLOR_ERROR_FRONT"
      #>&2 _cc_private::tput bold
    fi
    #  | sed -E "s/^\s+$j\s//"
    >&2 printf "%s%s" "$prefix" "$(cat -n "$_CC_PV_ERR_STACK" | grep -E "^\s+$j\s")" || true
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=" "
      >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
      #>&2 _cc_private::tput sgr0
    fi
    >&2 printf "\n"
  done
}

_CC_PV_NO_REENTRY=

# Trap exit for the actual cleanup
cc::trap::exit() {
  # { set +x; } 2>/dev/null

  local ex="$1"
  local i

  # Prevent reentrancy - XXX is this actually needed?
  [ ! "$_CC_PV_NO_REENTRY" ] || return 0
  _CC_PV_NO_REENTRY="exiting"

  printf "%s\n" "$ex" > "$CC_TMPFS"/.codecomet/logs/ex.log

  if [ "${#_CC_PV_TRAP_LISTENERS[@]}" -gt 0 ]; then
    for i in "${_CC_PV_TRAP_LISTENERS[@]}"; do
      cc::logger::debug "Calling exit hook $i"
#      >&2 printf "\n"
      "$i" "$ex" "$_CC_PV_ERR_CMD" "$_CC_PV_ERR_LNO" "$_CC_PV_ERR_STACK"
    done
  fi
  >&2 cc::console::reset
  >&2 printf "\n"
  cc::logger::debug "Exiting ($ex)"
  [ "$CC_ACTION_CAN_FAIL" == "true" ] && {
    [ "$ex" != "" ] || cc::logger::error "Action failed, but it is marked as 'can fail', so, exiting successfully"
    exit 0
  } || exit "$ex"
}

# Forking to disable xtrace when entering traps
cc::init::trap(){
  # Signals are caught by buildkit already - and only SIGKILL triggers a failure
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::err "$ex" "$LINENO" "$BASH_COMMAND" "${BASH_SOURCE[@]}"' ERR
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::exit "$ex"' EXIT
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# See https://manpages.ubuntu.com/manpages/xenial/man1/eatmydata.1.html
# Technically, we get a 10% speedup with apt operations for eg
# XXX careful here if this is going to be used in a chroot
cc::init::speedup(){
  ! command -v eatmydata >/dev/null || export LD_PRELOAD=libeatmydata.so
}

# Boot if we have an argument - otherwise, we are being sourced
if [ "$#" -gt 0 ]; then
  mkdir -p "$TMPDIR"
  rm -Rf "$CC_TMPFS"/.codecomet
  mkdir -p "$CC_TMPFS"/.codecomet/bin
  mkdir -p "$CC_TMPFS"/.codecomet/logs

  # Set logger to env var from the Bash helper
  cc::logger::level::set "$CC_LOG_LEVEL"

  # Eat data, trap, register tracer, register debugger on exit trap
  cc::init::speedup
  cc::init::trap
  cc::init::tracer
  # Live debugger is really wonky
  if [ "${CC_DEBUGGER_LIVE:-}" != "" ]; then
    cc::debugger::live &
    dc::trap::register cc::debugger::front
  else
    [ "$CC_ACTION_CAN_FAIL" == true ] || dc::trap::register cc::debugger::start
  fi

  # XXX technically, we receive a bunch of scripts, and we could just play them all - use case is not completely clear yet
  out="$CC_TMPFS"/.codecomet/logs/stdout.log
  err="$CC_TMPFS"/.codecomet/logs/stderr.log

  # Unpack libraries path and source them
  while [ "$#" -gt 1 ]; do
    cp "$1" "$CC_TMPFS"/.codecomet/bin
    # shellcheck disable=SC1090
    source "$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
    shift
  done
  cp "$1" "$CC_TMPFS"/.codecomet/bin
  _CC_PV_SCRIPT="$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
  export _CC_PV_SCRIPT

  # Run the actual action
  # shellcheck disable=SC1090
  source "$_CC_PV_SCRIPT" > >(tee -a "$out") 2> >(tee -a "$err" >&2)
else
  # If we are a library, toss this one so we do not exit on any error...
  # This is especially important for the reverse debugger
  set +o errexit
fi
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
â"Ûˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*◊
/library0.sh¿∏#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# A generic lock mechanism that supports exclusive locks, shared locks, and a simplistic queueing mechanism
_cc_lockindex=9
_cc_lock_location="/_cc/share/locks"

# Sets our locks location. Must be called to guarantee that the lock location exist.
cc::lock::init(){
	_cc_lock_location="${1:-.}"
	mkdir -p "${_cc_lock_location}"
}

# Acquire a lock with a given name, and a share mode (shared or exclusive (which is the default))
# If the lock is already acquired in a different mode, or the mode is exclusive, the function will wait until the lock is released.
# Return the lock id that you need to carry around to release the lock later on.
cc::lock::acquire(){
	local lockfile="$_cc_lock_location/$1"
	local shared="${2:-}"
	[ "$shared" ] && shared=-s || shared=-x
	_cc_lockindex=$((_cc_lockindex+1))
	mkdir -p "$(dirname "$lockfile")"
	exec {_cc_lockindex}>"$lockfile"
	flock $shared $_cc_lockindex
	return $_cc_lockindex
}

# Release a previously acquire lock by its id
cc::lock::release(){
	local idx="$1"
	# This is essentially the same
	flock -u "$idx"
	# exec {idx}>&-
}

cc::lock::queue(){
	local basepath="${1:-.}"
	local shared1="${2:-}"
	local shared2="${3:-}"
	local qid
	local oid

	# Get into the queue first
	cc::lock::acquire "$basepath"/cc_queue.lock "$shared1" || qid=$?

	# Then when out of the queue, acquire an operation lock
	cc::lock::acquire "$basepath"/cc_op.lock "$shared2" || oid=$?

	# Now, leave the queue
	cc::lock::release $qid

	# Return the lock id
	return $oid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
˙"‰·ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*»
/library1.sh¿©#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Lessons learned:
# - find -exec is VERY SLOW - better off piping to read (almost 10x) (0.2 second vs 0.02 second for about 200 files)
# - then globbing and grepping is faster than find + read
# This matters not in case we are copying a large amount of data of course, but then
# - there is no way to get something stable out of ls without further processing - directories with different owners
# for eg will widen some columns
# this "works" right now (if we do not use --numeric-uid-gid) but will be problematic outside of this specific case

_cc::fingerprint(){
  local directory="$1"
  # Will fail if the directory is empty, so the guardrail
  # Ignore directories, links, and "total" (note: -d will not work for that)
  # --numeric-uid-gid < messes up the output width
  # shellcheck disable=SC2010
  ls --full-time --almost-all --ignore lock "$directory" 2>/dev/null | grep -v "^[d|l|t]" || true
}

# Copy or symlink data "from" storage "to" destination
# This assume that storage holds only files, and no lock
# Will not copy anything if there is no difference
cc::storage::retrieve(){
  local from="$1"
  local to="$2"
  local copy="${3:-}"
  local lid
  local fromState

  # Ensure destination exists
  mkdir -p "$to"

  # Lock origin and keep the lock id
  cc::lock::acquire "$from" shared || lid=$?

  # Ensure origin exists
  mkdir -p "$from"

  # If we are asked to copy (not expected for large amount of data - linking is prefered in that case)
  if [ "$copy" ]; then
    # Retrieve the state of it
    fromState="$(_cc::fingerprint "$from")"

    # Check that we have content in storage
    # Check that we have a difference between storage and destination (ignoring directories and lock file)
    # shellcheck disable=SC2010
    # shellcheck disable=SC2015
    [ "$fromState" ] && [ "$fromState" != "$(_cc::fingerprint "$to")" ] && {
      # Then cleanup destination
      rm -Rf "$to"
      mkdir -p "$to"
      # And copy over
      cp -p "$from"/* "$to"
      # Slower
      #find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
      #  cp -p "$fd" "$to"
      #done
    } || {
      # Otherwise, do nothing
      cc::logger::debug "Nothing to retrieve from storage"
    }
  else
    # We want links, so, lets check we have anything in the origin
    #[ ! "$fromState" ] || {
    # Get rid of possibly remaining files in our destination
    find "$to" -type f -delete
    ln -sf "$from"/* "$to" 2>/dev/null || true
    # Note: below is slower
    # find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
    #  ln -s "$fd" "$to"
    # done
    #}
  fi

  # Release the lock
	cc::lock::release $lid
}

cc::storage::store(){
  local from="$1"
  local to="$2"
  local erase="${3:-}"
  local lid
  local fd
  local toState

  # Ensure origin exists
  mkdir -p "$from"

  # Lock destination and keep the lock id
  cc::lock::acquire "$to" "" || lid=$?

  # Ensure destination exists
  mkdir -p "$to"
  # Retrieve the state of it
  # shellcheck disable=SC2010
  toState="$(_cc::fingerprint "$to")"

  # Compare state of the destination with the origin (origin ignores directories and lock files)
  # shellcheck disable=SC2010
  # shellcheck disable=SC2015
  [ "$toState" != "$(_cc::fingerprint "$from")" ] && {
    # We have changes - if asked to wipe out, do so
    if [ "$erase" ]; then
      rm -Rf "$to"
      mkdir -p "$to"
    fi
    # Now copy the files
    # This is probably slow-ish. The question is: will it be significant in a context where copy IO is the bottleneck?
    find "$from" -type f -not -iname "lock" -print0 | while IFS= read -r -d $'\0' fd; do
      cp -p "$fd" "$to"
    done
  } || {
    cc::logger::debug "Nothing to save to storage"
  }

  # Release the lock
	cc::lock::release $lid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
Ï*"÷*”*ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∫*
/library2.sh¿õ*#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Helpers to allow apt to share cache properly

# Private tmpfs location
_cc_tmpfs_location=/codecomet/apt-get-private/tmp

# Location of the list cache
_cc_apt_list_store_location=/codecomet/apt-get-shared/lists
# And pack cache
_cc_apt_pack_local_location=/codecomet/apt-get-shared/packs

# Location of the packages cache
_cc_apt_pack_store_location=/codecomet/apt-get-shared/cache

# Location of our private lists files - by default, Debian normal location, which means state will persist
_cc_apt_list_local_location=/var/lib/apt/lists

# Location of the config file
export APT_CONFIG=$_cc_tmpfs_location/apt-get.conf

# Hash of the sources.list, which dictates the cache location to share
# Different sources means different cache location
# Caveats: this will likely not work with a future debian release as they change the sources.list format
# XXX this wracking the debugger output
cc::apt_get::shard(){
  sha256sum <<< "$(uname -m)$(grep --no-filename -Ev "^#" /etc/apt/sources.list /etc/apt/sources.list.d/* 2>/dev/null | sed -E 's/#.+$//' | sort || true)" | sed -E 's/  .*//'
}

# Set the tmp location, initiliaze APT_CONFIG and shared and private locations
cc::apt_get::init(){
  # Get the desired tmpfs mount point
  _cc_tmpfs_location="$1"

  mkdir -p "$_cc_tmpfs_location"

  # Point configuration there
  export APT_CONFIG="$_cc_tmpfs_location"/apt-get.conf

  # Sharding by sources list content, cleaned-up and sorted to maximize cache hits
	_cc_apt_list_store_location="$2/$(cc::apt_get::shard)"

  # Technically, we should not be sharding the architecture
  # But then, the only upside would be when installing cross-arch packages
	_cc_apt_pack_store_location="$3/$(cc::apt_get::shard)"

  # If we do not want lists to persist, use the tmp storage
  [ "${4:-}" == true ] || _cc_apt_list_local_location="$_cc_tmpfs_location"/lists

  # Finally, local pack location
  _cc_apt_pack_local_location="$_cc_tmpfs_location"/packs

  # Make sure they all exist
  mkdir -p "$_cc_apt_list_local_location"
  mkdir -p "$_cc_apt_pack_local_location"

  mkdir -p "$_cc_apt_list_store_location"
  mkdir -p "$_cc_apt_pack_store_location"
}

# Create the configuration file for APT
cc::apt_get::configure(){
  local config_extra="${1:-}"
  local persist="${2:-}"

  mkdir -p "$_cc_tmpfs_location/logs"
  cat << EOF > "$APT_CONFIG"
# Divert both lists and archives location
Dir::Cache::Archives "$_cc_apt_pack_local_location";
Dir::State::Lists "$_cc_apt_list_local_location";
# Prevent the default apt config to be used
Dir::Etc::parts "";
# Put the logs in the tmp zone
Dir::Log "$_cc_tmpfs_location/logs";
# Put the bin cache files in the private mount
Dir::Cache::srcpkgcache "$_cc_tmpfs_location/srcpkgcache.bin";
Dir::Cache::pkgcache "$_cc_tmpfs_location/pkgcache.bin";

$config_extra
EOF

  # If asked to persist the config, copy over the generated file
  [ "$persist" == "false" ] || cp "$APT_CONFIG" /etc/apt/apt.conf
}

#cc::apt_get::cleanup(){
  # This is only necessary if we were not using an tmpfs mount...
  # rm "$APT_CONFIG"
#}

cc::apt_get::update(){
  # Remove our marker if here
  rm -f "$_cc_apt_list_local_location"/.cc_updated

  # Retrieve existing data
  cc::storage::retrieve "$_cc_apt_list_store_location" "$_cc_apt_list_local_location" copy

	# Do the deed, same restriction applies
	apt-get update "$@"

  # Save it back (storage will decide)
  cc::storage::store "$_cc_apt_list_local_location" "$_cc_apt_list_store_location" erase

  # Now, flag it
  date > "$_cc_apt_list_local_location"/.cc_updated
}

cc::apt_get::do(){
  # Bring in any cache
  cc::storage::retrieve "$_cc_apt_pack_store_location" "$_cc_apt_pack_local_location"

	apt-get "$@"

  # Store the packages permanently
  cc::storage::store "$_cc_apt_pack_local_location" "$_cc_apt_pack_store_location"
}

# XXX what if sources are being modified, or config, or something else that materially impacts update?
cc::high::update(){
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "$nooutput"

  args+=("$@")
  time cc::apt_get::update "${args[@]}"
}

cc::high::install(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists has been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  args+=("$@")
  time cc::apt_get::do install "${args[@]}"
}

cc::high::upgrade(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists have been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  # ls -lAR "$_cc_tmpfs_location"/packs || true
  # time cc::apt_get::do upgrade "$nooutput" "$@"

  # XXX WIP here
  # Bust cache - delete this
  #time cc::apt_get::do upgrade --download-only "$nooutput" "$@"
  #time cc::apt_get::do upgrade --no-download "$nooutput" "$@"
  args+=("$@")
  time cc::apt_get::do upgrade "${args[@]}"
}

cc::high::purge(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")

  args+=("$@")
  time cc::apt_get::do purge --auto-remove "${args[@]}"
}(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
’"øºˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*£

/action.sh¿Ü#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::upgrade

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f7942
 



Z 
•
I
Gsha256:1fbbc4badd25a127fd4fadc9695046d27c048e2401041b62bedf36d229e45f77
I
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
armlinuxv7Z 
Í"‘—ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∏

/action.sh¿õ#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::install eatmydata nano socat

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c2
 



Z 
•
I
Gsha256:55ec848cf7d65106bee358f2ac6a5bba29563bf30924f0ee03dac01e2cbbc43e
I
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
armlinuxv7Z 
K
I
Gsha256:7d56e94b3beb356751a3e6f559295c2e360361498efd4103e6dd6dc5063a8e84Ë
Gsha256:1fbbc4badd25a127fd4fadc9695046d27c048e2401041b62bedf36d229e45f77ú!
codecomet.optest codecomet opG
llb.customname5[source:image] docker.io/library/debian:bullseye-slim*
source.image*
source.image.resolvemodeü
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library2.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library1.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupπ
Gsha256:55ec848cf7d65106bee358f2ac6a5bba29563bf30924f0ee03dac01e2cbbc43eÌ!
codecomet.optest codecomet op!
llb.customnameapt-get upgrade*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeŒ
Gsha256:7d56e94b3beb356751a3e6f559295c2e360361498efd4103e6dd6dc5063a8e84Ç!
codecomet.optest codecomet op6
llb.customname$apt-get install eatmydata nano socat*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeù
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962—!
codecomet.optest codecomet op0
llb.customname[action:addfile] codecomet in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupê
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edfƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library0.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupÄ
Gsha256:d8bbf2a7da2fc3ca36bc870ec340d424817c686cb2f622f469f5329d4532732b5*
constraints*
meta.description*
platformê
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8aƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupœ
K
Gsha256:1fbbc4badd25a127fd4fadc9695046d27c048e2401041b62bedf36d229e45f77 
K
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f 
K
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7 
K
Gsha256:55ec848cf7d65106bee358f2ac6a5bba29563bf30924f0ee03dac01e2cbbc43e 
K
Gsha256:7d56e94b3beb356751a3e6f559295c2e360361498efd4103e6dd6dc5063a8e84 
K
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962 
K
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c 
K
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf 
K
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c 
K
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794 
K
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a 
fR
5docker-image://docker.io/library/debian:bullseye-slim
image.resolvemodepullR
amd64linuxZ 
æ›"ß›£›ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*â›

/codecomet¿Î‹#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Defines the supported color palette, and our color scheme
########################################################################################################################

# Supported color palette
readonly _CC_PV_COLOR_BLACK=0
readonly _CC_PV_COLOR_RED=1
readonly _CC_PV_COLOR_GREEN=2
readonly _CC_PV_COLOR_YELLOW=3
# shellcheck disable=SC2034
readonly _CC_PV_COLOR_BLUE=4
readonly _CC_PV_COLOR_MAGENTA=5
readonly _CC_PV_COLOR_CYAN=6
readonly _CC_PV_COLOR_WHITE=7

# Colors scheme definition - can evidently be customized at runtime by setting these variables to other values from the palette
export CC_COLOR_DEFAULT_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEFAULT_BACK="$_CC_PV_COLOR_BLACK"

export CC_COLOR_BODY="$_CC_PV_COLOR_WHITE"
export CC_COLOR_COMMENT="$_CC_PV_COLOR_CYAN"
export CC_COLOR_HUMPF="$_CC_PV_COLOR_MAGENTA"

# Logger
export CC_COLOR_ERROR_FRONT="$_CC_PV_COLOR_RED"
export CC_COLOR_ERROR_BACK="$_CC_PV_COLOR_WHITE"
export CC_COLOR_WARNING_FRONT="$_CC_PV_COLOR_YELLOW"
export CC_COLOR_WARNING_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_INFO_FRONT="$_CC_PV_COLOR_GREEN"
export CC_COLOR_INFO_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_DEBUG_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEBUG_BACK="$_CC_PV_COLOR_BLACK"

# Tracer
export CC_COLOR_TRACER_HUMPF="$_CC_PV_COLOR_GREEN"
export CC_COLOR_TRACER_COMMAND_LABEL="$_CC_PV_COLOR_BLUE"
export CC_COLOR_TRACER_OUTPUT_LABEL="$_CC_PV_COLOR_RED"
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provide helpers to print colorful text
#
# Depends on:
# defaults.sh
# colors.sh
########################################################################################################################

_cc_private::tput(){
  [ ! "$CC_CAP_HAS_TERM" ] || [ "$CC_CAP_NO_COLOR" != "" ] || tput "$@" 2>/dev/null || true
}

_cc_private::console::inline(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it and pad to 7 chars, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"
}

_cc_private::console(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-7s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    # Otherwise, just a plain front/back
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"

  # Restore console to default before we \n so that we do not leak over into BK timestamp display
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::error(){
  _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_ERROR_BACK" "error" "$@"
}

cc::console::warning(){
  _cc_private::console "$CC_COLOR_WARNING_FRONT" "$CC_COLOR_WARNING_BACK" "warning" "$@"
}

cc::console::info(){
  _cc_private::console "$CC_COLOR_INFO_FRONT" "$CC_COLOR_INFO_BACK" "info" "$@"
}

cc::console::debug(){
  _cc_private::console "$CC_COLOR_DEBUG_FRONT" "$CC_COLOR_DEBUG_BACK" "debug" "$@"
}

cc::console::body(){
  _cc_private::console "$CC_COLOR_BODY" "" "" "$@"
}

cc::console::comment(){
  _cc_private::console "$CC_COLOR_COMMENT" "" "" "$@"
}

cc::console::humpf(){
  _cc_private::console "$CC_COLOR_HUMPF" "" "" "$@"
}

cc::console::reset(){
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::end(){
  _cc_private::tput op
  printf "\n"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Debugger based on socat
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
# logger.sh
########################################################################################################################

# Fancy prompt adapted from https://github.com/pombadev/fancy-linux-prompt/blob/master/LICENSE under MIT License
__powerline() {
    # Unicode symbols
    readonly GIT_NEED_PULL_SYMBOL='‚á£'
    readonly GIT_NEED_PUSH_SYMBOL='‚á°'
    readonly PS_SYMBOL='ü™ê' # üêß‚òÑ'‚ñ∂‚èµ‚ñ∂‚èµ

    # Solarized colorscheme
    readonly BG_BLUE="\\[$(tput setab 4)\\]"
    readonly BG_COLOR5="\\[\\e[48;5;31m\\]"
    readonly BG_COLOR8="\\[\\e[48;5;161m\\]"
    readonly BG_GREEN="\\[$(tput setab 2)\\]"
    readonly BG_RED="\\[$(tput setab 1)\\]"
    readonly FG_BASE3="\\[$(tput setaf 15)\\]"
    readonly FG_BLUE="\\[$(tput setaf 4)\\]"
    readonly FG_COLOR1="\\[\\e[38;5;250m\\]"
    readonly FG_COLOR6="\\[\\e[38;5;31m\\]"
    readonly FG_COLOR9="\\[\\e[38;5;161m\\]"
    readonly FG_GREEN="\\[$(tput setaf 2)\\]"
    readonly FG_RED="\\[$(tput setaf 1)\\]"
    readonly RESET="\\[$(tput sgr0)\\]"

    __git_info() {
        # has a .git directory and a git binary
    	[ -d .git ] || command -v git >/dev/null || return 0

        local aheadN
        local behindN
        local branch
        local marks=""
        local stats

        # get current branch name or short SHA1 hash for detached head
        branch="$(git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --always 2>/dev/null)"
        [ -n "$branch" ] || return 0 # git branch not found

        # how many commits local branch is ahead/behind of remote?
        stats="$(git status --porcelain --branch | grep '^##' | grep -o '\[.\+\]$')"
        aheadN="$(echo "$stats" | grep -o 'ahead \d\+' | grep -o '\d\+')"
        behindN="$(echo "$stats" | grep -o 'behind \d\+' | grep -o '\d\+')"
        [ -n "$aheadN" ] && marks+=" $GIT_NEED_PUSH_SYMBOL$aheadN"
        [ -n "$behindN" ] && marks+=" $GIT_NEED_PULL_SYMBOL$behindN"

        # print the git branch segment without a trailing newline
        # branch is modified?
        if [ -n "$(git status --porcelain)" ]; then
            printf "%s" "${BG_COLOR8}‚ñ∂$RESET$BG_COLOR8 $branch$marks $FG_COLOR9"
        else
            printf "%s" "${BG_BLUE}‚ñ∂$RESET$BG_BLUE $branch$marks $RESET$FG_BLUE"
        fi
    }


    ps1() {
        # Check the exit code of the previous command and display different
        # colors in the prompt accordingly.
        if [ "$?" -eq 0 ]; then
            local BG_EXIT="$BG_GREEN"
            local FG_EXIT="$FG_GREEN"
        else
            local BG_EXIT="$BG_RED"
            local FG_EXIT="$FG_RED"
        fi

        PS1="$FG_COLOR1$BG_COLOR5 CodeComet \\w "
        PS1+="$RESET${FG_COLOR6}"
        PS1+="$(__git_info)"
        PS1+="$BG_EXIT‚ñ∂$RESET"
        PS1+="$BG_EXIT$FG_BASE3 ${PS_SYMBOL} ${RESET}${FG_EXIT}‚ñ∂${RESET} "
    }

    PROMPT_COMMAND=ps1
}

_cc_private::debugger::setup(){
  # Set-up PS1
  cat << EOF > "$CC_TMPFS"/.profile
# export PS1='\[\033[01;32m\]CodeComet\[\033[00m\] \w \$ '
alias l="ls -lA"
source ${BASH_SOURCE[0]}
umask 077
export LSCOLORS=exfxcxdxbxegedabagacad
export CLICOLOR=1

_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Welcome!" printf "You are now debugging your pipeline at the point it stopped.\n"
printf "\n"
#_cc_private::console::inline "$_CC_PV_COLOR_BLACK" "$_CC_PV_COLOR_BLACK" "         " printf ""
printf "Environment, pwd, and filesystem, are exactly as they were when the last action failed.\n"
printf "You can call the following helpers:\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdout" printf "will output your action stdout\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stderr" printf "will output your action stderr\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdex " printf "will output your action exit code\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_action" printf "will output the location of your action script\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Tip           " printf "If you want to re-run your action, just call \\\$(ccdebug_action)\n"

# touch "$CC_TMPFS/.codecomet/connected"
__powerline

EOF

  cat << EOF >> "$CC_TMPFS"/.inputrc
"\e[A": history-search-backward
"\e[B": history-search-forward
set show-all-if-ambiguous on
set completion-ignore-case on

EOF

}

# "on demand
# "Abnormal exit, with non zero grace:
# - start debugger repeatedly, with grace
# - once the other end exits, bail out

# "live", with non zero grace
# - start debugger, with infinity grace
# - if the other end was connected and exited, that is it, end of story
# - if the other end is still running, bring socat forward and wait for the end to exit
# - if there was no other end, we should branch back to the first scenario

# This is called on trap ERR, if a live debugger has been running, and will make a decision to bring it back forward and keep it alive,
# or to drop it
cc::debugger::front(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  cc::logger::debug "[debugger-front] socat is here"
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  cc::logger::debug "[debugger-front] grace is fine"


  # Debugger still live? Bail out if not
  jobs | grep -q -v Done || {
    cc::logger::debug "[debugger-front] no jobs detected. Bailing out."
    return 0
  }

  # Ok, it is live. Do we have a client?
  # XXX unfortunately, this does not work as expected... socat does start the process first, bash sources the files and create the stamp file...
  local lasttry
  local current
  lasttry="$(cat $CC_TMPFS/.codecomet/lasttry 2>/dev/null)" || true
  current="$(date +%s)"
  # The older an unconnected socat could be is 2 seconds - if greater than that, then we definitely have a client
  # However, it is possible that a client has been connected for less than 2 seconds (since socat call) when the failure happens,
  # which means the client will wrongly get the boot... no good solution right now
  [ $(( current - lasttry)) -gt 2 ] && {
  # [ -e "$CC_TMPFS/.codecomet/connected" ] && {
    cc::logger::debug "[debugger-front] we have a connected client"
    # Yes, then foreground and let it sit
    fg 2>/dev/null
  } || {
    cc::logger::debug "[debugger-front] no live client. Kick it out restart."
    # No live client. Kill it, and start again the normal process with timeout and message
    kill %%
    cc::debugger::start "$ex"
  }
}

# XXX this is largely broken
cc::debugger::live(){
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  while true; do
    lasttry="$(date +%s)"
    printf "%s" "$lasttry" > "$CC_TMPFS/.codecomet/lasttry"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-live] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Break if we have been hanging out more than a second (meaning the other end did connect, but exit in error)
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-live] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
    }
    x=$(( x + 1 ))
    cc::logger::debug "[debugger-live] sleeping"
    sleep 1
  done
}

cc::debugger::start(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  # Prep-up profile
  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  cc::logger::error "Abnormal exit code $ex. If you want to inspect manually, start codecomet-debugger. Otherwise, we will exit after $CC_DEBUGGER_GRACE seconds"
  cc::logger::error "You can also restart the build with CODECOMET_DEBUG=true"

  >&2 _cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "waiting" printf "Waiting %s seconds for debugger to connect" "$CC_DEBUGGER_GRACE"
  # cc::logger::warning "Waiting "


  # https://medium.com/@JAlblas/tryhackme-what-the-shell-walkthrough-6c0ebe8f854e
  #pty, allocates a pseudoterminal on the target ‚Äî part of the stabilisation process
  #stderr, makes sure that any error messages get shown in the shell (often a problem with non-interactive shells)
  #sigint, passes any Ctrl + C commands through into the sub-process, allowing us to kill commands inside the shell
  #setsid, creates the process in a new session
  #sane, stabilises the terminal, attempting to ‚Äúnormalise‚Äù it.

  while [ "$x" -lt "$CC_DEBUGGER_GRACE" ]; do
    lasttry="$(date +%s)"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-stat] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Timeing out means we wait for a second. Any more than that should mean the connection was succesful
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-stat] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
      >&2 printf "."
    }
    x=$(( x + 1 ))
    sleep 1
  done
}

ccdebug_stdout(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stdout.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stdout.log
  fi
}

ccdebug_stderr(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stderr.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stderr.log
  fi
}

ccdebug_stdex(){
  [ -e "$CC_TMPFS"/.codecomet/logs/ex.log ] && {
    cat "$CC_TMPFS"/.codecomet/logs/ex.log
  } || {
    cc::logger::warning "Action is in progress, no exit code yet"
  }
}

ccdebug_action(){
  echo "$_CC_PV_SCRIPT"
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# List all environment variables we depend on, possibly providing defaults
########################################################################################################################

#############
# Generic controls
#############
# Log level to start with (error, warning, info, debug or 4, 3, 2, 1, 0 <- mute)
readonly CC_LOG_LEVEL="${CC_LOG_LEVEL:-}"
# Where is the tempfs mounted
readonly CC_TMPFS="${CC_TMPFS:-}"
# Honors NO_COLOR (see https://no-color.org/)
# shellcheck disable=SC2034
readonly CC_CAP_NO_COLOR="${NO_COLOR:-}"
# About detection
# https://stackoverflow.com/questions/911168/how-can-i-detect-if-my-shell-script-is-running-through-a-pipe
# Could also test for [ ! -t 2 ]
# Or could be: `test -t 0` (formerly `tty -s`)
# In our context though, this probably does not matter much
# shellcheck disable=SC2034
readonly CC_CAP_HAS_TERM="${TERM:-}"

#############
# Action execution flow control
#############
# Whether the action can fail or not
readonly CC_ACTION_CAN_FAIL="${CC_ACTION_CAN_FAIL:-}"

#############
# Tracing and debugging
#############
# Controls wether the tracer will also trace internal codecomet library or hide them
readonly CC_TRACER_CODECOMET_INTERNALS="${CC_TRACER_CODECOMET_INTERNALS:-}"
# How long to wait for a connection before dropping the debugger
export CC_DEBUGGER_GRACE="${CC_DEBUGGER_GRACE:-}"
# Port to connect to
readonly CC_DEBUGGER_PORT="${CC_DEBUGGER_PORT:-}"
# IP to connect to
readonly CC_DEBUGGER_IP="${CC_DEBUGGER_IP:-}"
# Whether a debugger should be started pre-emptively so that one can hook in "live" during the action. This is very wonky as soon as you have parallelism...
readonly CC_DEBUGGER_LIVE="${CC_DEBUGGER_LIVE:-}"


#############
# Error code used accross the codebase - rn, only the bland FAILED is used...
#############
# shellcheck disable=SC2034
readonly ERROR_NETWORK=200
# Thrown if a required argument is missing
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_MISSING=201
# Thrown if an argument does not match validation
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_INVALID=202
# Should be used to convey that a certain operation is not supported
# shellcheck disable=SC2034
readonly ERROR_UNSUPPORTED=203
# Generic error to denote that the operation has failed. More specific errors may be provided instead
# shellcheck disable=SC2034
readonly ERROR_FAILED=204
# Expectations failed on a file (not readable, writable, doesn't exist, can't be created)
# shellcheck disable=SC2034
readonly ERROR_FILESYSTEM=205
# System requirements
# shellcheck disable=SC2034
readonly ERROR_MISSING_REQUIREMENTS=206

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# A generic logger
#
# Depends on:
# console.sh
########################################################################################################################

readonly CC_LOGGER_DEBUG=4
readonly CC_LOGGER_INFO=3
readonly CC_LOGGER_WARNING=2
readonly CC_LOGGER_ERROR=1

_CC_PV_LOGGER_LEVEL="$CC_LOGGER_WARNING"

_cc_private::logger::log(){
  local prefix="$1"
  shift

  local level="CC_LOGGER_$prefix"
  local i

  [ "$_CC_PV_LOGGER_LEVEL" -ge "${!level}" ] || return 0

  # About the crazy shit: https://stackoverflow.com/questions/12674783/bash-double-process-substitution-gives-bad-file-descriptor
  exec 3>&2
  for i in "$@"; do
    >&2 cc::console::"$(printf "$prefix" | tr '[:upper:]' '[:lower:]')" printf "$i"
  done
  exec 3>&-
}

cc::logger::level::set() {
  local level
  level="$(printf "%s" "${1:-}" | tr '[:upper:]' '[:lower:]')"

  case "$level" in
    ''|*[!0-9]*)
      case "$level" in
          "debug")
            _CC_PV_LOGGER_LEVEL=4
            ;;
          "info")
            _CC_PV_LOGGER_LEVEL=3
            ;;
          "warning")
            _CC_PV_LOGGER_LEVEL=2
            ;;
          "error")
            _CC_PV_LOGGER_LEVEL=1
            ;;
          "mute")
            _CC_PV_LOGGER_LEVEL=0
            ;;
          *)
            _CC_PV_LOGGER_LEVEL=3
            ;;
      esac
      ;;
    *)
      if [ "$level" -gt "$CC_LOGGER_DEBUG" ]; then
        return "$ERROR_FAILED"
      fi
      _CC_PV_LOGGER_LEVEL="$level"
      ;;
  esac

  [ "$_CC_PV_LOGGER_LEVEL" != "$CC_LOGGER_DEBUG" ] || {
    cc::console::warning printf "YOU ARE LOGGING AT THE DEBUG LEVEL."
    cc::console::warning printf "This is NOT recommended for production use, and WILL LIKELY LEAK sensitive information to logs."
  }
}

# Sugar
cc::logger::level::set::debug(){
  cc::logger::level::set "$CC_LOGGER_DEBUG"
}

cc::logger::level::set::info(){
  cc::logger::level::set "$CC_LOGGER_INFO"
}

cc::logger::level::set::warning(){
  cc::logger::level::set "$CC_LOGGER_WARNING"
}

cc::logger::level::set::error(){
  cc::logger::level::set "$CC_LOGGER_ERROR"
}

cc::logger::mute() {
  _CC_PV_LOGGER_LEVEL=0
}

cc::logger::ismute() {
  [ "$_CC_PV_LOGGER_LEVEL" == 0 ] || return "$ERROR_FAILED"
}

cc::logger::debug(){
  _cc_private::logger::log "DEBUG" "$@"
}

cc::logger::info(){
  _cc_private::logger::log "INFO" "$@"
}

cc::logger::warning(){
  _cc_private::logger::log "WARNING" "$@"
}

cc::logger::error(){
  _cc_private::logger::log "ERROR" "$@"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provides fancy display for `set -x`
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
########################################################################################################################

cc::codecomet::tracer(){
  local length="${#BASH_SOURCE[@]}"

  #local indent=""
  local linenumber
  local filename
  local filecontent
  local funcname
  local col

  [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[1]}" == *"action.sh" ]] || return 0

  printf "\n"

  for (( j=$(( length - 1 )); j>0; j-- )); do
    [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[$j]}" == *"action.sh" ]] || {
      continue
    }

    linenumber="${BASH_LINENO[$(( j - 1 ))]}"
    filename="${BASH_SOURCE[$j]}"
    filecontent="$(cat -n "$filename" | grep -E "^\s+$linenumber\s" | sed -E "s/^\s+$linenumber\s+//")"
    funcname="${FUNCNAME[$j]}"

    # Why is this showing is a mystery for the times
    # [ "$filecontent" != "#!/usr/bin/env bash" ] || continue

    [ "$j" != 1 ] && {
      col="$CC_COLOR_DEFAULT_FRONT"
    } || {
      col="$CC_COLOR_TRACER_HUMPF"
    }

    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$filename"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$linenumber"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "function" printf "%-30s" "$funcname()"
    printf "\n"
    [ "$j" != 1 ] || {
      _cc_private::console "$CC_COLOR_TRACER_COMMAND_LABEL" "$CC_COLOR_DEFAULT_FRONT" "command" printf "%s" "$filecontent"
      _cc_private::console "$CC_COLOR_TRACER_OUTPUT_LABEL" "$CC_COLOR_DEFAULT_FRONT" "output" printf ""
    }

  done
}

cc::tracer::register(){
  # shellcheck disable=SC2016
  local ps=('$(' "$@" ')')
  export PS4="${ps[*]}"
}

cc::init::tracer(){
  cc::tracer::register cc::codecomet::tracer
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Trap management
#
# Depends on:
# colors.sh
# console.sh
########################################################################################################################

_CC_PV_TRAP_LISTENERS=()

_CC_PV_ERR_LNO=
_CC_PV_ERR_CMD=
_CC_PV_ERR_STACK=
_CC_PV_ERR_EX=

dc::trap::register(){
  _CC_PV_TRAP_LISTENERS+=( "$1" )
}

# Trap lno and cmd on ERR for future use
cc::trap::err(){
  _CC_PV_ERR_EX="$1"
  _CC_PV_ERR_LNO="$2"
  _CC_PV_ERR_CMD="$3"
  _CC_PV_ERR_STACK="$4"
  # Dropping the rest of the stack?

  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$_CC_PV_ERR_STACK"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$_CC_PV_ERR_LNO"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "exit" printf "%s" "$_CC_PV_ERR_EX"
  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "command" printf "%-30s" "$_CC_PV_ERR_CMD"
  >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  >&2 printf "\n"

  >&2 _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "source" printf ""
  prefix=" "
  for (( j=$(( _CC_PV_ERR_LNO - 3 )); j<$(( _CC_PV_ERR_LNO + 3 )); j++ )); do
    [ "$j" -gt 0 ] || continue
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=">"
      >&2 _cc_private::tput setaf "$CC_COLOR_ERROR_FRONT"
      #>&2 _cc_private::tput bold
    fi
    #  | sed -E "s/^\s+$j\s//"
    >&2 printf "%s%s" "$prefix" "$(cat -n "$_CC_PV_ERR_STACK" | grep -E "^\s+$j\s")" || true
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=" "
      >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
      #>&2 _cc_private::tput sgr0
    fi
    >&2 printf "\n"
  done
}

_CC_PV_NO_REENTRY=

# Trap exit for the actual cleanup
cc::trap::exit() {
  # { set +x; } 2>/dev/null

  local ex="$1"
  local i

  # Prevent reentrancy - XXX is this actually needed?
  [ ! "$_CC_PV_NO_REENTRY" ] || return 0
  _CC_PV_NO_REENTRY="exiting"

  printf "%s\n" "$ex" > "$CC_TMPFS"/.codecomet/logs/ex.log

  if [ "${#_CC_PV_TRAP_LISTENERS[@]}" -gt 0 ]; then
    for i in "${_CC_PV_TRAP_LISTENERS[@]}"; do
      cc::logger::debug "Calling exit hook $i"
#      >&2 printf "\n"
      "$i" "$ex" "$_CC_PV_ERR_CMD" "$_CC_PV_ERR_LNO" "$_CC_PV_ERR_STACK"
    done
  fi
  >&2 cc::console::reset
  >&2 printf "\n"
  cc::logger::debug "Exiting ($ex)"
  [ "$CC_ACTION_CAN_FAIL" == "true" ] && {
    [ "$ex" != "" ] || cc::logger::error "Action failed, but it is marked as 'can fail', so, exiting successfully"
    exit 0
  } || exit "$ex"
}

# Forking to disable xtrace when entering traps
cc::init::trap(){
  # Signals are caught by buildkit already - and only SIGKILL triggers a failure
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::err "$ex" "$LINENO" "$BASH_COMMAND" "${BASH_SOURCE[@]}"' ERR
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::exit "$ex"' EXIT
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# See https://manpages.ubuntu.com/manpages/xenial/man1/eatmydata.1.html
# Technically, we get a 10% speedup with apt operations for eg
# XXX careful here if this is going to be used in a chroot
cc::init::speedup(){
  ! command -v eatmydata >/dev/null || export LD_PRELOAD=libeatmydata.so
}

# Boot if we have an argument - otherwise, we are being sourced
if [ "$#" -gt 0 ]; then
  mkdir -p "$TMPDIR"
  rm -Rf "$CC_TMPFS"/.codecomet
  mkdir -p "$CC_TMPFS"/.codecomet/bin
  mkdir -p "$CC_TMPFS"/.codecomet/logs

  # Set logger to env var from the Bash helper
  cc::logger::level::set "$CC_LOG_LEVEL"

  # Eat data, trap, register tracer, register debugger on exit trap
  cc::init::speedup
  cc::init::trap
  cc::init::tracer
  # Live debugger is really wonky
  if [ "${CC_DEBUGGER_LIVE:-}" != "" ]; then
    cc::debugger::live &
    dc::trap::register cc::debugger::front
  else
    [ "$CC_ACTION_CAN_FAIL" == true ] || dc::trap::register cc::debugger::start
  fi

  # XXX technically, we receive a bunch of scripts, and we could just play them all - use case is not completely clear yet
  out="$CC_TMPFS"/.codecomet/logs/stdout.log
  err="$CC_TMPFS"/.codecomet/logs/stderr.log

  # Unpack libraries path and source them
  while [ "$#" -gt 1 ]; do
    cp "$1" "$CC_TMPFS"/.codecomet/bin
    # shellcheck disable=SC1090
    source "$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
    shift
  done
  cp "$1" "$CC_TMPFS"/.codecomet/bin
  _CC_PV_SCRIPT="$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
  export _CC_PV_SCRIPT

  # Run the actual action
  # shellcheck disable=SC1090
  source "$_CC_PV_SCRIPT" > >(tee -a "$out") 2> >(tee -a "$err" >&2)
else
  # If we are a library, toss this one so we do not exit on any error...
  # This is especially important for the reverse debugger
  set +o errexit
fi
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
â"Ûˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*◊
/library0.sh¿∏#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# A generic lock mechanism that supports exclusive locks, shared locks, and a simplistic queueing mechanism
_cc_lockindex=9
_cc_lock_location="/_cc/share/locks"

# Sets our locks location. Must be called to guarantee that the lock location exist.
cc::lock::init(){
	_cc_lock_location="${1:-.}"
	mkdir -p "${_cc_lock_location}"
}

# Acquire a lock with a given name, and a share mode (shared or exclusive (which is the default))
# If the lock is already acquired in a different mode, or the mode is exclusive, the function will wait until the lock is released.
# Return the lock id that you need to carry around to release the lock later on.
cc::lock::acquire(){
	local lockfile="$_cc_lock_location/$1"
	local shared="${2:-}"
	[ "$shared" ] && shared=-s || shared=-x
	_cc_lockindex=$((_cc_lockindex+1))
	mkdir -p "$(dirname "$lockfile")"
	exec {_cc_lockindex}>"$lockfile"
	flock $shared $_cc_lockindex
	return $_cc_lockindex
}

# Release a previously acquire lock by its id
cc::lock::release(){
	local idx="$1"
	# This is essentially the same
	flock -u "$idx"
	# exec {idx}>&-
}

cc::lock::queue(){
	local basepath="${1:-.}"
	local shared1="${2:-}"
	local shared2="${3:-}"
	local qid
	local oid

	# Get into the queue first
	cc::lock::acquire "$basepath"/cc_queue.lock "$shared1" || qid=$?

	# Then when out of the queue, acquire an operation lock
	cc::lock::acquire "$basepath"/cc_op.lock "$shared2" || oid=$?

	# Now, leave the queue
	cc::lock::release $qid

	# Return the lock id
	return $oid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
˙"‰·ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*»
/library1.sh¿©#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Lessons learned:
# - find -exec is VERY SLOW - better off piping to read (almost 10x) (0.2 second vs 0.02 second for about 200 files)
# - then globbing and grepping is faster than find + read
# This matters not in case we are copying a large amount of data of course, but then
# - there is no way to get something stable out of ls without further processing - directories with different owners
# for eg will widen some columns
# this "works" right now (if we do not use --numeric-uid-gid) but will be problematic outside of this specific case

_cc::fingerprint(){
  local directory="$1"
  # Will fail if the directory is empty, so the guardrail
  # Ignore directories, links, and "total" (note: -d will not work for that)
  # --numeric-uid-gid < messes up the output width
  # shellcheck disable=SC2010
  ls --full-time --almost-all --ignore lock "$directory" 2>/dev/null | grep -v "^[d|l|t]" || true
}

# Copy or symlink data "from" storage "to" destination
# This assume that storage holds only files, and no lock
# Will not copy anything if there is no difference
cc::storage::retrieve(){
  local from="$1"
  local to="$2"
  local copy="${3:-}"
  local lid
  local fromState

  # Ensure destination exists
  mkdir -p "$to"

  # Lock origin and keep the lock id
  cc::lock::acquire "$from" shared || lid=$?

  # Ensure origin exists
  mkdir -p "$from"

  # If we are asked to copy (not expected for large amount of data - linking is prefered in that case)
  if [ "$copy" ]; then
    # Retrieve the state of it
    fromState="$(_cc::fingerprint "$from")"

    # Check that we have content in storage
    # Check that we have a difference between storage and destination (ignoring directories and lock file)
    # shellcheck disable=SC2010
    # shellcheck disable=SC2015
    [ "$fromState" ] && [ "$fromState" != "$(_cc::fingerprint "$to")" ] && {
      # Then cleanup destination
      rm -Rf "$to"
      mkdir -p "$to"
      # And copy over
      cp -p "$from"/* "$to"
      # Slower
      #find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
      #  cp -p "$fd" "$to"
      #done
    } || {
      # Otherwise, do nothing
      cc::logger::debug "Nothing to retrieve from storage"
    }
  else
    # We want links, so, lets check we have anything in the origin
    #[ ! "$fromState" ] || {
    # Get rid of possibly remaining files in our destination
    find "$to" -type f -delete
    ln -sf "$from"/* "$to" 2>/dev/null || true
    # Note: below is slower
    # find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
    #  ln -s "$fd" "$to"
    # done
    #}
  fi

  # Release the lock
	cc::lock::release $lid
}

cc::storage::store(){
  local from="$1"
  local to="$2"
  local erase="${3:-}"
  local lid
  local fd
  local toState

  # Ensure origin exists
  mkdir -p "$from"

  # Lock destination and keep the lock id
  cc::lock::acquire "$to" "" || lid=$?

  # Ensure destination exists
  mkdir -p "$to"
  # Retrieve the state of it
  # shellcheck disable=SC2010
  toState="$(_cc::fingerprint "$to")"

  # Compare state of the destination with the origin (origin ignores directories and lock files)
  # shellcheck disable=SC2010
  # shellcheck disable=SC2015
  [ "$toState" != "$(_cc::fingerprint "$from")" ] && {
    # We have changes - if asked to wipe out, do so
    if [ "$erase" ]; then
      rm -Rf "$to"
      mkdir -p "$to"
    fi
    # Now copy the files
    # This is probably slow-ish. The question is: will it be significant in a context where copy IO is the bottleneck?
    find "$from" -type f -not -iname "lock" -print0 | while IFS= read -r -d $'\0' fd; do
      cp -p "$fd" "$to"
    done
  } || {
    cc::logger::debug "Nothing to save to storage"
  }

  # Release the lock
	cc::lock::release $lid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
Ï*"÷*”*ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∫*
/library2.sh¿õ*#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Helpers to allow apt to share cache properly

# Private tmpfs location
_cc_tmpfs_location=/codecomet/apt-get-private/tmp

# Location of the list cache
_cc_apt_list_store_location=/codecomet/apt-get-shared/lists
# And pack cache
_cc_apt_pack_local_location=/codecomet/apt-get-shared/packs

# Location of the packages cache
_cc_apt_pack_store_location=/codecomet/apt-get-shared/cache

# Location of our private lists files - by default, Debian normal location, which means state will persist
_cc_apt_list_local_location=/var/lib/apt/lists

# Location of the config file
export APT_CONFIG=$_cc_tmpfs_location/apt-get.conf

# Hash of the sources.list, which dictates the cache location to share
# Different sources means different cache location
# Caveats: this will likely not work with a future debian release as they change the sources.list format
# XXX this wracking the debugger output
cc::apt_get::shard(){
  sha256sum <<< "$(uname -m)$(grep --no-filename -Ev "^#" /etc/apt/sources.list /etc/apt/sources.list.d/* 2>/dev/null | sed -E 's/#.+$//' | sort || true)" | sed -E 's/  .*//'
}

# Set the tmp location, initiliaze APT_CONFIG and shared and private locations
cc::apt_get::init(){
  # Get the desired tmpfs mount point
  _cc_tmpfs_location="$1"

  mkdir -p "$_cc_tmpfs_location"

  # Point configuration there
  export APT_CONFIG="$_cc_tmpfs_location"/apt-get.conf

  # Sharding by sources list content, cleaned-up and sorted to maximize cache hits
	_cc_apt_list_store_location="$2/$(cc::apt_get::shard)"

  # Technically, we should not be sharding the architecture
  # But then, the only upside would be when installing cross-arch packages
	_cc_apt_pack_store_location="$3/$(cc::apt_get::shard)"

  # If we do not want lists to persist, use the tmp storage
  [ "${4:-}" == true ] || _cc_apt_list_local_location="$_cc_tmpfs_location"/lists

  # Finally, local pack location
  _cc_apt_pack_local_location="$_cc_tmpfs_location"/packs

  # Make sure they all exist
  mkdir -p "$_cc_apt_list_local_location"
  mkdir -p "$_cc_apt_pack_local_location"

  mkdir -p "$_cc_apt_list_store_location"
  mkdir -p "$_cc_apt_pack_store_location"
}

# Create the configuration file for APT
cc::apt_get::configure(){
  local config_extra="${1:-}"
  local persist="${2:-}"

  mkdir -p "$_cc_tmpfs_location/logs"
  cat << EOF > "$APT_CONFIG"
# Divert both lists and archives location
Dir::Cache::Archives "$_cc_apt_pack_local_location";
Dir::State::Lists "$_cc_apt_list_local_location";
# Prevent the default apt config to be used
Dir::Etc::parts "";
# Put the logs in the tmp zone
Dir::Log "$_cc_tmpfs_location/logs";
# Put the bin cache files in the private mount
Dir::Cache::srcpkgcache "$_cc_tmpfs_location/srcpkgcache.bin";
Dir::Cache::pkgcache "$_cc_tmpfs_location/pkgcache.bin";

$config_extra
EOF

  # If asked to persist the config, copy over the generated file
  [ "$persist" == "false" ] || cp "$APT_CONFIG" /etc/apt/apt.conf
}

#cc::apt_get::cleanup(){
  # This is only necessary if we were not using an tmpfs mount...
  # rm "$APT_CONFIG"
#}

cc::apt_get::update(){
  # Remove our marker if here
  rm -f "$_cc_apt_list_local_location"/.cc_updated

  # Retrieve existing data
  cc::storage::retrieve "$_cc_apt_list_store_location" "$_cc_apt_list_local_location" copy

	# Do the deed, same restriction applies
	apt-get update "$@"

  # Save it back (storage will decide)
  cc::storage::store "$_cc_apt_list_local_location" "$_cc_apt_list_store_location" erase

  # Now, flag it
  date > "$_cc_apt_list_local_location"/.cc_updated
}

cc::apt_get::do(){
  # Bring in any cache
  cc::storage::retrieve "$_cc_apt_pack_store_location" "$_cc_apt_pack_local_location"

	apt-get "$@"

  # Store the packages permanently
  cc::storage::store "$_cc_apt_pack_local_location" "$_cc_apt_pack_store_location"
}

# XXX what if sources are being modified, or config, or something else that materially impacts update?
cc::high::update(){
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "$nooutput"

  args+=("$@")
  time cc::apt_get::update "${args[@]}"
}

cc::high::install(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists has been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  args+=("$@")
  time cc::apt_get::do install "${args[@]}"
}

cc::high::upgrade(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists have been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  # ls -lAR "$_cc_tmpfs_location"/packs || true
  # time cc::apt_get::do upgrade "$nooutput" "$@"

  # XXX WIP here
  # Bust cache - delete this
  #time cc::apt_get::do upgrade --download-only "$nooutput" "$@"
  #time cc::apt_get::do upgrade --no-download "$nooutput" "$@"
  args+=("$@")
  time cc::apt_get::do upgrade "${args[@]}"
}

cc::high::purge(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")

  args+=("$@")
  time cc::apt_get::do purge --auto-remove "${args[@]}"
}(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
’"øºˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*£

/action.sh¿Ü#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::upgrade

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f7942
 



Z 
£
I
Gsha256:f65fec6162c8d70fc2311c3d20f1b6a91a87c9203547e280f276fe349ca18ac5
I
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
amd64linuxZ 
Í"‘—ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∏

/action.sh¿õ#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::install eatmydata nano socat

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c2
 



Z 
£
I
Gsha256:7a830e01dd5926f63eee241a37f13de580dac91af765ea3a0c027e5dc01a70b0
I
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
amd64linuxZ 
K
I
Gsha256:7675b821844b304f3dfa86c81f7648559f41024b3a59c7bda03b191a177910cdü
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library2.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library1.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupŒ
Gsha256:7675b821844b304f3dfa86c81f7648559f41024b3a59c7bda03b191a177910cdÇ!
codecomet.optest codecomet op6
llb.customname$apt-get install eatmydata nano socat*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeπ
Gsha256:7a830e01dd5926f63eee241a37f13de580dac91af765ea3a0c027e5dc01a70b0Ì!
codecomet.optest codecomet op!
llb.customnameapt-get upgrade*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeù
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962—!
codecomet.optest codecomet op0
llb.customname[action:addfile] codecomet in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupê
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edfƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library0.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupê
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8aƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupË
Gsha256:f65fec6162c8d70fc2311c3d20f1b6a91a87c9203547e280f276fe349ca18ac5ú!
codecomet.optest codecomet opG
llb.customname5[source:image] docker.io/library/debian:bullseye-slim*
source.image*
source.image.resolvemodeÄ
Gsha256:fe08b103bce4ea5603cb864c3b8f0394fee85e8253501e3a7d3fd8fc5b3008405*
constraints*
meta.description*
platformœ
K
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f 
K
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7 
K
Gsha256:7675b821844b304f3dfa86c81f7648559f41024b3a59c7bda03b191a177910cd 
K
Gsha256:7a830e01dd5926f63eee241a37f13de580dac91af765ea3a0c027e5dc01a70b0 
K
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962 
K
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c 
K
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf 
K
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c 
K
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794 
K
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a 
K
Gsha256:f65fec6162c8d70fc2311c3d20f1b6a91a87c9203547e280f276fe349ca18ac5 
fR
5docker-image://docker.io/library/debian:bullseye-slim
image.resolvemodepullR
arm64linuxZ 
æ›"ß›£›ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*â›

/codecomet¿Î‹#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Defines the supported color palette, and our color scheme
########################################################################################################################

# Supported color palette
readonly _CC_PV_COLOR_BLACK=0
readonly _CC_PV_COLOR_RED=1
readonly _CC_PV_COLOR_GREEN=2
readonly _CC_PV_COLOR_YELLOW=3
# shellcheck disable=SC2034
readonly _CC_PV_COLOR_BLUE=4
readonly _CC_PV_COLOR_MAGENTA=5
readonly _CC_PV_COLOR_CYAN=6
readonly _CC_PV_COLOR_WHITE=7

# Colors scheme definition - can evidently be customized at runtime by setting these variables to other values from the palette
export CC_COLOR_DEFAULT_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEFAULT_BACK="$_CC_PV_COLOR_BLACK"

export CC_COLOR_BODY="$_CC_PV_COLOR_WHITE"
export CC_COLOR_COMMENT="$_CC_PV_COLOR_CYAN"
export CC_COLOR_HUMPF="$_CC_PV_COLOR_MAGENTA"

# Logger
export CC_COLOR_ERROR_FRONT="$_CC_PV_COLOR_RED"
export CC_COLOR_ERROR_BACK="$_CC_PV_COLOR_WHITE"
export CC_COLOR_WARNING_FRONT="$_CC_PV_COLOR_YELLOW"
export CC_COLOR_WARNING_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_INFO_FRONT="$_CC_PV_COLOR_GREEN"
export CC_COLOR_INFO_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_DEBUG_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEBUG_BACK="$_CC_PV_COLOR_BLACK"

# Tracer
export CC_COLOR_TRACER_HUMPF="$_CC_PV_COLOR_GREEN"
export CC_COLOR_TRACER_COMMAND_LABEL="$_CC_PV_COLOR_BLUE"
export CC_COLOR_TRACER_OUTPUT_LABEL="$_CC_PV_COLOR_RED"
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provide helpers to print colorful text
#
# Depends on:
# defaults.sh
# colors.sh
########################################################################################################################

_cc_private::tput(){
  [ ! "$CC_CAP_HAS_TERM" ] || [ "$CC_CAP_NO_COLOR" != "" ] || tput "$@" 2>/dev/null || true
}

_cc_private::console::inline(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it and pad to 7 chars, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"
}

_cc_private::console(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-7s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    # Otherwise, just a plain front/back
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"

  # Restore console to default before we \n so that we do not leak over into BK timestamp display
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::error(){
  _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_ERROR_BACK" "error" "$@"
}

cc::console::warning(){
  _cc_private::console "$CC_COLOR_WARNING_FRONT" "$CC_COLOR_WARNING_BACK" "warning" "$@"
}

cc::console::info(){
  _cc_private::console "$CC_COLOR_INFO_FRONT" "$CC_COLOR_INFO_BACK" "info" "$@"
}

cc::console::debug(){
  _cc_private::console "$CC_COLOR_DEBUG_FRONT" "$CC_COLOR_DEBUG_BACK" "debug" "$@"
}

cc::console::body(){
  _cc_private::console "$CC_COLOR_BODY" "" "" "$@"
}

cc::console::comment(){
  _cc_private::console "$CC_COLOR_COMMENT" "" "" "$@"
}

cc::console::humpf(){
  _cc_private::console "$CC_COLOR_HUMPF" "" "" "$@"
}

cc::console::reset(){
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::end(){
  _cc_private::tput op
  printf "\n"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Debugger based on socat
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
# logger.sh
########################################################################################################################

# Fancy prompt adapted from https://github.com/pombadev/fancy-linux-prompt/blob/master/LICENSE under MIT License
__powerline() {
    # Unicode symbols
    readonly GIT_NEED_PULL_SYMBOL='‚á£'
    readonly GIT_NEED_PUSH_SYMBOL='‚á°'
    readonly PS_SYMBOL='ü™ê' # üêß‚òÑ'‚ñ∂‚èµ‚ñ∂‚èµ

    # Solarized colorscheme
    readonly BG_BLUE="\\[$(tput setab 4)\\]"
    readonly BG_COLOR5="\\[\\e[48;5;31m\\]"
    readonly BG_COLOR8="\\[\\e[48;5;161m\\]"
    readonly BG_GREEN="\\[$(tput setab 2)\\]"
    readonly BG_RED="\\[$(tput setab 1)\\]"
    readonly FG_BASE3="\\[$(tput setaf 15)\\]"
    readonly FG_BLUE="\\[$(tput setaf 4)\\]"
    readonly FG_COLOR1="\\[\\e[38;5;250m\\]"
    readonly FG_COLOR6="\\[\\e[38;5;31m\\]"
    readonly FG_COLOR9="\\[\\e[38;5;161m\\]"
    readonly FG_GREEN="\\[$(tput setaf 2)\\]"
    readonly FG_RED="\\[$(tput setaf 1)\\]"
    readonly RESET="\\[$(tput sgr0)\\]"

    __git_info() {
        # has a .git directory and a git binary
    	[ -d .git ] || command -v git >/dev/null || return 0

        local aheadN
        local behindN
        local branch
        local marks=""
        local stats

        # get current branch name or short SHA1 hash for detached head
        branch="$(git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --always 2>/dev/null)"
        [ -n "$branch" ] || return 0 # git branch not found

        # how many commits local branch is ahead/behind of remote?
        stats="$(git status --porcelain --branch | grep '^##' | grep -o '\[.\+\]$')"
        aheadN="$(echo "$stats" | grep -o 'ahead \d\+' | grep -o '\d\+')"
        behindN="$(echo "$stats" | grep -o 'behind \d\+' | grep -o '\d\+')"
        [ -n "$aheadN" ] && marks+=" $GIT_NEED_PUSH_SYMBOL$aheadN"
        [ -n "$behindN" ] && marks+=" $GIT_NEED_PULL_SYMBOL$behindN"

        # print the git branch segment without a trailing newline
        # branch is modified?
        if [ -n "$(git status --porcelain)" ]; then
            printf "%s" "${BG_COLOR8}‚ñ∂$RESET$BG_COLOR8 $branch$marks $FG_COLOR9"
        else
            printf "%s" "${BG_BLUE}‚ñ∂$RESET$BG_BLUE $branch$marks $RESET$FG_BLUE"
        fi
    }


    ps1() {
        # Check the exit code of the previous command and display different
        # colors in the prompt accordingly.
        if [ "$?" -eq 0 ]; then
            local BG_EXIT="$BG_GREEN"
            local FG_EXIT="$FG_GREEN"
        else
            local BG_EXIT="$BG_RED"
            local FG_EXIT="$FG_RED"
        fi

        PS1="$FG_COLOR1$BG_COLOR5 CodeComet \\w "
        PS1+="$RESET${FG_COLOR6}"
        PS1+="$(__git_info)"
        PS1+="$BG_EXIT‚ñ∂$RESET"
        PS1+="$BG_EXIT$FG_BASE3 ${PS_SYMBOL} ${RESET}${FG_EXIT}‚ñ∂${RESET} "
    }

    PROMPT_COMMAND=ps1
}

_cc_private::debugger::setup(){
  # Set-up PS1
  cat << EOF > "$CC_TMPFS"/.profile
# export PS1='\[\033[01;32m\]CodeComet\[\033[00m\] \w \$ '
alias l="ls -lA"
source ${BASH_SOURCE[0]}
umask 077
export LSCOLORS=exfxcxdxbxegedabagacad
export CLICOLOR=1

_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Welcome!" printf "You are now debugging your pipeline at the point it stopped.\n"
printf "\n"
#_cc_private::console::inline "$_CC_PV_COLOR_BLACK" "$_CC_PV_COLOR_BLACK" "         " printf ""
printf "Environment, pwd, and filesystem, are exactly as they were when the last action failed.\n"
printf "You can call the following helpers:\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdout" printf "will output your action stdout\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stderr" printf "will output your action stderr\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdex " printf "will output your action exit code\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_action" printf "will output the location of your action script\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Tip           " printf "If you want to re-run your action, just call \\\$(ccdebug_action)\n"

# touch "$CC_TMPFS/.codecomet/connected"
__powerline

EOF

  cat << EOF >> "$CC_TMPFS"/.inputrc
"\e[A": history-search-backward
"\e[B": history-search-forward
set show-all-if-ambiguous on
set completion-ignore-case on

EOF

}

# "on demand
# "Abnormal exit, with non zero grace:
# - start debugger repeatedly, with grace
# - once the other end exits, bail out

# "live", with non zero grace
# - start debugger, with infinity grace
# - if the other end was connected and exited, that is it, end of story
# - if the other end is still running, bring socat forward and wait for the end to exit
# - if there was no other end, we should branch back to the first scenario

# This is called on trap ERR, if a live debugger has been running, and will make a decision to bring it back forward and keep it alive,
# or to drop it
cc::debugger::front(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  cc::logger::debug "[debugger-front] socat is here"
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  cc::logger::debug "[debugger-front] grace is fine"


  # Debugger still live? Bail out if not
  jobs | grep -q -v Done || {
    cc::logger::debug "[debugger-front] no jobs detected. Bailing out."
    return 0
  }

  # Ok, it is live. Do we have a client?
  # XXX unfortunately, this does not work as expected... socat does start the process first, bash sources the files and create the stamp file...
  local lasttry
  local current
  lasttry="$(cat $CC_TMPFS/.codecomet/lasttry 2>/dev/null)" || true
  current="$(date +%s)"
  # The older an unconnected socat could be is 2 seconds - if greater than that, then we definitely have a client
  # However, it is possible that a client has been connected for less than 2 seconds (since socat call) when the failure happens,
  # which means the client will wrongly get the boot... no good solution right now
  [ $(( current - lasttry)) -gt 2 ] && {
  # [ -e "$CC_TMPFS/.codecomet/connected" ] && {
    cc::logger::debug "[debugger-front] we have a connected client"
    # Yes, then foreground and let it sit
    fg 2>/dev/null
  } || {
    cc::logger::debug "[debugger-front] no live client. Kick it out restart."
    # No live client. Kill it, and start again the normal process with timeout and message
    kill %%
    cc::debugger::start "$ex"
  }
}

# XXX this is largely broken
cc::debugger::live(){
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  while true; do
    lasttry="$(date +%s)"
    printf "%s" "$lasttry" > "$CC_TMPFS/.codecomet/lasttry"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-live] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Break if we have been hanging out more than a second (meaning the other end did connect, but exit in error)
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-live] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
    }
    x=$(( x + 1 ))
    cc::logger::debug "[debugger-live] sleeping"
    sleep 1
  done
}

cc::debugger::start(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  # Prep-up profile
  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  cc::logger::error "Abnormal exit code $ex. If you want to inspect manually, start codecomet-debugger. Otherwise, we will exit after $CC_DEBUGGER_GRACE seconds"
  cc::logger::error "You can also restart the build with CODECOMET_DEBUG=true"

  >&2 _cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "waiting" printf "Waiting %s seconds for debugger to connect" "$CC_DEBUGGER_GRACE"
  # cc::logger::warning "Waiting "


  # https://medium.com/@JAlblas/tryhackme-what-the-shell-walkthrough-6c0ebe8f854e
  #pty, allocates a pseudoterminal on the target ‚Äî part of the stabilisation process
  #stderr, makes sure that any error messages get shown in the shell (often a problem with non-interactive shells)
  #sigint, passes any Ctrl + C commands through into the sub-process, allowing us to kill commands inside the shell
  #setsid, creates the process in a new session
  #sane, stabilises the terminal, attempting to ‚Äúnormalise‚Äù it.

  while [ "$x" -lt "$CC_DEBUGGER_GRACE" ]; do
    lasttry="$(date +%s)"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-stat] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Timeing out means we wait for a second. Any more than that should mean the connection was succesful
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-stat] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
      >&2 printf "."
    }
    x=$(( x + 1 ))
    sleep 1
  done
}

ccdebug_stdout(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stdout.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stdout.log
  fi
}

ccdebug_stderr(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stderr.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stderr.log
  fi
}

ccdebug_stdex(){
  [ -e "$CC_TMPFS"/.codecomet/logs/ex.log ] && {
    cat "$CC_TMPFS"/.codecomet/logs/ex.log
  } || {
    cc::logger::warning "Action is in progress, no exit code yet"
  }
}

ccdebug_action(){
  echo "$_CC_PV_SCRIPT"
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# List all environment variables we depend on, possibly providing defaults
########################################################################################################################

#############
# Generic controls
#############
# Log level to start with (error, warning, info, debug or 4, 3, 2, 1, 0 <- mute)
readonly CC_LOG_LEVEL="${CC_LOG_LEVEL:-}"
# Where is the tempfs mounted
readonly CC_TMPFS="${CC_TMPFS:-}"
# Honors NO_COLOR (see https://no-color.org/)
# shellcheck disable=SC2034
readonly CC_CAP_NO_COLOR="${NO_COLOR:-}"
# About detection
# https://stackoverflow.com/questions/911168/how-can-i-detect-if-my-shell-script-is-running-through-a-pipe
# Could also test for [ ! -t 2 ]
# Or could be: `test -t 0` (formerly `tty -s`)
# In our context though, this probably does not matter much
# shellcheck disable=SC2034
readonly CC_CAP_HAS_TERM="${TERM:-}"

#############
# Action execution flow control
#############
# Whether the action can fail or not
readonly CC_ACTION_CAN_FAIL="${CC_ACTION_CAN_FAIL:-}"

#############
# Tracing and debugging
#############
# Controls wether the tracer will also trace internal codecomet library or hide them
readonly CC_TRACER_CODECOMET_INTERNALS="${CC_TRACER_CODECOMET_INTERNALS:-}"
# How long to wait for a connection before dropping the debugger
export CC_DEBUGGER_GRACE="${CC_DEBUGGER_GRACE:-}"
# Port to connect to
readonly CC_DEBUGGER_PORT="${CC_DEBUGGER_PORT:-}"
# IP to connect to
readonly CC_DEBUGGER_IP="${CC_DEBUGGER_IP:-}"
# Whether a debugger should be started pre-emptively so that one can hook in "live" during the action. This is very wonky as soon as you have parallelism...
readonly CC_DEBUGGER_LIVE="${CC_DEBUGGER_LIVE:-}"


#############
# Error code used accross the codebase - rn, only the bland FAILED is used...
#############
# shellcheck disable=SC2034
readonly ERROR_NETWORK=200
# Thrown if a required argument is missing
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_MISSING=201
# Thrown if an argument does not match validation
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_INVALID=202
# Should be used to convey that a certain operation is not supported
# shellcheck disable=SC2034
readonly ERROR_UNSUPPORTED=203
# Generic error to denote that the operation has failed. More specific errors may be provided instead
# shellcheck disable=SC2034
readonly ERROR_FAILED=204
# Expectations failed on a file (not readable, writable, doesn't exist, can't be created)
# shellcheck disable=SC2034
readonly ERROR_FILESYSTEM=205
# System requirements
# shellcheck disable=SC2034
readonly ERROR_MISSING_REQUIREMENTS=206

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# A generic logger
#
# Depends on:
# console.sh
########################################################################################################################

readonly CC_LOGGER_DEBUG=4
readonly CC_LOGGER_INFO=3
readonly CC_LOGGER_WARNING=2
readonly CC_LOGGER_ERROR=1

_CC_PV_LOGGER_LEVEL="$CC_LOGGER_WARNING"

_cc_private::logger::log(){
  local prefix="$1"
  shift

  local level="CC_LOGGER_$prefix"
  local i

  [ "$_CC_PV_LOGGER_LEVEL" -ge "${!level}" ] || return 0

  # About the crazy shit: https://stackoverflow.com/questions/12674783/bash-double-process-substitution-gives-bad-file-descriptor
  exec 3>&2
  for i in "$@"; do
    >&2 cc::console::"$(printf "$prefix" | tr '[:upper:]' '[:lower:]')" printf "$i"
  done
  exec 3>&-
}

cc::logger::level::set() {
  local level
  level="$(printf "%s" "${1:-}" | tr '[:upper:]' '[:lower:]')"

  case "$level" in
    ''|*[!0-9]*)
      case "$level" in
          "debug")
            _CC_PV_LOGGER_LEVEL=4
            ;;
          "info")
            _CC_PV_LOGGER_LEVEL=3
            ;;
          "warning")
            _CC_PV_LOGGER_LEVEL=2
            ;;
          "error")
            _CC_PV_LOGGER_LEVEL=1
            ;;
          "mute")
            _CC_PV_LOGGER_LEVEL=0
            ;;
          *)
            _CC_PV_LOGGER_LEVEL=3
            ;;
      esac
      ;;
    *)
      if [ "$level" -gt "$CC_LOGGER_DEBUG" ]; then
        return "$ERROR_FAILED"
      fi
      _CC_PV_LOGGER_LEVEL="$level"
      ;;
  esac

  [ "$_CC_PV_LOGGER_LEVEL" != "$CC_LOGGER_DEBUG" ] || {
    cc::console::warning printf "YOU ARE LOGGING AT THE DEBUG LEVEL."
    cc::console::warning printf "This is NOT recommended for production use, and WILL LIKELY LEAK sensitive information to logs."
  }
}

# Sugar
cc::logger::level::set::debug(){
  cc::logger::level::set "$CC_LOGGER_DEBUG"
}

cc::logger::level::set::info(){
  cc::logger::level::set "$CC_LOGGER_INFO"
}

cc::logger::level::set::warning(){
  cc::logger::level::set "$CC_LOGGER_WARNING"
}

cc::logger::level::set::error(){
  cc::logger::level::set "$CC_LOGGER_ERROR"
}

cc::logger::mute() {
  _CC_PV_LOGGER_LEVEL=0
}

cc::logger::ismute() {
  [ "$_CC_PV_LOGGER_LEVEL" == 0 ] || return "$ERROR_FAILED"
}

cc::logger::debug(){
  _cc_private::logger::log "DEBUG" "$@"
}

cc::logger::info(){
  _cc_private::logger::log "INFO" "$@"
}

cc::logger::warning(){
  _cc_private::logger::log "WARNING" "$@"
}

cc::logger::error(){
  _cc_private::logger::log "ERROR" "$@"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provides fancy display for `set -x`
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
########################################################################################################################

cc::codecomet::tracer(){
  local length="${#BASH_SOURCE[@]}"

  #local indent=""
  local linenumber
  local filename
  local filecontent
  local funcname
  local col

  [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[1]}" == *"action.sh" ]] || return 0

  printf "\n"

  for (( j=$(( length - 1 )); j>0; j-- )); do
    [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[$j]}" == *"action.sh" ]] || {
      continue
    }

    linenumber="${BASH_LINENO[$(( j - 1 ))]}"
    filename="${BASH_SOURCE[$j]}"
    filecontent="$(cat -n "$filename" | grep -E "^\s+$linenumber\s" | sed -E "s/^\s+$linenumber\s+//")"
    funcname="${FUNCNAME[$j]}"

    # Why is this showing is a mystery for the times
    # [ "$filecontent" != "#!/usr/bin/env bash" ] || continue

    [ "$j" != 1 ] && {
      col="$CC_COLOR_DEFAULT_FRONT"
    } || {
      col="$CC_COLOR_TRACER_HUMPF"
    }

    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$filename"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$linenumber"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "function" printf "%-30s" "$funcname()"
    printf "\n"
    [ "$j" != 1 ] || {
      _cc_private::console "$CC_COLOR_TRACER_COMMAND_LABEL" "$CC_COLOR_DEFAULT_FRONT" "command" printf "%s" "$filecontent"
      _cc_private::console "$CC_COLOR_TRACER_OUTPUT_LABEL" "$CC_COLOR_DEFAULT_FRONT" "output" printf ""
    }

  done
}

cc::tracer::register(){
  # shellcheck disable=SC2016
  local ps=('$(' "$@" ')')
  export PS4="${ps[*]}"
}

cc::init::tracer(){
  cc::tracer::register cc::codecomet::tracer
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Trap management
#
# Depends on:
# colors.sh
# console.sh
########################################################################################################################

_CC_PV_TRAP_LISTENERS=()

_CC_PV_ERR_LNO=
_CC_PV_ERR_CMD=
_CC_PV_ERR_STACK=
_CC_PV_ERR_EX=

dc::trap::register(){
  _CC_PV_TRAP_LISTENERS+=( "$1" )
}

# Trap lno and cmd on ERR for future use
cc::trap::err(){
  _CC_PV_ERR_EX="$1"
  _CC_PV_ERR_LNO="$2"
  _CC_PV_ERR_CMD="$3"
  _CC_PV_ERR_STACK="$4"
  # Dropping the rest of the stack?

  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$_CC_PV_ERR_STACK"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$_CC_PV_ERR_LNO"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "exit" printf "%s" "$_CC_PV_ERR_EX"
  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "command" printf "%-30s" "$_CC_PV_ERR_CMD"
  >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  >&2 printf "\n"

  >&2 _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "source" printf ""
  prefix=" "
  for (( j=$(( _CC_PV_ERR_LNO - 3 )); j<$(( _CC_PV_ERR_LNO + 3 )); j++ )); do
    [ "$j" -gt 0 ] || continue
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=">"
      >&2 _cc_private::tput setaf "$CC_COLOR_ERROR_FRONT"
      #>&2 _cc_private::tput bold
    fi
    #  | sed -E "s/^\s+$j\s//"
    >&2 printf "%s%s" "$prefix" "$(cat -n "$_CC_PV_ERR_STACK" | grep -E "^\s+$j\s")" || true
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=" "
      >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
      #>&2 _cc_private::tput sgr0
    fi
    >&2 printf "\n"
  done
}

_CC_PV_NO_REENTRY=

# Trap exit for the actual cleanup
cc::trap::exit() {
  # { set +x; } 2>/dev/null

  local ex="$1"
  local i

  # Prevent reentrancy - XXX is this actually needed?
  [ ! "$_CC_PV_NO_REENTRY" ] || return 0
  _CC_PV_NO_REENTRY="exiting"

  printf "%s\n" "$ex" > "$CC_TMPFS"/.codecomet/logs/ex.log

  if [ "${#_CC_PV_TRAP_LISTENERS[@]}" -gt 0 ]; then
    for i in "${_CC_PV_TRAP_LISTENERS[@]}"; do
      cc::logger::debug "Calling exit hook $i"
#      >&2 printf "\n"
      "$i" "$ex" "$_CC_PV_ERR_CMD" "$_CC_PV_ERR_LNO" "$_CC_PV_ERR_STACK"
    done
  fi
  >&2 cc::console::reset
  >&2 printf "\n"
  cc::logger::debug "Exiting ($ex)"
  [ "$CC_ACTION_CAN_FAIL" == "true" ] && {
    [ "$ex" != "" ] || cc::logger::error "Action failed, but it is marked as 'can fail', so, exiting successfully"
    exit 0
  } || exit "$ex"
}

# Forking to disable xtrace when entering traps
cc::init::trap(){
  # Signals are caught by buildkit already - and only SIGKILL triggers a failure
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::err "$ex" "$LINENO" "$BASH_COMMAND" "${BASH_SOURCE[@]}"' ERR
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::exit "$ex"' EXIT
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# See https://manpages.ubuntu.com/manpages/xenial/man1/eatmydata.1.html
# Technically, we get a 10% speedup with apt operations for eg
# XXX careful here if this is going to be used in a chroot
cc::init::speedup(){
  ! command -v eatmydata >/dev/null || export LD_PRELOAD=libeatmydata.so
}

# Boot if we have an argument - otherwise, we are being sourced
if [ "$#" -gt 0 ]; then
  mkdir -p "$TMPDIR"
  rm -Rf "$CC_TMPFS"/.codecomet
  mkdir -p "$CC_TMPFS"/.codecomet/bin
  mkdir -p "$CC_TMPFS"/.codecomet/logs

  # Set logger to env var from the Bash helper
  cc::logger::level::set "$CC_LOG_LEVEL"

  # Eat data, trap, register tracer, register debugger on exit trap
  cc::init::speedup
  cc::init::trap
  cc::init::tracer
  # Live debugger is really wonky
  if [ "${CC_DEBUGGER_LIVE:-}" != "" ]; then
    cc::debugger::live &
    dc::trap::register cc::debugger::front
  else
    [ "$CC_ACTION_CAN_FAIL" == true ] || dc::trap::register cc::debugger::start
  fi

  # XXX technically, we receive a bunch of scripts, and we could just play them all - use case is not completely clear yet
  out="$CC_TMPFS"/.codecomet/logs/stdout.log
  err="$CC_TMPFS"/.codecomet/logs/stderr.log

  # Unpack libraries path and source them
  while [ "$#" -gt 1 ]; do
    cp "$1" "$CC_TMPFS"/.codecomet/bin
    # shellcheck disable=SC1090
    source "$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
    shift
  done
  cp "$1" "$CC_TMPFS"/.codecomet/bin
  _CC_PV_SCRIPT="$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
  export _CC_PV_SCRIPT

  # Run the actual action
  # shellcheck disable=SC1090
  source "$_CC_PV_SCRIPT" > >(tee -a "$out") 2> >(tee -a "$err" >&2)
else
  # If we are a library, toss this one so we do not exit on any error...
  # This is especially important for the reverse debugger
  set +o errexit
fi
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
â"Ûˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*◊
/library0.sh¿∏#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# A generic lock mechanism that supports exclusive locks, shared locks, and a simplistic queueing mechanism
_cc_lockindex=9
_cc_lock_location="/_cc/share/locks"

# Sets our locks location. Must be called to guarantee that the lock location exist.
cc::lock::init(){
	_cc_lock_location="${1:-.}"
	mkdir -p "${_cc_lock_location}"
}

# Acquire a lock with a given name, and a share mode (shared or exclusive (which is the default))
# If the lock is already acquired in a different mode, or the mode is exclusive, the function will wait until the lock is released.
# Return the lock id that you need to carry around to release the lock later on.
cc::lock::acquire(){
	local lockfile="$_cc_lock_location/$1"
	local shared="${2:-}"
	[ "$shared" ] && shared=-s || shared=-x
	_cc_lockindex=$((_cc_lockindex+1))
	mkdir -p "$(dirname "$lockfile")"
	exec {_cc_lockindex}>"$lockfile"
	flock $shared $_cc_lockindex
	return $_cc_lockindex
}

# Release a previously acquire lock by its id
cc::lock::release(){
	local idx="$1"
	# This is essentially the same
	flock -u "$idx"
	# exec {idx}>&-
}

cc::lock::queue(){
	local basepath="${1:-.}"
	local shared1="${2:-}"
	local shared2="${3:-}"
	local qid
	local oid

	# Get into the queue first
	cc::lock::acquire "$basepath"/cc_queue.lock "$shared1" || qid=$?

	# Then when out of the queue, acquire an operation lock
	cc::lock::acquire "$basepath"/cc_op.lock "$shared2" || oid=$?

	# Now, leave the queue
	cc::lock::release $qid

	# Return the lock id
	return $oid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
˙"‰·ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*»
/library1.sh¿©#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Lessons learned:
# - find -exec is VERY SLOW - better off piping to read (almost 10x) (0.2 second vs 0.02 second for about 200 files)
# - then globbing and grepping is faster than find + read
# This matters not in case we are copying a large amount of data of course, but then
# - there is no way to get something stable out of ls without further processing - directories with different owners
# for eg will widen some columns
# this "works" right now (if we do not use --numeric-uid-gid) but will be problematic outside of this specific case

_cc::fingerprint(){
  local directory="$1"
  # Will fail if the directory is empty, so the guardrail
  # Ignore directories, links, and "total" (note: -d will not work for that)
  # --numeric-uid-gid < messes up the output width
  # shellcheck disable=SC2010
  ls --full-time --almost-all --ignore lock "$directory" 2>/dev/null | grep -v "^[d|l|t]" || true
}

# Copy or symlink data "from" storage "to" destination
# This assume that storage holds only files, and no lock
# Will not copy anything if there is no difference
cc::storage::retrieve(){
  local from="$1"
  local to="$2"
  local copy="${3:-}"
  local lid
  local fromState

  # Ensure destination exists
  mkdir -p "$to"

  # Lock origin and keep the lock id
  cc::lock::acquire "$from" shared || lid=$?

  # Ensure origin exists
  mkdir -p "$from"

  # If we are asked to copy (not expected for large amount of data - linking is prefered in that case)
  if [ "$copy" ]; then
    # Retrieve the state of it
    fromState="$(_cc::fingerprint "$from")"

    # Check that we have content in storage
    # Check that we have a difference between storage and destination (ignoring directories and lock file)
    # shellcheck disable=SC2010
    # shellcheck disable=SC2015
    [ "$fromState" ] && [ "$fromState" != "$(_cc::fingerprint "$to")" ] && {
      # Then cleanup destination
      rm -Rf "$to"
      mkdir -p "$to"
      # And copy over
      cp -p "$from"/* "$to"
      # Slower
      #find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
      #  cp -p "$fd" "$to"
      #done
    } || {
      # Otherwise, do nothing
      cc::logger::debug "Nothing to retrieve from storage"
    }
  else
    # We want links, so, lets check we have anything in the origin
    #[ ! "$fromState" ] || {
    # Get rid of possibly remaining files in our destination
    find "$to" -type f -delete
    ln -sf "$from"/* "$to" 2>/dev/null || true
    # Note: below is slower
    # find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
    #  ln -s "$fd" "$to"
    # done
    #}
  fi

  # Release the lock
	cc::lock::release $lid
}

cc::storage::store(){
  local from="$1"
  local to="$2"
  local erase="${3:-}"
  local lid
  local fd
  local toState

  # Ensure origin exists
  mkdir -p "$from"

  # Lock destination and keep the lock id
  cc::lock::acquire "$to" "" || lid=$?

  # Ensure destination exists
  mkdir -p "$to"
  # Retrieve the state of it
  # shellcheck disable=SC2010
  toState="$(_cc::fingerprint "$to")"

  # Compare state of the destination with the origin (origin ignores directories and lock files)
  # shellcheck disable=SC2010
  # shellcheck disable=SC2015
  [ "$toState" != "$(_cc::fingerprint "$from")" ] && {
    # We have changes - if asked to wipe out, do so
    if [ "$erase" ]; then
      rm -Rf "$to"
      mkdir -p "$to"
    fi
    # Now copy the files
    # This is probably slow-ish. The question is: will it be significant in a context where copy IO is the bottleneck?
    find "$from" -type f -not -iname "lock" -print0 | while IFS= read -r -d $'\0' fd; do
      cp -p "$fd" "$to"
    done
  } || {
    cc::logger::debug "Nothing to save to storage"
  }

  # Release the lock
	cc::lock::release $lid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
Ï*"÷*”*ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∫*
/library2.sh¿õ*#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Helpers to allow apt to share cache properly

# Private tmpfs location
_cc_tmpfs_location=/codecomet/apt-get-private/tmp

# Location of the list cache
_cc_apt_list_store_location=/codecomet/apt-get-shared/lists
# And pack cache
_cc_apt_pack_local_location=/codecomet/apt-get-shared/packs

# Location of the packages cache
_cc_apt_pack_store_location=/codecomet/apt-get-shared/cache

# Location of our private lists files - by default, Debian normal location, which means state will persist
_cc_apt_list_local_location=/var/lib/apt/lists

# Location of the config file
export APT_CONFIG=$_cc_tmpfs_location/apt-get.conf

# Hash of the sources.list, which dictates the cache location to share
# Different sources means different cache location
# Caveats: this will likely not work with a future debian release as they change the sources.list format
# XXX this wracking the debugger output
cc::apt_get::shard(){
  sha256sum <<< "$(uname -m)$(grep --no-filename -Ev "^#" /etc/apt/sources.list /etc/apt/sources.list.d/* 2>/dev/null | sed -E 's/#.+$//' | sort || true)" | sed -E 's/  .*//'
}

# Set the tmp location, initiliaze APT_CONFIG and shared and private locations
cc::apt_get::init(){
  # Get the desired tmpfs mount point
  _cc_tmpfs_location="$1"

  mkdir -p "$_cc_tmpfs_location"

  # Point configuration there
  export APT_CONFIG="$_cc_tmpfs_location"/apt-get.conf

  # Sharding by sources list content, cleaned-up and sorted to maximize cache hits
	_cc_apt_list_store_location="$2/$(cc::apt_get::shard)"

  # Technically, we should not be sharding the architecture
  # But then, the only upside would be when installing cross-arch packages
	_cc_apt_pack_store_location="$3/$(cc::apt_get::shard)"

  # If we do not want lists to persist, use the tmp storage
  [ "${4:-}" == true ] || _cc_apt_list_local_location="$_cc_tmpfs_location"/lists

  # Finally, local pack location
  _cc_apt_pack_local_location="$_cc_tmpfs_location"/packs

  # Make sure they all exist
  mkdir -p "$_cc_apt_list_local_location"
  mkdir -p "$_cc_apt_pack_local_location"

  mkdir -p "$_cc_apt_list_store_location"
  mkdir -p "$_cc_apt_pack_store_location"
}

# Create the configuration file for APT
cc::apt_get::configure(){
  local config_extra="${1:-}"
  local persist="${2:-}"

  mkdir -p "$_cc_tmpfs_location/logs"
  cat << EOF > "$APT_CONFIG"
# Divert both lists and archives location
Dir::Cache::Archives "$_cc_apt_pack_local_location";
Dir::State::Lists "$_cc_apt_list_local_location";
# Prevent the default apt config to be used
Dir::Etc::parts "";
# Put the logs in the tmp zone
Dir::Log "$_cc_tmpfs_location/logs";
# Put the bin cache files in the private mount
Dir::Cache::srcpkgcache "$_cc_tmpfs_location/srcpkgcache.bin";
Dir::Cache::pkgcache "$_cc_tmpfs_location/pkgcache.bin";

$config_extra
EOF

  # If asked to persist the config, copy over the generated file
  [ "$persist" == "false" ] || cp "$APT_CONFIG" /etc/apt/apt.conf
}

#cc::apt_get::cleanup(){
  # This is only necessary if we were not using an tmpfs mount...
  # rm "$APT_CONFIG"
#}

cc::apt_get::update(){
  # Remove our marker if here
  rm -f "$_cc_apt_list_local_location"/.cc_updated

  # Retrieve existing data
  cc::storage::retrieve "$_cc_apt_list_store_location" "$_cc_apt_list_local_location" copy

	# Do the deed, same restriction applies
	apt-get update "$@"

  # Save it back (storage will decide)
  cc::storage::store "$_cc_apt_list_local_location" "$_cc_apt_list_store_location" erase

  # Now, flag it
  date > "$_cc_apt_list_local_location"/.cc_updated
}

cc::apt_get::do(){
  # Bring in any cache
  cc::storage::retrieve "$_cc_apt_pack_store_location" "$_cc_apt_pack_local_location"

	apt-get "$@"

  # Store the packages permanently
  cc::storage::store "$_cc_apt_pack_local_location" "$_cc_apt_pack_store_location"
}

# XXX what if sources are being modified, or config, or something else that materially impacts update?
cc::high::update(){
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "$nooutput"

  args+=("$@")
  time cc::apt_get::update "${args[@]}"
}

cc::high::install(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists has been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  args+=("$@")
  time cc::apt_get::do install "${args[@]}"
}

cc::high::upgrade(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists have been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  # ls -lAR "$_cc_tmpfs_location"/packs || true
  # time cc::apt_get::do upgrade "$nooutput" "$@"

  # XXX WIP here
  # Bust cache - delete this
  #time cc::apt_get::do upgrade --download-only "$nooutput" "$@"
  #time cc::apt_get::do upgrade --no-download "$nooutput" "$@"
  args+=("$@")
  time cc::apt_get::do upgrade "${args[@]}"
}

cc::high::purge(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")

  args+=("$@")
  time cc::apt_get::do purge --auto-remove "${args[@]}"
}(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
’"øºˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*£

/action.sh¿Ü#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::upgrade

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f7942
 



Z 
£
I
Gsha256:aba97bce52cb75c817d06fec2353f811940c416a472ab6b0fab8ae0a54511d83
I
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
arm64linuxZ 
Í"‘—ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∏

/action.sh¿õ#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::install eatmydata nano socat

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c2
 



Z 
£
I
Gsha256:1f71c46c8f58462f657331fc0617521fb54f9990f04397320f86547435ca03f3
I
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
arm64linuxZ 
K
I
Gsha256:c7759768f7674d770a8a4ef7c18d38e5c0deb872d612f1f8102e8bdebc9bcf0eπ
Gsha256:1f71c46c8f58462f657331fc0617521fb54f9990f04397320f86547435ca03f3Ì!
codecomet.optest codecomet op!
llb.customnameapt-get upgrade*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeü
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library2.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library1.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962—!
codecomet.optest codecomet op0
llb.customname[action:addfile] codecomet in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupË
Gsha256:aba97bce52cb75c817d06fec2353f811940c416a472ab6b0fab8ae0a54511d83ú!
codecomet.optest codecomet opG
llb.customname5[source:image] docker.io/library/debian:bullseye-slim*
source.image*
source.image.resolvemodeê
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edfƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library0.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupŒ
Gsha256:c7759768f7674d770a8a4ef7c18d38e5c0deb872d612f1f8102e8bdebc9bcf0eÇ!
codecomet.optest codecomet op6
llb.customname$apt-get install eatmydata nano socat*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeÄ
Gsha256:e0223abffd3a522e48edba08a44b777ad6b5b53eaafcfe5f5f7ae63aaa1097405*
constraints*
meta.description*
platformê
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8aƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupœ
K
Gsha256:1f71c46c8f58462f657331fc0617521fb54f9990f04397320f86547435ca03f3 
K
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f 
K
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7 
K
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962 
K
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c 
K
Gsha256:aba97bce52cb75c817d06fec2353f811940c416a472ab6b0fab8ae0a54511d83 
K
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf 
K
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c 
K
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794 
K
Gsha256:c7759768f7674d770a8a4ef7c18d38e5c0deb872d612f1f8102e8bdebc9bcf0e 
K
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a 
hR
5docker-image://docker.io/library/debian:bullseye-slim
image.resolvemodepullR
armlinuxv7Z 
æ›"ß›£›ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*â›

/codecomet¿Î‹#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Defines the supported color palette, and our color scheme
########################################################################################################################

# Supported color palette
readonly _CC_PV_COLOR_BLACK=0
readonly _CC_PV_COLOR_RED=1
readonly _CC_PV_COLOR_GREEN=2
readonly _CC_PV_COLOR_YELLOW=3
# shellcheck disable=SC2034
readonly _CC_PV_COLOR_BLUE=4
readonly _CC_PV_COLOR_MAGENTA=5
readonly _CC_PV_COLOR_CYAN=6
readonly _CC_PV_COLOR_WHITE=7

# Colors scheme definition - can evidently be customized at runtime by setting these variables to other values from the palette
export CC_COLOR_DEFAULT_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEFAULT_BACK="$_CC_PV_COLOR_BLACK"

export CC_COLOR_BODY="$_CC_PV_COLOR_WHITE"
export CC_COLOR_COMMENT="$_CC_PV_COLOR_CYAN"
export CC_COLOR_HUMPF="$_CC_PV_COLOR_MAGENTA"

# Logger
export CC_COLOR_ERROR_FRONT="$_CC_PV_COLOR_RED"
export CC_COLOR_ERROR_BACK="$_CC_PV_COLOR_WHITE"
export CC_COLOR_WARNING_FRONT="$_CC_PV_COLOR_YELLOW"
export CC_COLOR_WARNING_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_INFO_FRONT="$_CC_PV_COLOR_GREEN"
export CC_COLOR_INFO_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_DEBUG_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEBUG_BACK="$_CC_PV_COLOR_BLACK"

# Tracer
export CC_COLOR_TRACER_HUMPF="$_CC_PV_COLOR_GREEN"
export CC_COLOR_TRACER_COMMAND_LABEL="$_CC_PV_COLOR_BLUE"
export CC_COLOR_TRACER_OUTPUT_LABEL="$_CC_PV_COLOR_RED"
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provide helpers to print colorful text
#
# Depends on:
# defaults.sh
# colors.sh
########################################################################################################################

_cc_private::tput(){
  [ ! "$CC_CAP_HAS_TERM" ] || [ "$CC_CAP_NO_COLOR" != "" ] || tput "$@" 2>/dev/null || true
}

_cc_private::console::inline(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it and pad to 7 chars, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"
}

_cc_private::console(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-7s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    # Otherwise, just a plain front/back
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"

  # Restore console to default before we \n so that we do not leak over into BK timestamp display
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::error(){
  _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_ERROR_BACK" "error" "$@"
}

cc::console::warning(){
  _cc_private::console "$CC_COLOR_WARNING_FRONT" "$CC_COLOR_WARNING_BACK" "warning" "$@"
}

cc::console::info(){
  _cc_private::console "$CC_COLOR_INFO_FRONT" "$CC_COLOR_INFO_BACK" "info" "$@"
}

cc::console::debug(){
  _cc_private::console "$CC_COLOR_DEBUG_FRONT" "$CC_COLOR_DEBUG_BACK" "debug" "$@"
}

cc::console::body(){
  _cc_private::console "$CC_COLOR_BODY" "" "" "$@"
}

cc::console::comment(){
  _cc_private::console "$CC_COLOR_COMMENT" "" "" "$@"
}

cc::console::humpf(){
  _cc_private::console "$CC_COLOR_HUMPF" "" "" "$@"
}

cc::console::reset(){
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::end(){
  _cc_private::tput op
  printf "\n"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Debugger based on socat
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
# logger.sh
########################################################################################################################

# Fancy prompt adapted from https://github.com/pombadev/fancy-linux-prompt/blob/master/LICENSE under MIT License
__powerline() {
    # Unicode symbols
    readonly GIT_NEED_PULL_SYMBOL='‚á£'
    readonly GIT_NEED_PUSH_SYMBOL='‚á°'
    readonly PS_SYMBOL='ü™ê' # üêß‚òÑ'‚ñ∂‚èµ‚ñ∂‚èµ

    # Solarized colorscheme
    readonly BG_BLUE="\\[$(tput setab 4)\\]"
    readonly BG_COLOR5="\\[\\e[48;5;31m\\]"
    readonly BG_COLOR8="\\[\\e[48;5;161m\\]"
    readonly BG_GREEN="\\[$(tput setab 2)\\]"
    readonly BG_RED="\\[$(tput setab 1)\\]"
    readonly FG_BASE3="\\[$(tput setaf 15)\\]"
    readonly FG_BLUE="\\[$(tput setaf 4)\\]"
    readonly FG_COLOR1="\\[\\e[38;5;250m\\]"
    readonly FG_COLOR6="\\[\\e[38;5;31m\\]"
    readonly FG_COLOR9="\\[\\e[38;5;161m\\]"
    readonly FG_GREEN="\\[$(tput setaf 2)\\]"
    readonly FG_RED="\\[$(tput setaf 1)\\]"
    readonly RESET="\\[$(tput sgr0)\\]"

    __git_info() {
        # has a .git directory and a git binary
    	[ -d .git ] || command -v git >/dev/null || return 0

        local aheadN
        local behindN
        local branch
        local marks=""
        local stats

        # get current branch name or short SHA1 hash for detached head
        branch="$(git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --always 2>/dev/null)"
        [ -n "$branch" ] || return 0 # git branch not found

        # how many commits local branch is ahead/behind of remote?
        stats="$(git status --porcelain --branch | grep '^##' | grep -o '\[.\+\]$')"
        aheadN="$(echo "$stats" | grep -o 'ahead \d\+' | grep -o '\d\+')"
        behindN="$(echo "$stats" | grep -o 'behind \d\+' | grep -o '\d\+')"
        [ -n "$aheadN" ] && marks+=" $GIT_NEED_PUSH_SYMBOL$aheadN"
        [ -n "$behindN" ] && marks+=" $GIT_NEED_PULL_SYMBOL$behindN"

        # print the git branch segment without a trailing newline
        # branch is modified?
        if [ -n "$(git status --porcelain)" ]; then
            printf "%s" "${BG_COLOR8}‚ñ∂$RESET$BG_COLOR8 $branch$marks $FG_COLOR9"
        else
            printf "%s" "${BG_BLUE}‚ñ∂$RESET$BG_BLUE $branch$marks $RESET$FG_BLUE"
        fi
    }


    ps1() {
        # Check the exit code of the previous command and display different
        # colors in the prompt accordingly.
        if [ "$?" -eq 0 ]; then
            local BG_EXIT="$BG_GREEN"
            local FG_EXIT="$FG_GREEN"
        else
            local BG_EXIT="$BG_RED"
            local FG_EXIT="$FG_RED"
        fi

        PS1="$FG_COLOR1$BG_COLOR5 CodeComet \\w "
        PS1+="$RESET${FG_COLOR6}"
        PS1+="$(__git_info)"
        PS1+="$BG_EXIT‚ñ∂$RESET"
        PS1+="$BG_EXIT$FG_BASE3 ${PS_SYMBOL} ${RESET}${FG_EXIT}‚ñ∂${RESET} "
    }

    PROMPT_COMMAND=ps1
}

_cc_private::debugger::setup(){
  # Set-up PS1
  cat << EOF > "$CC_TMPFS"/.profile
# export PS1='\[\033[01;32m\]CodeComet\[\033[00m\] \w \$ '
alias l="ls -lA"
source ${BASH_SOURCE[0]}
umask 077
export LSCOLORS=exfxcxdxbxegedabagacad
export CLICOLOR=1

_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Welcome!" printf "You are now debugging your pipeline at the point it stopped.\n"
printf "\n"
#_cc_private::console::inline "$_CC_PV_COLOR_BLACK" "$_CC_PV_COLOR_BLACK" "         " printf ""
printf "Environment, pwd, and filesystem, are exactly as they were when the last action failed.\n"
printf "You can call the following helpers:\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdout" printf "will output your action stdout\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stderr" printf "will output your action stderr\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdex " printf "will output your action exit code\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_action" printf "will output the location of your action script\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Tip           " printf "If you want to re-run your action, just call \\\$(ccdebug_action)\n"

# touch "$CC_TMPFS/.codecomet/connected"
__powerline

EOF

  cat << EOF >> "$CC_TMPFS"/.inputrc
"\e[A": history-search-backward
"\e[B": history-search-forward
set show-all-if-ambiguous on
set completion-ignore-case on

EOF

}

# "on demand
# "Abnormal exit, with non zero grace:
# - start debugger repeatedly, with grace
# - once the other end exits, bail out

# "live", with non zero grace
# - start debugger, with infinity grace
# - if the other end was connected and exited, that is it, end of story
# - if the other end is still running, bring socat forward and wait for the end to exit
# - if there was no other end, we should branch back to the first scenario

# This is called on trap ERR, if a live debugger has been running, and will make a decision to bring it back forward and keep it alive,
# or to drop it
cc::debugger::front(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  cc::logger::debug "[debugger-front] socat is here"
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  cc::logger::debug "[debugger-front] grace is fine"


  # Debugger still live? Bail out if not
  jobs | grep -q -v Done || {
    cc::logger::debug "[debugger-front] no jobs detected. Bailing out."
    return 0
  }

  # Ok, it is live. Do we have a client?
  # XXX unfortunately, this does not work as expected... socat does start the process first, bash sources the files and create the stamp file...
  local lasttry
  local current
  lasttry="$(cat $CC_TMPFS/.codecomet/lasttry 2>/dev/null)" || true
  current="$(date +%s)"
  # The older an unconnected socat could be is 2 seconds - if greater than that, then we definitely have a client
  # However, it is possible that a client has been connected for less than 2 seconds (since socat call) when the failure happens,
  # which means the client will wrongly get the boot... no good solution right now
  [ $(( current - lasttry)) -gt 2 ] && {
  # [ -e "$CC_TMPFS/.codecomet/connected" ] && {
    cc::logger::debug "[debugger-front] we have a connected client"
    # Yes, then foreground and let it sit
    fg 2>/dev/null
  } || {
    cc::logger::debug "[debugger-front] no live client. Kick it out restart."
    # No live client. Kill it, and start again the normal process with timeout and message
    kill %%
    cc::debugger::start "$ex"
  }
}

# XXX this is largely broken
cc::debugger::live(){
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  while true; do
    lasttry="$(date +%s)"
    printf "%s" "$lasttry" > "$CC_TMPFS/.codecomet/lasttry"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-live] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Break if we have been hanging out more than a second (meaning the other end did connect, but exit in error)
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-live] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
    }
    x=$(( x + 1 ))
    cc::logger::debug "[debugger-live] sleeping"
    sleep 1
  done
}

cc::debugger::start(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  # Prep-up profile
  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  cc::logger::error "Abnormal exit code $ex. If you want to inspect manually, start codecomet-debugger. Otherwise, we will exit after $CC_DEBUGGER_GRACE seconds"
  cc::logger::error "You can also restart the build with CODECOMET_DEBUG=true"

  >&2 _cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "waiting" printf "Waiting %s seconds for debugger to connect" "$CC_DEBUGGER_GRACE"
  # cc::logger::warning "Waiting "


  # https://medium.com/@JAlblas/tryhackme-what-the-shell-walkthrough-6c0ebe8f854e
  #pty, allocates a pseudoterminal on the target ‚Äî part of the stabilisation process
  #stderr, makes sure that any error messages get shown in the shell (often a problem with non-interactive shells)
  #sigint, passes any Ctrl + C commands through into the sub-process, allowing us to kill commands inside the shell
  #setsid, creates the process in a new session
  #sane, stabilises the terminal, attempting to ‚Äúnormalise‚Äù it.

  while [ "$x" -lt "$CC_DEBUGGER_GRACE" ]; do
    lasttry="$(date +%s)"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-stat] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Timeing out means we wait for a second. Any more than that should mean the connection was succesful
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-stat] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
      >&2 printf "."
    }
    x=$(( x + 1 ))
    sleep 1
  done
}

ccdebug_stdout(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stdout.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stdout.log
  fi
}

ccdebug_stderr(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stderr.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stderr.log
  fi
}

ccdebug_stdex(){
  [ -e "$CC_TMPFS"/.codecomet/logs/ex.log ] && {
    cat "$CC_TMPFS"/.codecomet/logs/ex.log
  } || {
    cc::logger::warning "Action is in progress, no exit code yet"
  }
}

ccdebug_action(){
  echo "$_CC_PV_SCRIPT"
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# List all environment variables we depend on, possibly providing defaults
########################################################################################################################

#############
# Generic controls
#############
# Log level to start with (error, warning, info, debug or 4, 3, 2, 1, 0 <- mute)
readonly CC_LOG_LEVEL="${CC_LOG_LEVEL:-}"
# Where is the tempfs mounted
readonly CC_TMPFS="${CC_TMPFS:-}"
# Honors NO_COLOR (see https://no-color.org/)
# shellcheck disable=SC2034
readonly CC_CAP_NO_COLOR="${NO_COLOR:-}"
# About detection
# https://stackoverflow.com/questions/911168/how-can-i-detect-if-my-shell-script-is-running-through-a-pipe
# Could also test for [ ! -t 2 ]
# Or could be: `test -t 0` (formerly `tty -s`)
# In our context though, this probably does not matter much
# shellcheck disable=SC2034
readonly CC_CAP_HAS_TERM="${TERM:-}"

#############
# Action execution flow control
#############
# Whether the action can fail or not
readonly CC_ACTION_CAN_FAIL="${CC_ACTION_CAN_FAIL:-}"

#############
# Tracing and debugging
#############
# Controls wether the tracer will also trace internal codecomet library or hide them
readonly CC_TRACER_CODECOMET_INTERNALS="${CC_TRACER_CODECOMET_INTERNALS:-}"
# How long to wait for a connection before dropping the debugger
export CC_DEBUGGER_GRACE="${CC_DEBUGGER_GRACE:-}"
# Port to connect to
readonly CC_DEBUGGER_PORT="${CC_DEBUGGER_PORT:-}"
# IP to connect to
readonly CC_DEBUGGER_IP="${CC_DEBUGGER_IP:-}"
# Whether a debugger should be started pre-emptively so that one can hook in "live" during the action. This is very wonky as soon as you have parallelism...
readonly CC_DEBUGGER_LIVE="${CC_DEBUGGER_LIVE:-}"


#############
# Error code used accross the codebase - rn, only the bland FAILED is used...
#############
# shellcheck disable=SC2034
readonly ERROR_NETWORK=200
# Thrown if a required argument is missing
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_MISSING=201
# Thrown if an argument does not match validation
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_INVALID=202
# Should be used to convey that a certain operation is not supported
# shellcheck disable=SC2034
readonly ERROR_UNSUPPORTED=203
# Generic error to denote that the operation has failed. More specific errors may be provided instead
# shellcheck disable=SC2034
readonly ERROR_FAILED=204
# Expectations failed on a file (not readable, writable, doesn't exist, can't be created)
# shellcheck disable=SC2034
readonly ERROR_FILESYSTEM=205
# System requirements
# shellcheck disable=SC2034
readonly ERROR_MISSING_REQUIREMENTS=206

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# A generic logger
#
# Depends on:
# console.sh
########################################################################################################################

readonly CC_LOGGER_DEBUG=4
readonly CC_LOGGER_INFO=3
readonly CC_LOGGER_WARNING=2
readonly CC_LOGGER_ERROR=1

_CC_PV_LOGGER_LEVEL="$CC_LOGGER_WARNING"

_cc_private::logger::log(){
  local prefix="$1"
  shift

  local level="CC_LOGGER_$prefix"
  local i

  [ "$_CC_PV_LOGGER_LEVEL" -ge "${!level}" ] || return 0

  # About the crazy shit: https://stackoverflow.com/questions/12674783/bash-double-process-substitution-gives-bad-file-descriptor
  exec 3>&2
  for i in "$@"; do
    >&2 cc::console::"$(printf "$prefix" | tr '[:upper:]' '[:lower:]')" printf "$i"
  done
  exec 3>&-
}

cc::logger::level::set() {
  local level
  level="$(printf "%s" "${1:-}" | tr '[:upper:]' '[:lower:]')"

  case "$level" in
    ''|*[!0-9]*)
      case "$level" in
          "debug")
            _CC_PV_LOGGER_LEVEL=4
            ;;
          "info")
            _CC_PV_LOGGER_LEVEL=3
            ;;
          "warning")
            _CC_PV_LOGGER_LEVEL=2
            ;;
          "error")
            _CC_PV_LOGGER_LEVEL=1
            ;;
          "mute")
            _CC_PV_LOGGER_LEVEL=0
            ;;
          *)
            _CC_PV_LOGGER_LEVEL=3
            ;;
      esac
      ;;
    *)
      if [ "$level" -gt "$CC_LOGGER_DEBUG" ]; then
        return "$ERROR_FAILED"
      fi
      _CC_PV_LOGGER_LEVEL="$level"
      ;;
  esac

  [ "$_CC_PV_LOGGER_LEVEL" != "$CC_LOGGER_DEBUG" ] || {
    cc::console::warning printf "YOU ARE LOGGING AT THE DEBUG LEVEL."
    cc::console::warning printf "This is NOT recommended for production use, and WILL LIKELY LEAK sensitive information to logs."
  }
}

# Sugar
cc::logger::level::set::debug(){
  cc::logger::level::set "$CC_LOGGER_DEBUG"
}

cc::logger::level::set::info(){
  cc::logger::level::set "$CC_LOGGER_INFO"
}

cc::logger::level::set::warning(){
  cc::logger::level::set "$CC_LOGGER_WARNING"
}

cc::logger::level::set::error(){
  cc::logger::level::set "$CC_LOGGER_ERROR"
}

cc::logger::mute() {
  _CC_PV_LOGGER_LEVEL=0
}

cc::logger::ismute() {
  [ "$_CC_PV_LOGGER_LEVEL" == 0 ] || return "$ERROR_FAILED"
}

cc::logger::debug(){
  _cc_private::logger::log "DEBUG" "$@"
}

cc::logger::info(){
  _cc_private::logger::log "INFO" "$@"
}

cc::logger::warning(){
  _cc_private::logger::log "WARNING" "$@"
}

cc::logger::error(){
  _cc_private::logger::log "ERROR" "$@"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provides fancy display for `set -x`
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
########################################################################################################################

cc::codecomet::tracer(){
  local length="${#BASH_SOURCE[@]}"

  #local indent=""
  local linenumber
  local filename
  local filecontent
  local funcname
  local col

  [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[1]}" == *"action.sh" ]] || return 0

  printf "\n"

  for (( j=$(( length - 1 )); j>0; j-- )); do
    [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[$j]}" == *"action.sh" ]] || {
      continue
    }

    linenumber="${BASH_LINENO[$(( j - 1 ))]}"
    filename="${BASH_SOURCE[$j]}"
    filecontent="$(cat -n "$filename" | grep -E "^\s+$linenumber\s" | sed -E "s/^\s+$linenumber\s+//")"
    funcname="${FUNCNAME[$j]}"

    # Why is this showing is a mystery for the times
    # [ "$filecontent" != "#!/usr/bin/env bash" ] || continue

    [ "$j" != 1 ] && {
      col="$CC_COLOR_DEFAULT_FRONT"
    } || {
      col="$CC_COLOR_TRACER_HUMPF"
    }

    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$filename"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$linenumber"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "function" printf "%-30s" "$funcname()"
    printf "\n"
    [ "$j" != 1 ] || {
      _cc_private::console "$CC_COLOR_TRACER_COMMAND_LABEL" "$CC_COLOR_DEFAULT_FRONT" "command" printf "%s" "$filecontent"
      _cc_private::console "$CC_COLOR_TRACER_OUTPUT_LABEL" "$CC_COLOR_DEFAULT_FRONT" "output" printf ""
    }

  done
}

cc::tracer::register(){
  # shellcheck disable=SC2016
  local ps=('$(' "$@" ')')
  export PS4="${ps[*]}"
}

cc::init::tracer(){
  cc::tracer::register cc::codecomet::tracer
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Trap management
#
# Depends on:
# colors.sh
# console.sh
########################################################################################################################

_CC_PV_TRAP_LISTENERS=()

_CC_PV_ERR_LNO=
_CC_PV_ERR_CMD=
_CC_PV_ERR_STACK=
_CC_PV_ERR_EX=

dc::trap::register(){
  _CC_PV_TRAP_LISTENERS+=( "$1" )
}

# Trap lno and cmd on ERR for future use
cc::trap::err(){
  _CC_PV_ERR_EX="$1"
  _CC_PV_ERR_LNO="$2"
  _CC_PV_ERR_CMD="$3"
  _CC_PV_ERR_STACK="$4"
  # Dropping the rest of the stack?

  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$_CC_PV_ERR_STACK"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$_CC_PV_ERR_LNO"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "exit" printf "%s" "$_CC_PV_ERR_EX"
  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "command" printf "%-30s" "$_CC_PV_ERR_CMD"
  >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  >&2 printf "\n"

  >&2 _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "source" printf ""
  prefix=" "
  for (( j=$(( _CC_PV_ERR_LNO - 3 )); j<$(( _CC_PV_ERR_LNO + 3 )); j++ )); do
    [ "$j" -gt 0 ] || continue
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=">"
      >&2 _cc_private::tput setaf "$CC_COLOR_ERROR_FRONT"
      #>&2 _cc_private::tput bold
    fi
    #  | sed -E "s/^\s+$j\s//"
    >&2 printf "%s%s" "$prefix" "$(cat -n "$_CC_PV_ERR_STACK" | grep -E "^\s+$j\s")" || true
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=" "
      >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
      #>&2 _cc_private::tput sgr0
    fi
    >&2 printf "\n"
  done
}

_CC_PV_NO_REENTRY=

# Trap exit for the actual cleanup
cc::trap::exit() {
  # { set +x; } 2>/dev/null

  local ex="$1"
  local i

  # Prevent reentrancy - XXX is this actually needed?
  [ ! "$_CC_PV_NO_REENTRY" ] || return 0
  _CC_PV_NO_REENTRY="exiting"

  printf "%s\n" "$ex" > "$CC_TMPFS"/.codecomet/logs/ex.log

  if [ "${#_CC_PV_TRAP_LISTENERS[@]}" -gt 0 ]; then
    for i in "${_CC_PV_TRAP_LISTENERS[@]}"; do
      cc::logger::debug "Calling exit hook $i"
#      >&2 printf "\n"
      "$i" "$ex" "$_CC_PV_ERR_CMD" "$_CC_PV_ERR_LNO" "$_CC_PV_ERR_STACK"
    done
  fi
  >&2 cc::console::reset
  >&2 printf "\n"
  cc::logger::debug "Exiting ($ex)"
  [ "$CC_ACTION_CAN_FAIL" == "true" ] && {
    [ "$ex" != "" ] || cc::logger::error "Action failed, but it is marked as 'can fail', so, exiting successfully"
    exit 0
  } || exit "$ex"
}

# Forking to disable xtrace when entering traps
cc::init::trap(){
  # Signals are caught by buildkit already - and only SIGKILL triggers a failure
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::err "$ex" "$LINENO" "$BASH_COMMAND" "${BASH_SOURCE[@]}"' ERR
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::exit "$ex"' EXIT
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# See https://manpages.ubuntu.com/manpages/xenial/man1/eatmydata.1.html
# Technically, we get a 10% speedup with apt operations for eg
# XXX careful here if this is going to be used in a chroot
cc::init::speedup(){
  ! command -v eatmydata >/dev/null || export LD_PRELOAD=libeatmydata.so
}

# Boot if we have an argument - otherwise, we are being sourced
if [ "$#" -gt 0 ]; then
  mkdir -p "$TMPDIR"
  rm -Rf "$CC_TMPFS"/.codecomet
  mkdir -p "$CC_TMPFS"/.codecomet/bin
  mkdir -p "$CC_TMPFS"/.codecomet/logs

  # Set logger to env var from the Bash helper
  cc::logger::level::set "$CC_LOG_LEVEL"

  # Eat data, trap, register tracer, register debugger on exit trap
  cc::init::speedup
  cc::init::trap
  cc::init::tracer
  # Live debugger is really wonky
  if [ "${CC_DEBUGGER_LIVE:-}" != "" ]; then
    cc::debugger::live &
    dc::trap::register cc::debugger::front
  else
    [ "$CC_ACTION_CAN_FAIL" == true ] || dc::trap::register cc::debugger::start
  fi

  # XXX technically, we receive a bunch of scripts, and we could just play them all - use case is not completely clear yet
  out="$CC_TMPFS"/.codecomet/logs/stdout.log
  err="$CC_TMPFS"/.codecomet/logs/stderr.log

  # Unpack libraries path and source them
  while [ "$#" -gt 1 ]; do
    cp "$1" "$CC_TMPFS"/.codecomet/bin
    # shellcheck disable=SC1090
    source "$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
    shift
  done
  cp "$1" "$CC_TMPFS"/.codecomet/bin
  _CC_PV_SCRIPT="$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
  export _CC_PV_SCRIPT

  # Run the actual action
  # shellcheck disable=SC1090
  source "$_CC_PV_SCRIPT" > >(tee -a "$out") 2> >(tee -a "$err" >&2)
else
  # If we are a library, toss this one so we do not exit on any error...
  # This is especially important for the reverse debugger
  set +o errexit
fi
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
â"Ûˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*◊
/library0.sh¿∏#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# A generic lock mechanism that supports exclusive locks, shared locks, and a simplistic queueing mechanism
_cc_lockindex=9
_cc_lock_location="/_cc/share/locks"

# Sets our locks location. Must be called to guarantee that the lock location exist.
cc::lock::init(){
	_cc_lock_location="${1:-.}"
	mkdir -p "${_cc_lock_location}"
}

# Acquire a lock with a given name, and a share mode (shared or exclusive (which is the default))
# If the lock is already acquired in a different mode, or the mode is exclusive, the function will wait until the lock is released.
# Return the lock id that you need to carry around to release the lock later on.
cc::lock::acquire(){
	local lockfile="$_cc_lock_location/$1"
	local shared="${2:-}"
	[ "$shared" ] && shared=-s || shared=-x
	_cc_lockindex=$((_cc_lockindex+1))
	mkdir -p "$(dirname "$lockfile")"
	exec {_cc_lockindex}>"$lockfile"
	flock $shared $_cc_lockindex
	return $_cc_lockindex
}

# Release a previously acquire lock by its id
cc::lock::release(){
	local idx="$1"
	# This is essentially the same
	flock -u "$idx"
	# exec {idx}>&-
}

cc::lock::queue(){
	local basepath="${1:-.}"
	local shared1="${2:-}"
	local shared2="${3:-}"
	local qid
	local oid

	# Get into the queue first
	cc::lock::acquire "$basepath"/cc_queue.lock "$shared1" || qid=$?

	# Then when out of the queue, acquire an operation lock
	cc::lock::acquire "$basepath"/cc_op.lock "$shared2" || oid=$?

	# Now, leave the queue
	cc::lock::release $qid

	# Return the lock id
	return $oid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
˙"‰·ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*»
/library1.sh¿©#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Lessons learned:
# - find -exec is VERY SLOW - better off piping to read (almost 10x) (0.2 second vs 0.02 second for about 200 files)
# - then globbing and grepping is faster than find + read
# This matters not in case we are copying a large amount of data of course, but then
# - there is no way to get something stable out of ls without further processing - directories with different owners
# for eg will widen some columns
# this "works" right now (if we do not use --numeric-uid-gid) but will be problematic outside of this specific case

_cc::fingerprint(){
  local directory="$1"
  # Will fail if the directory is empty, so the guardrail
  # Ignore directories, links, and "total" (note: -d will not work for that)
  # --numeric-uid-gid < messes up the output width
  # shellcheck disable=SC2010
  ls --full-time --almost-all --ignore lock "$directory" 2>/dev/null | grep -v "^[d|l|t]" || true
}

# Copy or symlink data "from" storage "to" destination
# This assume that storage holds only files, and no lock
# Will not copy anything if there is no difference
cc::storage::retrieve(){
  local from="$1"
  local to="$2"
  local copy="${3:-}"
  local lid
  local fromState

  # Ensure destination exists
  mkdir -p "$to"

  # Lock origin and keep the lock id
  cc::lock::acquire "$from" shared || lid=$?

  # Ensure origin exists
  mkdir -p "$from"

  # If we are asked to copy (not expected for large amount of data - linking is prefered in that case)
  if [ "$copy" ]; then
    # Retrieve the state of it
    fromState="$(_cc::fingerprint "$from")"

    # Check that we have content in storage
    # Check that we have a difference between storage and destination (ignoring directories and lock file)
    # shellcheck disable=SC2010
    # shellcheck disable=SC2015
    [ "$fromState" ] && [ "$fromState" != "$(_cc::fingerprint "$to")" ] && {
      # Then cleanup destination
      rm -Rf "$to"
      mkdir -p "$to"
      # And copy over
      cp -p "$from"/* "$to"
      # Slower
      #find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
      #  cp -p "$fd" "$to"
      #done
    } || {
      # Otherwise, do nothing
      cc::logger::debug "Nothing to retrieve from storage"
    }
  else
    # We want links, so, lets check we have anything in the origin
    #[ ! "$fromState" ] || {
    # Get rid of possibly remaining files in our destination
    find "$to" -type f -delete
    ln -sf "$from"/* "$to" 2>/dev/null || true
    # Note: below is slower
    # find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
    #  ln -s "$fd" "$to"
    # done
    #}
  fi

  # Release the lock
	cc::lock::release $lid
}

cc::storage::store(){
  local from="$1"
  local to="$2"
  local erase="${3:-}"
  local lid
  local fd
  local toState

  # Ensure origin exists
  mkdir -p "$from"

  # Lock destination and keep the lock id
  cc::lock::acquire "$to" "" || lid=$?

  # Ensure destination exists
  mkdir -p "$to"
  # Retrieve the state of it
  # shellcheck disable=SC2010
  toState="$(_cc::fingerprint "$to")"

  # Compare state of the destination with the origin (origin ignores directories and lock files)
  # shellcheck disable=SC2010
  # shellcheck disable=SC2015
  [ "$toState" != "$(_cc::fingerprint "$from")" ] && {
    # We have changes - if asked to wipe out, do so
    if [ "$erase" ]; then
      rm -Rf "$to"
      mkdir -p "$to"
    fi
    # Now copy the files
    # This is probably slow-ish. The question is: will it be significant in a context where copy IO is the bottleneck?
    find "$from" -type f -not -iname "lock" -print0 | while IFS= read -r -d $'\0' fd; do
      cp -p "$fd" "$to"
    done
  } || {
    cc::logger::debug "Nothing to save to storage"
  }

  # Release the lock
	cc::lock::release $lid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
Ï*"÷*”*ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∫*
/library2.sh¿õ*#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Helpers to allow apt to share cache properly

# Private tmpfs location
_cc_tmpfs_location=/codecomet/apt-get-private/tmp

# Location of the list cache
_cc_apt_list_store_location=/codecomet/apt-get-shared/lists
# And pack cache
_cc_apt_pack_local_location=/codecomet/apt-get-shared/packs

# Location of the packages cache
_cc_apt_pack_store_location=/codecomet/apt-get-shared/cache

# Location of our private lists files - by default, Debian normal location, which means state will persist
_cc_apt_list_local_location=/var/lib/apt/lists

# Location of the config file
export APT_CONFIG=$_cc_tmpfs_location/apt-get.conf

# Hash of the sources.list, which dictates the cache location to share
# Different sources means different cache location
# Caveats: this will likely not work with a future debian release as they change the sources.list format
# XXX this wracking the debugger output
cc::apt_get::shard(){
  sha256sum <<< "$(uname -m)$(grep --no-filename -Ev "^#" /etc/apt/sources.list /etc/apt/sources.list.d/* 2>/dev/null | sed -E 's/#.+$//' | sort || true)" | sed -E 's/  .*//'
}

# Set the tmp location, initiliaze APT_CONFIG and shared and private locations
cc::apt_get::init(){
  # Get the desired tmpfs mount point
  _cc_tmpfs_location="$1"

  mkdir -p "$_cc_tmpfs_location"

  # Point configuration there
  export APT_CONFIG="$_cc_tmpfs_location"/apt-get.conf

  # Sharding by sources list content, cleaned-up and sorted to maximize cache hits
	_cc_apt_list_store_location="$2/$(cc::apt_get::shard)"

  # Technically, we should not be sharding the architecture
  # But then, the only upside would be when installing cross-arch packages
	_cc_apt_pack_store_location="$3/$(cc::apt_get::shard)"

  # If we do not want lists to persist, use the tmp storage
  [ "${4:-}" == true ] || _cc_apt_list_local_location="$_cc_tmpfs_location"/lists

  # Finally, local pack location
  _cc_apt_pack_local_location="$_cc_tmpfs_location"/packs

  # Make sure they all exist
  mkdir -p "$_cc_apt_list_local_location"
  mkdir -p "$_cc_apt_pack_local_location"

  mkdir -p "$_cc_apt_list_store_location"
  mkdir -p "$_cc_apt_pack_store_location"
}

# Create the configuration file for APT
cc::apt_get::configure(){
  local config_extra="${1:-}"
  local persist="${2:-}"

  mkdir -p "$_cc_tmpfs_location/logs"
  cat << EOF > "$APT_CONFIG"
# Divert both lists and archives location
Dir::Cache::Archives "$_cc_apt_pack_local_location";
Dir::State::Lists "$_cc_apt_list_local_location";
# Prevent the default apt config to be used
Dir::Etc::parts "";
# Put the logs in the tmp zone
Dir::Log "$_cc_tmpfs_location/logs";
# Put the bin cache files in the private mount
Dir::Cache::srcpkgcache "$_cc_tmpfs_location/srcpkgcache.bin";
Dir::Cache::pkgcache "$_cc_tmpfs_location/pkgcache.bin";

$config_extra
EOF

  # If asked to persist the config, copy over the generated file
  [ "$persist" == "false" ] || cp "$APT_CONFIG" /etc/apt/apt.conf
}

#cc::apt_get::cleanup(){
  # This is only necessary if we were not using an tmpfs mount...
  # rm "$APT_CONFIG"
#}

cc::apt_get::update(){
  # Remove our marker if here
  rm -f "$_cc_apt_list_local_location"/.cc_updated

  # Retrieve existing data
  cc::storage::retrieve "$_cc_apt_list_store_location" "$_cc_apt_list_local_location" copy

	# Do the deed, same restriction applies
	apt-get update "$@"

  # Save it back (storage will decide)
  cc::storage::store "$_cc_apt_list_local_location" "$_cc_apt_list_store_location" erase

  # Now, flag it
  date > "$_cc_apt_list_local_location"/.cc_updated
}

cc::apt_get::do(){
  # Bring in any cache
  cc::storage::retrieve "$_cc_apt_pack_store_location" "$_cc_apt_pack_local_location"

	apt-get "$@"

  # Store the packages permanently
  cc::storage::store "$_cc_apt_pack_local_location" "$_cc_apt_pack_store_location"
}

# XXX what if sources are being modified, or config, or something else that materially impacts update?
cc::high::update(){
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "$nooutput"

  args+=("$@")
  time cc::apt_get::update "${args[@]}"
}

cc::high::install(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists has been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  args+=("$@")
  time cc::apt_get::do install "${args[@]}"
}

cc::high::upgrade(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists have been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  # ls -lAR "$_cc_tmpfs_location"/packs || true
  # time cc::apt_get::do upgrade "$nooutput" "$@"

  # XXX WIP here
  # Bust cache - delete this
  #time cc::apt_get::do upgrade --download-only "$nooutput" "$@"
  #time cc::apt_get::do upgrade --no-download "$nooutput" "$@"
  args+=("$@")
  time cc::apt_get::do upgrade "${args[@]}"
}

cc::high::purge(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")

  args+=("$@")
  time cc::apt_get::do purge --auto-remove "${args[@]}"
}(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
’"øºˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*£

/action.sh¿Ü#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::upgrade

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f7942
 



Z 
•
I
Gsha256:1fbbc4badd25a127fd4fadc9695046d27c048e2401041b62bedf36d229e45f77
I
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
armlinuxv7Z 
Í"‘—ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∏

/action.sh¿õ#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::install eatmydata nano socat

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c2
 



Z 
•
I
Gsha256:55ec848cf7d65106bee358f2ac6a5bba29563bf30924f0ee03dac01e2cbbc43e
I
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
armlinuxv7Z 
K
I
Gsha256:7d56e94b3beb356751a3e6f559295c2e360361498efd4103e6dd6dc5063a8e84Ë
Gsha256:1fbbc4badd25a127fd4fadc9695046d27c048e2401041b62bedf36d229e45f77ú!
codecomet.optest codecomet opG
llb.customname5[source:image] docker.io/library/debian:bullseye-slim*
source.image*
source.image.resolvemodeü
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library2.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library1.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupπ
Gsha256:55ec848cf7d65106bee358f2ac6a5bba29563bf30924f0ee03dac01e2cbbc43eÌ!
codecomet.optest codecomet op!
llb.customnameapt-get upgrade*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeŒ
Gsha256:7d56e94b3beb356751a3e6f559295c2e360361498efd4103e6dd6dc5063a8e84Ç!
codecomet.optest codecomet op6
llb.customname$apt-get install eatmydata nano socat*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeù
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962—!
codecomet.optest codecomet op0
llb.customname[action:addfile] codecomet in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupê
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edfƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library0.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupÄ
Gsha256:d8bbf2a7da2fc3ca36bc870ec340d424817c686cb2f622f469f5329d4532732b5*
constraints*
meta.description*
platformê
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8aƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupœ
K
Gsha256:1fbbc4badd25a127fd4fadc9695046d27c048e2401041b62bedf36d229e45f77 
K
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f 
K
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7 
K
Gsha256:55ec848cf7d65106bee358f2ac6a5bba29563bf30924f0ee03dac01e2cbbc43e 
K
Gsha256:7d56e94b3beb356751a3e6f559295c2e360361498efd4103e6dd6dc5063a8e84 
K
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962 
K
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c 
K
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf 
K
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c 
K
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794 
K
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a 
fR
5docker-image://docker.io/library/debian:bullseye-slim
image.resolvemodepullR
amd64linuxZ 
æ›"ß›£›ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*â›

/codecomet¿Î‹#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Defines the supported color palette, and our color scheme
########################################################################################################################

# Supported color palette
readonly _CC_PV_COLOR_BLACK=0
readonly _CC_PV_COLOR_RED=1
readonly _CC_PV_COLOR_GREEN=2
readonly _CC_PV_COLOR_YELLOW=3
# shellcheck disable=SC2034
readonly _CC_PV_COLOR_BLUE=4
readonly _CC_PV_COLOR_MAGENTA=5
readonly _CC_PV_COLOR_CYAN=6
readonly _CC_PV_COLOR_WHITE=7

# Colors scheme definition - can evidently be customized at runtime by setting these variables to other values from the palette
export CC_COLOR_DEFAULT_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEFAULT_BACK="$_CC_PV_COLOR_BLACK"

export CC_COLOR_BODY="$_CC_PV_COLOR_WHITE"
export CC_COLOR_COMMENT="$_CC_PV_COLOR_CYAN"
export CC_COLOR_HUMPF="$_CC_PV_COLOR_MAGENTA"

# Logger
export CC_COLOR_ERROR_FRONT="$_CC_PV_COLOR_RED"
export CC_COLOR_ERROR_BACK="$_CC_PV_COLOR_WHITE"
export CC_COLOR_WARNING_FRONT="$_CC_PV_COLOR_YELLOW"
export CC_COLOR_WARNING_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_INFO_FRONT="$_CC_PV_COLOR_GREEN"
export CC_COLOR_INFO_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_DEBUG_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEBUG_BACK="$_CC_PV_COLOR_BLACK"

# Tracer
export CC_COLOR_TRACER_HUMPF="$_CC_PV_COLOR_GREEN"
export CC_COLOR_TRACER_COMMAND_LABEL="$_CC_PV_COLOR_BLUE"
export CC_COLOR_TRACER_OUTPUT_LABEL="$_CC_PV_COLOR_RED"
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provide helpers to print colorful text
#
# Depends on:
# defaults.sh
# colors.sh
########################################################################################################################

_cc_private::tput(){
  [ ! "$CC_CAP_HAS_TERM" ] || [ "$CC_CAP_NO_COLOR" != "" ] || tput "$@" 2>/dev/null || true
}

_cc_private::console::inline(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it and pad to 7 chars, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"
}

_cc_private::console(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-7s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    # Otherwise, just a plain front/back
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"

  # Restore console to default before we \n so that we do not leak over into BK timestamp display
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::error(){
  _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_ERROR_BACK" "error" "$@"
}

cc::console::warning(){
  _cc_private::console "$CC_COLOR_WARNING_FRONT" "$CC_COLOR_WARNING_BACK" "warning" "$@"
}

cc::console::info(){
  _cc_private::console "$CC_COLOR_INFO_FRONT" "$CC_COLOR_INFO_BACK" "info" "$@"
}

cc::console::debug(){
  _cc_private::console "$CC_COLOR_DEBUG_FRONT" "$CC_COLOR_DEBUG_BACK" "debug" "$@"
}

cc::console::body(){
  _cc_private::console "$CC_COLOR_BODY" "" "" "$@"
}

cc::console::comment(){
  _cc_private::console "$CC_COLOR_COMMENT" "" "" "$@"
}

cc::console::humpf(){
  _cc_private::console "$CC_COLOR_HUMPF" "" "" "$@"
}

cc::console::reset(){
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::end(){
  _cc_private::tput op
  printf "\n"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Debugger based on socat
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
# logger.sh
########################################################################################################################

# Fancy prompt adapted from https://github.com/pombadev/fancy-linux-prompt/blob/master/LICENSE under MIT License
__powerline() {
    # Unicode symbols
    readonly GIT_NEED_PULL_SYMBOL='‚á£'
    readonly GIT_NEED_PUSH_SYMBOL='‚á°'
    readonly PS_SYMBOL='ü™ê' # üêß‚òÑ'‚ñ∂‚èµ‚ñ∂‚èµ

    # Solarized colorscheme
    readonly BG_BLUE="\\[$(tput setab 4)\\]"
    readonly BG_COLOR5="\\[\\e[48;5;31m\\]"
    readonly BG_COLOR8="\\[\\e[48;5;161m\\]"
    readonly BG_GREEN="\\[$(tput setab 2)\\]"
    readonly BG_RED="\\[$(tput setab 1)\\]"
    readonly FG_BASE3="\\[$(tput setaf 15)\\]"
    readonly FG_BLUE="\\[$(tput setaf 4)\\]"
    readonly FG_COLOR1="\\[\\e[38;5;250m\\]"
    readonly FG_COLOR6="\\[\\e[38;5;31m\\]"
    readonly FG_COLOR9="\\[\\e[38;5;161m\\]"
    readonly FG_GREEN="\\[$(tput setaf 2)\\]"
    readonly FG_RED="\\[$(tput setaf 1)\\]"
    readonly RESET="\\[$(tput sgr0)\\]"

    __git_info() {
        # has a .git directory and a git binary
    	[ -d .git ] || command -v git >/dev/null || return 0

        local aheadN
        local behindN
        local branch
        local marks=""
        local stats

        # get current branch name or short SHA1 hash for detached head
        branch="$(git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --always 2>/dev/null)"
        [ -n "$branch" ] || return 0 # git branch not found

        # how many commits local branch is ahead/behind of remote?
        stats="$(git status --porcelain --branch | grep '^##' | grep -o '\[.\+\]$')"
        aheadN="$(echo "$stats" | grep -o 'ahead \d\+' | grep -o '\d\+')"
        behindN="$(echo "$stats" | grep -o 'behind \d\+' | grep -o '\d\+')"
        [ -n "$aheadN" ] && marks+=" $GIT_NEED_PUSH_SYMBOL$aheadN"
        [ -n "$behindN" ] && marks+=" $GIT_NEED_PULL_SYMBOL$behindN"

        # print the git branch segment without a trailing newline
        # branch is modified?
        if [ -n "$(git status --porcelain)" ]; then
            printf "%s" "${BG_COLOR8}‚ñ∂$RESET$BG_COLOR8 $branch$marks $FG_COLOR9"
        else
            printf "%s" "${BG_BLUE}‚ñ∂$RESET$BG_BLUE $branch$marks $RESET$FG_BLUE"
        fi
    }


    ps1() {
        # Check the exit code of the previous command and display different
        # colors in the prompt accordingly.
        if [ "$?" -eq 0 ]; then
            local BG_EXIT="$BG_GREEN"
            local FG_EXIT="$FG_GREEN"
        else
            local BG_EXIT="$BG_RED"
            local FG_EXIT="$FG_RED"
        fi

        PS1="$FG_COLOR1$BG_COLOR5 CodeComet \\w "
        PS1+="$RESET${FG_COLOR6}"
        PS1+="$(__git_info)"
        PS1+="$BG_EXIT‚ñ∂$RESET"
        PS1+="$BG_EXIT$FG_BASE3 ${PS_SYMBOL} ${RESET}${FG_EXIT}‚ñ∂${RESET} "
    }

    PROMPT_COMMAND=ps1
}

_cc_private::debugger::setup(){
  # Set-up PS1
  cat << EOF > "$CC_TMPFS"/.profile
# export PS1='\[\033[01;32m\]CodeComet\[\033[00m\] \w \$ '
alias l="ls -lA"
source ${BASH_SOURCE[0]}
umask 077
export LSCOLORS=exfxcxdxbxegedabagacad
export CLICOLOR=1

_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Welcome!" printf "You are now debugging your pipeline at the point it stopped.\n"
printf "\n"
#_cc_private::console::inline "$_CC_PV_COLOR_BLACK" "$_CC_PV_COLOR_BLACK" "         " printf ""
printf "Environment, pwd, and filesystem, are exactly as they were when the last action failed.\n"
printf "You can call the following helpers:\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdout" printf "will output your action stdout\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stderr" printf "will output your action stderr\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdex " printf "will output your action exit code\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_action" printf "will output the location of your action script\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Tip           " printf "If you want to re-run your action, just call \\\$(ccdebug_action)\n"

# touch "$CC_TMPFS/.codecomet/connected"
__powerline

EOF

  cat << EOF >> "$CC_TMPFS"/.inputrc
"\e[A": history-search-backward
"\e[B": history-search-forward
set show-all-if-ambiguous on
set completion-ignore-case on

EOF

}

# "on demand
# "Abnormal exit, with non zero grace:
# - start debugger repeatedly, with grace
# - once the other end exits, bail out

# "live", with non zero grace
# - start debugger, with infinity grace
# - if the other end was connected and exited, that is it, end of story
# - if the other end is still running, bring socat forward and wait for the end to exit
# - if there was no other end, we should branch back to the first scenario

# This is called on trap ERR, if a live debugger has been running, and will make a decision to bring it back forward and keep it alive,
# or to drop it
cc::debugger::front(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  cc::logger::debug "[debugger-front] socat is here"
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  cc::logger::debug "[debugger-front] grace is fine"


  # Debugger still live? Bail out if not
  jobs | grep -q -v Done || {
    cc::logger::debug "[debugger-front] no jobs detected. Bailing out."
    return 0
  }

  # Ok, it is live. Do we have a client?
  # XXX unfortunately, this does not work as expected... socat does start the process first, bash sources the files and create the stamp file...
  local lasttry
  local current
  lasttry="$(cat $CC_TMPFS/.codecomet/lasttry 2>/dev/null)" || true
  current="$(date +%s)"
  # The older an unconnected socat could be is 2 seconds - if greater than that, then we definitely have a client
  # However, it is possible that a client has been connected for less than 2 seconds (since socat call) when the failure happens,
  # which means the client will wrongly get the boot... no good solution right now
  [ $(( current - lasttry)) -gt 2 ] && {
  # [ -e "$CC_TMPFS/.codecomet/connected" ] && {
    cc::logger::debug "[debugger-front] we have a connected client"
    # Yes, then foreground and let it sit
    fg 2>/dev/null
  } || {
    cc::logger::debug "[debugger-front] no live client. Kick it out restart."
    # No live client. Kill it, and start again the normal process with timeout and message
    kill %%
    cc::debugger::start "$ex"
  }
}

# XXX this is largely broken
cc::debugger::live(){
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  while true; do
    lasttry="$(date +%s)"
    printf "%s" "$lasttry" > "$CC_TMPFS/.codecomet/lasttry"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-live] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Break if we have been hanging out more than a second (meaning the other end did connect, but exit in error)
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-live] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
    }
    x=$(( x + 1 ))
    cc::logger::debug "[debugger-live] sleeping"
    sleep 1
  done
}

cc::debugger::start(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  # Prep-up profile
  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  cc::logger::error "Abnormal exit code $ex. If you want to inspect manually, start codecomet-debugger. Otherwise, we will exit after $CC_DEBUGGER_GRACE seconds"
  cc::logger::error "You can also restart the build with CODECOMET_DEBUG=true"

  >&2 _cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "waiting" printf "Waiting %s seconds for debugger to connect" "$CC_DEBUGGER_GRACE"
  # cc::logger::warning "Waiting "


  # https://medium.com/@JAlblas/tryhackme-what-the-shell-walkthrough-6c0ebe8f854e
  #pty, allocates a pseudoterminal on the target ‚Äî part of the stabilisation process
  #stderr, makes sure that any error messages get shown in the shell (often a problem with non-interactive shells)
  #sigint, passes any Ctrl + C commands through into the sub-process, allowing us to kill commands inside the shell
  #setsid, creates the process in a new session
  #sane, stabilises the terminal, attempting to ‚Äúnormalise‚Äù it.

  while [ "$x" -lt "$CC_DEBUGGER_GRACE" ]; do
    lasttry="$(date +%s)"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-stat] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Timeing out means we wait for a second. Any more than that should mean the connection was succesful
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-stat] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
      >&2 printf "."
    }
    x=$(( x + 1 ))
    sleep 1
  done
}

ccdebug_stdout(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stdout.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stdout.log
  fi
}

ccdebug_stderr(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stderr.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stderr.log
  fi
}

ccdebug_stdex(){
  [ -e "$CC_TMPFS"/.codecomet/logs/ex.log ] && {
    cat "$CC_TMPFS"/.codecomet/logs/ex.log
  } || {
    cc::logger::warning "Action is in progress, no exit code yet"
  }
}

ccdebug_action(){
  echo "$_CC_PV_SCRIPT"
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# List all environment variables we depend on, possibly providing defaults
########################################################################################################################

#############
# Generic controls
#############
# Log level to start with (error, warning, info, debug or 4, 3, 2, 1, 0 <- mute)
readonly CC_LOG_LEVEL="${CC_LOG_LEVEL:-}"
# Where is the tempfs mounted
readonly CC_TMPFS="${CC_TMPFS:-}"
# Honors NO_COLOR (see https://no-color.org/)
# shellcheck disable=SC2034
readonly CC_CAP_NO_COLOR="${NO_COLOR:-}"
# About detection
# https://stackoverflow.com/questions/911168/how-can-i-detect-if-my-shell-script-is-running-through-a-pipe
# Could also test for [ ! -t 2 ]
# Or could be: `test -t 0` (formerly `tty -s`)
# In our context though, this probably does not matter much
# shellcheck disable=SC2034
readonly CC_CAP_HAS_TERM="${TERM:-}"

#############
# Action execution flow control
#############
# Whether the action can fail or not
readonly CC_ACTION_CAN_FAIL="${CC_ACTION_CAN_FAIL:-}"

#############
# Tracing and debugging
#############
# Controls wether the tracer will also trace internal codecomet library or hide them
readonly CC_TRACER_CODECOMET_INTERNALS="${CC_TRACER_CODECOMET_INTERNALS:-}"
# How long to wait for a connection before dropping the debugger
export CC_DEBUGGER_GRACE="${CC_DEBUGGER_GRACE:-}"
# Port to connect to
readonly CC_DEBUGGER_PORT="${CC_DEBUGGER_PORT:-}"
# IP to connect to
readonly CC_DEBUGGER_IP="${CC_DEBUGGER_IP:-}"
# Whether a debugger should be started pre-emptively so that one can hook in "live" during the action. This is very wonky as soon as you have parallelism...
readonly CC_DEBUGGER_LIVE="${CC_DEBUGGER_LIVE:-}"


#############
# Error code used accross the codebase - rn, only the bland FAILED is used...
#############
# shellcheck disable=SC2034
readonly ERROR_NETWORK=200
# Thrown if a required argument is missing
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_MISSING=201
# Thrown if an argument does not match validation
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_INVALID=202
# Should be used to convey that a certain operation is not supported
# shellcheck disable=SC2034
readonly ERROR_UNSUPPORTED=203
# Generic error to denote that the operation has failed. More specific errors may be provided instead
# shellcheck disable=SC2034
readonly ERROR_FAILED=204
# Expectations failed on a file (not readable, writable, doesn't exist, can't be created)
# shellcheck disable=SC2034
readonly ERROR_FILESYSTEM=205
# System requirements
# shellcheck disable=SC2034
readonly ERROR_MISSING_REQUIREMENTS=206

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# A generic logger
#
# Depends on:
# console.sh
########################################################################################################################

readonly CC_LOGGER_DEBUG=4
readonly CC_LOGGER_INFO=3
readonly CC_LOGGER_WARNING=2
readonly CC_LOGGER_ERROR=1

_CC_PV_LOGGER_LEVEL="$CC_LOGGER_WARNING"

_cc_private::logger::log(){
  local prefix="$1"
  shift

  local level="CC_LOGGER_$prefix"
  local i

  [ "$_CC_PV_LOGGER_LEVEL" -ge "${!level}" ] || return 0

  # About the crazy shit: https://stackoverflow.com/questions/12674783/bash-double-process-substitution-gives-bad-file-descriptor
  exec 3>&2
  for i in "$@"; do
    >&2 cc::console::"$(printf "$prefix" | tr '[:upper:]' '[:lower:]')" printf "$i"
  done
  exec 3>&-
}

cc::logger::level::set() {
  local level
  level="$(printf "%s" "${1:-}" | tr '[:upper:]' '[:lower:]')"

  case "$level" in
    ''|*[!0-9]*)
      case "$level" in
          "debug")
            _CC_PV_LOGGER_LEVEL=4
            ;;
          "info")
            _CC_PV_LOGGER_LEVEL=3
            ;;
          "warning")
            _CC_PV_LOGGER_LEVEL=2
            ;;
          "error")
            _CC_PV_LOGGER_LEVEL=1
            ;;
          "mute")
            _CC_PV_LOGGER_LEVEL=0
            ;;
          *)
            _CC_PV_LOGGER_LEVEL=3
            ;;
      esac
      ;;
    *)
      if [ "$level" -gt "$CC_LOGGER_DEBUG" ]; then
        return "$ERROR_FAILED"
      fi
      _CC_PV_LOGGER_LEVEL="$level"
      ;;
  esac

  [ "$_CC_PV_LOGGER_LEVEL" != "$CC_LOGGER_DEBUG" ] || {
    cc::console::warning printf "YOU ARE LOGGING AT THE DEBUG LEVEL."
    cc::console::warning printf "This is NOT recommended for production use, and WILL LIKELY LEAK sensitive information to logs."
  }
}

# Sugar
cc::logger::level::set::debug(){
  cc::logger::level::set "$CC_LOGGER_DEBUG"
}

cc::logger::level::set::info(){
  cc::logger::level::set "$CC_LOGGER_INFO"
}

cc::logger::level::set::warning(){
  cc::logger::level::set "$CC_LOGGER_WARNING"
}

cc::logger::level::set::error(){
  cc::logger::level::set "$CC_LOGGER_ERROR"
}

cc::logger::mute() {
  _CC_PV_LOGGER_LEVEL=0
}

cc::logger::ismute() {
  [ "$_CC_PV_LOGGER_LEVEL" == 0 ] || return "$ERROR_FAILED"
}

cc::logger::debug(){
  _cc_private::logger::log "DEBUG" "$@"
}

cc::logger::info(){
  _cc_private::logger::log "INFO" "$@"
}

cc::logger::warning(){
  _cc_private::logger::log "WARNING" "$@"
}

cc::logger::error(){
  _cc_private::logger::log "ERROR" "$@"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provides fancy display for `set -x`
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
########################################################################################################################

cc::codecomet::tracer(){
  local length="${#BASH_SOURCE[@]}"

  #local indent=""
  local linenumber
  local filename
  local filecontent
  local funcname
  local col

  [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[1]}" == *"action.sh" ]] || return 0

  printf "\n"

  for (( j=$(( length - 1 )); j>0; j-- )); do
    [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[$j]}" == *"action.sh" ]] || {
      continue
    }

    linenumber="${BASH_LINENO[$(( j - 1 ))]}"
    filename="${BASH_SOURCE[$j]}"
    filecontent="$(cat -n "$filename" | grep -E "^\s+$linenumber\s" | sed -E "s/^\s+$linenumber\s+//")"
    funcname="${FUNCNAME[$j]}"

    # Why is this showing is a mystery for the times
    # [ "$filecontent" != "#!/usr/bin/env bash" ] || continue

    [ "$j" != 1 ] && {
      col="$CC_COLOR_DEFAULT_FRONT"
    } || {
      col="$CC_COLOR_TRACER_HUMPF"
    }

    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$filename"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$linenumber"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "function" printf "%-30s" "$funcname()"
    printf "\n"
    [ "$j" != 1 ] || {
      _cc_private::console "$CC_COLOR_TRACER_COMMAND_LABEL" "$CC_COLOR_DEFAULT_FRONT" "command" printf "%s" "$filecontent"
      _cc_private::console "$CC_COLOR_TRACER_OUTPUT_LABEL" "$CC_COLOR_DEFAULT_FRONT" "output" printf ""
    }

  done
}

cc::tracer::register(){
  # shellcheck disable=SC2016
  local ps=('$(' "$@" ')')
  export PS4="${ps[*]}"
}

cc::init::tracer(){
  cc::tracer::register cc::codecomet::tracer
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Trap management
#
# Depends on:
# colors.sh
# console.sh
########################################################################################################################

_CC_PV_TRAP_LISTENERS=()

_CC_PV_ERR_LNO=
_CC_PV_ERR_CMD=
_CC_PV_ERR_STACK=
_CC_PV_ERR_EX=

dc::trap::register(){
  _CC_PV_TRAP_LISTENERS+=( "$1" )
}

# Trap lno and cmd on ERR for future use
cc::trap::err(){
  _CC_PV_ERR_EX="$1"
  _CC_PV_ERR_LNO="$2"
  _CC_PV_ERR_CMD="$3"
  _CC_PV_ERR_STACK="$4"
  # Dropping the rest of the stack?

  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$_CC_PV_ERR_STACK"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$_CC_PV_ERR_LNO"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "exit" printf "%s" "$_CC_PV_ERR_EX"
  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "command" printf "%-30s" "$_CC_PV_ERR_CMD"
  >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  >&2 printf "\n"

  >&2 _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "source" printf ""
  prefix=" "
  for (( j=$(( _CC_PV_ERR_LNO - 3 )); j<$(( _CC_PV_ERR_LNO + 3 )); j++ )); do
    [ "$j" -gt 0 ] || continue
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=">"
      >&2 _cc_private::tput setaf "$CC_COLOR_ERROR_FRONT"
      #>&2 _cc_private::tput bold
    fi
    #  | sed -E "s/^\s+$j\s//"
    >&2 printf "%s%s" "$prefix" "$(cat -n "$_CC_PV_ERR_STACK" | grep -E "^\s+$j\s")" || true
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=" "
      >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
      #>&2 _cc_private::tput sgr0
    fi
    >&2 printf "\n"
  done
}

_CC_PV_NO_REENTRY=

# Trap exit for the actual cleanup
cc::trap::exit() {
  # { set +x; } 2>/dev/null

  local ex="$1"
  local i

  # Prevent reentrancy - XXX is this actually needed?
  [ ! "$_CC_PV_NO_REENTRY" ] || return 0
  _CC_PV_NO_REENTRY="exiting"

  printf "%s\n" "$ex" > "$CC_TMPFS"/.codecomet/logs/ex.log

  if [ "${#_CC_PV_TRAP_LISTENERS[@]}" -gt 0 ]; then
    for i in "${_CC_PV_TRAP_LISTENERS[@]}"; do
      cc::logger::debug "Calling exit hook $i"
#      >&2 printf "\n"
      "$i" "$ex" "$_CC_PV_ERR_CMD" "$_CC_PV_ERR_LNO" "$_CC_PV_ERR_STACK"
    done
  fi
  >&2 cc::console::reset
  >&2 printf "\n"
  cc::logger::debug "Exiting ($ex)"
  [ "$CC_ACTION_CAN_FAIL" == "true" ] && {
    [ "$ex" != "" ] || cc::logger::error "Action failed, but it is marked as 'can fail', so, exiting successfully"
    exit 0
  } || exit "$ex"
}

# Forking to disable xtrace when entering traps
cc::init::trap(){
  # Signals are caught by buildkit already - and only SIGKILL triggers a failure
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::err "$ex" "$LINENO" "$BASH_COMMAND" "${BASH_SOURCE[@]}"' ERR
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::exit "$ex"' EXIT
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# See https://manpages.ubuntu.com/manpages/xenial/man1/eatmydata.1.html
# Technically, we get a 10% speedup with apt operations for eg
# XXX careful here if this is going to be used in a chroot
cc::init::speedup(){
  ! command -v eatmydata >/dev/null || export LD_PRELOAD=libeatmydata.so
}

# Boot if we have an argument - otherwise, we are being sourced
if [ "$#" -gt 0 ]; then
  mkdir -p "$TMPDIR"
  rm -Rf "$CC_TMPFS"/.codecomet
  mkdir -p "$CC_TMPFS"/.codecomet/bin
  mkdir -p "$CC_TMPFS"/.codecomet/logs

  # Set logger to env var from the Bash helper
  cc::logger::level::set "$CC_LOG_LEVEL"

  # Eat data, trap, register tracer, register debugger on exit trap
  cc::init::speedup
  cc::init::trap
  cc::init::tracer
  # Live debugger is really wonky
  if [ "${CC_DEBUGGER_LIVE:-}" != "" ]; then
    cc::debugger::live &
    dc::trap::register cc::debugger::front
  else
    [ "$CC_ACTION_CAN_FAIL" == true ] || dc::trap::register cc::debugger::start
  fi

  # XXX technically, we receive a bunch of scripts, and we could just play them all - use case is not completely clear yet
  out="$CC_TMPFS"/.codecomet/logs/stdout.log
  err="$CC_TMPFS"/.codecomet/logs/stderr.log

  # Unpack libraries path and source them
  while [ "$#" -gt 1 ]; do
    cp "$1" "$CC_TMPFS"/.codecomet/bin
    # shellcheck disable=SC1090
    source "$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
    shift
  done
  cp "$1" "$CC_TMPFS"/.codecomet/bin
  _CC_PV_SCRIPT="$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
  export _CC_PV_SCRIPT

  # Run the actual action
  # shellcheck disable=SC1090
  source "$_CC_PV_SCRIPT" > >(tee -a "$out") 2> >(tee -a "$err" >&2)
else
  # If we are a library, toss this one so we do not exit on any error...
  # This is especially important for the reverse debugger
  set +o errexit
fi
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
â"Ûˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*◊
/library0.sh¿∏#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# A generic lock mechanism that supports exclusive locks, shared locks, and a simplistic queueing mechanism
_cc_lockindex=9
_cc_lock_location="/_cc/share/locks"

# Sets our locks location. Must be called to guarantee that the lock location exist.
cc::lock::init(){
	_cc_lock_location="${1:-.}"
	mkdir -p "${_cc_lock_location}"
}

# Acquire a lock with a given name, and a share mode (shared or exclusive (which is the default))
# If the lock is already acquired in a different mode, or the mode is exclusive, the function will wait until the lock is released.
# Return the lock id that you need to carry around to release the lock later on.
cc::lock::acquire(){
	local lockfile="$_cc_lock_location/$1"
	local shared="${2:-}"
	[ "$shared" ] && shared=-s || shared=-x
	_cc_lockindex=$((_cc_lockindex+1))
	mkdir -p "$(dirname "$lockfile")"
	exec {_cc_lockindex}>"$lockfile"
	flock $shared $_cc_lockindex
	return $_cc_lockindex
}

# Release a previously acquire lock by its id
cc::lock::release(){
	local idx="$1"
	# This is essentially the same
	flock -u "$idx"
	# exec {idx}>&-
}

cc::lock::queue(){
	local basepath="${1:-.}"
	local shared1="${2:-}"
	local shared2="${3:-}"
	local qid
	local oid

	# Get into the queue first
	cc::lock::acquire "$basepath"/cc_queue.lock "$shared1" || qid=$?

	# Then when out of the queue, acquire an operation lock
	cc::lock::acquire "$basepath"/cc_op.lock "$shared2" || oid=$?

	# Now, leave the queue
	cc::lock::release $qid

	# Return the lock id
	return $oid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
˙"‰·ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*»
/library1.sh¿©#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Lessons learned:
# - find -exec is VERY SLOW - better off piping to read (almost 10x) (0.2 second vs 0.02 second for about 200 files)
# - then globbing and grepping is faster than find + read
# This matters not in case we are copying a large amount of data of course, but then
# - there is no way to get something stable out of ls without further processing - directories with different owners
# for eg will widen some columns
# this "works" right now (if we do not use --numeric-uid-gid) but will be problematic outside of this specific case

_cc::fingerprint(){
  local directory="$1"
  # Will fail if the directory is empty, so the guardrail
  # Ignore directories, links, and "total" (note: -d will not work for that)
  # --numeric-uid-gid < messes up the output width
  # shellcheck disable=SC2010
  ls --full-time --almost-all --ignore lock "$directory" 2>/dev/null | grep -v "^[d|l|t]" || true
}

# Copy or symlink data "from" storage "to" destination
# This assume that storage holds only files, and no lock
# Will not copy anything if there is no difference
cc::storage::retrieve(){
  local from="$1"
  local to="$2"
  local copy="${3:-}"
  local lid
  local fromState

  # Ensure destination exists
  mkdir -p "$to"

  # Lock origin and keep the lock id
  cc::lock::acquire "$from" shared || lid=$?

  # Ensure origin exists
  mkdir -p "$from"

  # If we are asked to copy (not expected for large amount of data - linking is prefered in that case)
  if [ "$copy" ]; then
    # Retrieve the state of it
    fromState="$(_cc::fingerprint "$from")"

    # Check that we have content in storage
    # Check that we have a difference between storage and destination (ignoring directories and lock file)
    # shellcheck disable=SC2010
    # shellcheck disable=SC2015
    [ "$fromState" ] && [ "$fromState" != "$(_cc::fingerprint "$to")" ] && {
      # Then cleanup destination
      rm -Rf "$to"
      mkdir -p "$to"
      # And copy over
      cp -p "$from"/* "$to"
      # Slower
      #find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
      #  cp -p "$fd" "$to"
      #done
    } || {
      # Otherwise, do nothing
      cc::logger::debug "Nothing to retrieve from storage"
    }
  else
    # We want links, so, lets check we have anything in the origin
    #[ ! "$fromState" ] || {
    # Get rid of possibly remaining files in our destination
    find "$to" -type f -delete
    ln -sf "$from"/* "$to" 2>/dev/null || true
    # Note: below is slower
    # find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
    #  ln -s "$fd" "$to"
    # done
    #}
  fi

  # Release the lock
	cc::lock::release $lid
}

cc::storage::store(){
  local from="$1"
  local to="$2"
  local erase="${3:-}"
  local lid
  local fd
  local toState

  # Ensure origin exists
  mkdir -p "$from"

  # Lock destination and keep the lock id
  cc::lock::acquire "$to" "" || lid=$?

  # Ensure destination exists
  mkdir -p "$to"
  # Retrieve the state of it
  # shellcheck disable=SC2010
  toState="$(_cc::fingerprint "$to")"

  # Compare state of the destination with the origin (origin ignores directories and lock files)
  # shellcheck disable=SC2010
  # shellcheck disable=SC2015
  [ "$toState" != "$(_cc::fingerprint "$from")" ] && {
    # We have changes - if asked to wipe out, do so
    if [ "$erase" ]; then
      rm -Rf "$to"
      mkdir -p "$to"
    fi
    # Now copy the files
    # This is probably slow-ish. The question is: will it be significant in a context where copy IO is the bottleneck?
    find "$from" -type f -not -iname "lock" -print0 | while IFS= read -r -d $'\0' fd; do
      cp -p "$fd" "$to"
    done
  } || {
    cc::logger::debug "Nothing to save to storage"
  }

  # Release the lock
	cc::lock::release $lid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
Ï*"÷*”*ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∫*
/library2.sh¿õ*#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Helpers to allow apt to share cache properly

# Private tmpfs location
_cc_tmpfs_location=/codecomet/apt-get-private/tmp

# Location of the list cache
_cc_apt_list_store_location=/codecomet/apt-get-shared/lists
# And pack cache
_cc_apt_pack_local_location=/codecomet/apt-get-shared/packs

# Location of the packages cache
_cc_apt_pack_store_location=/codecomet/apt-get-shared/cache

# Location of our private lists files - by default, Debian normal location, which means state will persist
_cc_apt_list_local_location=/var/lib/apt/lists

# Location of the config file
export APT_CONFIG=$_cc_tmpfs_location/apt-get.conf

# Hash of the sources.list, which dictates the cache location to share
# Different sources means different cache location
# Caveats: this will likely not work with a future debian release as they change the sources.list format
# XXX this wracking the debugger output
cc::apt_get::shard(){
  sha256sum <<< "$(uname -m)$(grep --no-filename -Ev "^#" /etc/apt/sources.list /etc/apt/sources.list.d/* 2>/dev/null | sed -E 's/#.+$//' | sort || true)" | sed -E 's/  .*//'
}

# Set the tmp location, initiliaze APT_CONFIG and shared and private locations
cc::apt_get::init(){
  # Get the desired tmpfs mount point
  _cc_tmpfs_location="$1"

  mkdir -p "$_cc_tmpfs_location"

  # Point configuration there
  export APT_CONFIG="$_cc_tmpfs_location"/apt-get.conf

  # Sharding by sources list content, cleaned-up and sorted to maximize cache hits
	_cc_apt_list_store_location="$2/$(cc::apt_get::shard)"

  # Technically, we should not be sharding the architecture
  # But then, the only upside would be when installing cross-arch packages
	_cc_apt_pack_store_location="$3/$(cc::apt_get::shard)"

  # If we do not want lists to persist, use the tmp storage
  [ "${4:-}" == true ] || _cc_apt_list_local_location="$_cc_tmpfs_location"/lists

  # Finally, local pack location
  _cc_apt_pack_local_location="$_cc_tmpfs_location"/packs

  # Make sure they all exist
  mkdir -p "$_cc_apt_list_local_location"
  mkdir -p "$_cc_apt_pack_local_location"

  mkdir -p "$_cc_apt_list_store_location"
  mkdir -p "$_cc_apt_pack_store_location"
}

# Create the configuration file for APT
cc::apt_get::configure(){
  local config_extra="${1:-}"
  local persist="${2:-}"

  mkdir -p "$_cc_tmpfs_location/logs"
  cat << EOF > "$APT_CONFIG"
# Divert both lists and archives location
Dir::Cache::Archives "$_cc_apt_pack_local_location";
Dir::State::Lists "$_cc_apt_list_local_location";
# Prevent the default apt config to be used
Dir::Etc::parts "";
# Put the logs in the tmp zone
Dir::Log "$_cc_tmpfs_location/logs";
# Put the bin cache files in the private mount
Dir::Cache::srcpkgcache "$_cc_tmpfs_location/srcpkgcache.bin";
Dir::Cache::pkgcache "$_cc_tmpfs_location/pkgcache.bin";

$config_extra
EOF

  # If asked to persist the config, copy over the generated file
  [ "$persist" == "false" ] || cp "$APT_CONFIG" /etc/apt/apt.conf
}

#cc::apt_get::cleanup(){
  # This is only necessary if we were not using an tmpfs mount...
  # rm "$APT_CONFIG"
#}

cc::apt_get::update(){
  # Remove our marker if here
  rm -f "$_cc_apt_list_local_location"/.cc_updated

  # Retrieve existing data
  cc::storage::retrieve "$_cc_apt_list_store_location" "$_cc_apt_list_local_location" copy

	# Do the deed, same restriction applies
	apt-get update "$@"

  # Save it back (storage will decide)
  cc::storage::store "$_cc_apt_list_local_location" "$_cc_apt_list_store_location" erase

  # Now, flag it
  date > "$_cc_apt_list_local_location"/.cc_updated
}

cc::apt_get::do(){
  # Bring in any cache
  cc::storage::retrieve "$_cc_apt_pack_store_location" "$_cc_apt_pack_local_location"

	apt-get "$@"

  # Store the packages permanently
  cc::storage::store "$_cc_apt_pack_local_location" "$_cc_apt_pack_store_location"
}

# XXX what if sources are being modified, or config, or something else that materially impacts update?
cc::high::update(){
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "$nooutput"

  args+=("$@")
  time cc::apt_get::update "${args[@]}"
}

cc::high::install(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists has been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  args+=("$@")
  time cc::apt_get::do install "${args[@]}"
}

cc::high::upgrade(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists have been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  # ls -lAR "$_cc_tmpfs_location"/packs || true
  # time cc::apt_get::do upgrade "$nooutput" "$@"

  # XXX WIP here
  # Bust cache - delete this
  #time cc::apt_get::do upgrade --download-only "$nooutput" "$@"
  #time cc::apt_get::do upgrade --no-download "$nooutput" "$@"
  args+=("$@")
  time cc::apt_get::do upgrade "${args[@]}"
}

cc::high::purge(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")

  args+=("$@")
  time cc::apt_get::do purge --auto-remove "${args[@]}"
}(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
’"øºˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*£

/action.sh¿Ü#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::upgrade

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f7942
 



Z 
£
I
Gsha256:f65fec6162c8d70fc2311c3d20f1b6a91a87c9203547e280f276fe349ca18ac5
I
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
amd64linuxZ 
Í"‘—ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∏

/action.sh¿õ#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::install eatmydata nano socat

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c2
 



Z 
£
I
Gsha256:7a830e01dd5926f63eee241a37f13de580dac91af765ea3a0c027e5dc01a70b0
I
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
amd64linuxZ 
K
I
Gsha256:7675b821844b304f3dfa86c81f7648559f41024b3a59c7bda03b191a177910cdü
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library2.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library1.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupŒ
Gsha256:7675b821844b304f3dfa86c81f7648559f41024b3a59c7bda03b191a177910cdÇ!
codecomet.optest codecomet op6
llb.customname$apt-get install eatmydata nano socat*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeπ
Gsha256:7a830e01dd5926f63eee241a37f13de580dac91af765ea3a0c027e5dc01a70b0Ì!
codecomet.optest codecomet op!
llb.customnameapt-get upgrade*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeù
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962—!
codecomet.optest codecomet op0
llb.customname[action:addfile] codecomet in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupê
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edfƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library0.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupê
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8aƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupË
Gsha256:f65fec6162c8d70fc2311c3d20f1b6a91a87c9203547e280f276fe349ca18ac5ú!
codecomet.optest codecomet opG
llb.customname5[source:image] docker.io/library/debian:bullseye-slim*
source.image*
source.image.resolvemodeÄ
Gsha256:fe08b103bce4ea5603cb864c3b8f0394fee85e8253501e3a7d3fd8fc5b3008405*
constraints*
meta.description*
platformœ
K
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f 
K
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7 
K
Gsha256:7675b821844b304f3dfa86c81f7648559f41024b3a59c7bda03b191a177910cd 
K
Gsha256:7a830e01dd5926f63eee241a37f13de580dac91af765ea3a0c027e5dc01a70b0 
K
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962 
K
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c 
K
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf 
K
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c 
K
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794 
K
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a 
K
Gsha256:f65fec6162c8d70fc2311c3d20f1b6a91a87c9203547e280f276fe349ca18ac5 
fR
5docker-image://docker.io/library/debian:bullseye-slim
image.resolvemodepullR
arm64linuxZ 
æ›"ß›£›ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*â›

/codecomet¿Î‹#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Defines the supported color palette, and our color scheme
########################################################################################################################

# Supported color palette
readonly _CC_PV_COLOR_BLACK=0
readonly _CC_PV_COLOR_RED=1
readonly _CC_PV_COLOR_GREEN=2
readonly _CC_PV_COLOR_YELLOW=3
# shellcheck disable=SC2034
readonly _CC_PV_COLOR_BLUE=4
readonly _CC_PV_COLOR_MAGENTA=5
readonly _CC_PV_COLOR_CYAN=6
readonly _CC_PV_COLOR_WHITE=7

# Colors scheme definition - can evidently be customized at runtime by setting these variables to other values from the palette
export CC_COLOR_DEFAULT_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEFAULT_BACK="$_CC_PV_COLOR_BLACK"

export CC_COLOR_BODY="$_CC_PV_COLOR_WHITE"
export CC_COLOR_COMMENT="$_CC_PV_COLOR_CYAN"
export CC_COLOR_HUMPF="$_CC_PV_COLOR_MAGENTA"

# Logger
export CC_COLOR_ERROR_FRONT="$_CC_PV_COLOR_RED"
export CC_COLOR_ERROR_BACK="$_CC_PV_COLOR_WHITE"
export CC_COLOR_WARNING_FRONT="$_CC_PV_COLOR_YELLOW"
export CC_COLOR_WARNING_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_INFO_FRONT="$_CC_PV_COLOR_GREEN"
export CC_COLOR_INFO_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_DEBUG_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEBUG_BACK="$_CC_PV_COLOR_BLACK"

# Tracer
export CC_COLOR_TRACER_HUMPF="$_CC_PV_COLOR_GREEN"
export CC_COLOR_TRACER_COMMAND_LABEL="$_CC_PV_COLOR_BLUE"
export CC_COLOR_TRACER_OUTPUT_LABEL="$_CC_PV_COLOR_RED"
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provide helpers to print colorful text
#
# Depends on:
# defaults.sh
# colors.sh
########################################################################################################################

_cc_private::tput(){
  [ ! "$CC_CAP_HAS_TERM" ] || [ "$CC_CAP_NO_COLOR" != "" ] || tput "$@" 2>/dev/null || true
}

_cc_private::console::inline(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it and pad to 7 chars, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"
}

_cc_private::console(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-7s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    # Otherwise, just a plain front/back
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"

  # Restore console to default before we \n so that we do not leak over into BK timestamp display
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::error(){
  _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_ERROR_BACK" "error" "$@"
}

cc::console::warning(){
  _cc_private::console "$CC_COLOR_WARNING_FRONT" "$CC_COLOR_WARNING_BACK" "warning" "$@"
}

cc::console::info(){
  _cc_private::console "$CC_COLOR_INFO_FRONT" "$CC_COLOR_INFO_BACK" "info" "$@"
}

cc::console::debug(){
  _cc_private::console "$CC_COLOR_DEBUG_FRONT" "$CC_COLOR_DEBUG_BACK" "debug" "$@"
}

cc::console::body(){
  _cc_private::console "$CC_COLOR_BODY" "" "" "$@"
}

cc::console::comment(){
  _cc_private::console "$CC_COLOR_COMMENT" "" "" "$@"
}

cc::console::humpf(){
  _cc_private::console "$CC_COLOR_HUMPF" "" "" "$@"
}

cc::console::reset(){
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::end(){
  _cc_private::tput op
  printf "\n"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Debugger based on socat
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
# logger.sh
########################################################################################################################

# Fancy prompt adapted from https://github.com/pombadev/fancy-linux-prompt/blob/master/LICENSE under MIT License
__powerline() {
    # Unicode symbols
    readonly GIT_NEED_PULL_SYMBOL='‚á£'
    readonly GIT_NEED_PUSH_SYMBOL='‚á°'
    readonly PS_SYMBOL='ü™ê' # üêß‚òÑ'‚ñ∂‚èµ‚ñ∂‚èµ

    # Solarized colorscheme
    readonly BG_BLUE="\\[$(tput setab 4)\\]"
    readonly BG_COLOR5="\\[\\e[48;5;31m\\]"
    readonly BG_COLOR8="\\[\\e[48;5;161m\\]"
    readonly BG_GREEN="\\[$(tput setab 2)\\]"
    readonly BG_RED="\\[$(tput setab 1)\\]"
    readonly FG_BASE3="\\[$(tput setaf 15)\\]"
    readonly FG_BLUE="\\[$(tput setaf 4)\\]"
    readonly FG_COLOR1="\\[\\e[38;5;250m\\]"
    readonly FG_COLOR6="\\[\\e[38;5;31m\\]"
    readonly FG_COLOR9="\\[\\e[38;5;161m\\]"
    readonly FG_GREEN="\\[$(tput setaf 2)\\]"
    readonly FG_RED="\\[$(tput setaf 1)\\]"
    readonly RESET="\\[$(tput sgr0)\\]"

    __git_info() {
        # has a .git directory and a git binary
    	[ -d .git ] || command -v git >/dev/null || return 0

        local aheadN
        local behindN
        local branch
        local marks=""
        local stats

        # get current branch name or short SHA1 hash for detached head
        branch="$(git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --always 2>/dev/null)"
        [ -n "$branch" ] || return 0 # git branch not found

        # how many commits local branch is ahead/behind of remote?
        stats="$(git status --porcelain --branch | grep '^##' | grep -o '\[.\+\]$')"
        aheadN="$(echo "$stats" | grep -o 'ahead \d\+' | grep -o '\d\+')"
        behindN="$(echo "$stats" | grep -o 'behind \d\+' | grep -o '\d\+')"
        [ -n "$aheadN" ] && marks+=" $GIT_NEED_PUSH_SYMBOL$aheadN"
        [ -n "$behindN" ] && marks+=" $GIT_NEED_PULL_SYMBOL$behindN"

        # print the git branch segment without a trailing newline
        # branch is modified?
        if [ -n "$(git status --porcelain)" ]; then
            printf "%s" "${BG_COLOR8}‚ñ∂$RESET$BG_COLOR8 $branch$marks $FG_COLOR9"
        else
            printf "%s" "${BG_BLUE}‚ñ∂$RESET$BG_BLUE $branch$marks $RESET$FG_BLUE"
        fi
    }


    ps1() {
        # Check the exit code of the previous command and display different
        # colors in the prompt accordingly.
        if [ "$?" -eq 0 ]; then
            local BG_EXIT="$BG_GREEN"
            local FG_EXIT="$FG_GREEN"
        else
            local BG_EXIT="$BG_RED"
            local FG_EXIT="$FG_RED"
        fi

        PS1="$FG_COLOR1$BG_COLOR5 CodeComet \\w "
        PS1+="$RESET${FG_COLOR6}"
        PS1+="$(__git_info)"
        PS1+="$BG_EXIT‚ñ∂$RESET"
        PS1+="$BG_EXIT$FG_BASE3 ${PS_SYMBOL} ${RESET}${FG_EXIT}‚ñ∂${RESET} "
    }

    PROMPT_COMMAND=ps1
}

_cc_private::debugger::setup(){
  # Set-up PS1
  cat << EOF > "$CC_TMPFS"/.profile
# export PS1='\[\033[01;32m\]CodeComet\[\033[00m\] \w \$ '
alias l="ls -lA"
source ${BASH_SOURCE[0]}
umask 077
export LSCOLORS=exfxcxdxbxegedabagacad
export CLICOLOR=1

_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Welcome!" printf "You are now debugging your pipeline at the point it stopped.\n"
printf "\n"
#_cc_private::console::inline "$_CC_PV_COLOR_BLACK" "$_CC_PV_COLOR_BLACK" "         " printf ""
printf "Environment, pwd, and filesystem, are exactly as they were when the last action failed.\n"
printf "You can call the following helpers:\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdout" printf "will output your action stdout\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stderr" printf "will output your action stderr\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdex " printf "will output your action exit code\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_action" printf "will output the location of your action script\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Tip           " printf "If you want to re-run your action, just call \\\$(ccdebug_action)\n"

# touch "$CC_TMPFS/.codecomet/connected"
__powerline

EOF

  cat << EOF >> "$CC_TMPFS"/.inputrc
"\e[A": history-search-backward
"\e[B": history-search-forward
set show-all-if-ambiguous on
set completion-ignore-case on

EOF

}

# "on demand
# "Abnormal exit, with non zero grace:
# - start debugger repeatedly, with grace
# - once the other end exits, bail out

# "live", with non zero grace
# - start debugger, with infinity grace
# - if the other end was connected and exited, that is it, end of story
# - if the other end is still running, bring socat forward and wait for the end to exit
# - if there was no other end, we should branch back to the first scenario

# This is called on trap ERR, if a live debugger has been running, and will make a decision to bring it back forward and keep it alive,
# or to drop it
cc::debugger::front(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  cc::logger::debug "[debugger-front] socat is here"
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  cc::logger::debug "[debugger-front] grace is fine"


  # Debugger still live? Bail out if not
  jobs | grep -q -v Done || {
    cc::logger::debug "[debugger-front] no jobs detected. Bailing out."
    return 0
  }

  # Ok, it is live. Do we have a client?
  # XXX unfortunately, this does not work as expected... socat does start the process first, bash sources the files and create the stamp file...
  local lasttry
  local current
  lasttry="$(cat $CC_TMPFS/.codecomet/lasttry 2>/dev/null)" || true
  current="$(date +%s)"
  # The older an unconnected socat could be is 2 seconds - if greater than that, then we definitely have a client
  # However, it is possible that a client has been connected for less than 2 seconds (since socat call) when the failure happens,
  # which means the client will wrongly get the boot... no good solution right now
  [ $(( current - lasttry)) -gt 2 ] && {
  # [ -e "$CC_TMPFS/.codecomet/connected" ] && {
    cc::logger::debug "[debugger-front] we have a connected client"
    # Yes, then foreground and let it sit
    fg 2>/dev/null
  } || {
    cc::logger::debug "[debugger-front] no live client. Kick it out restart."
    # No live client. Kill it, and start again the normal process with timeout and message
    kill %%
    cc::debugger::start "$ex"
  }
}

# XXX this is largely broken
cc::debugger::live(){
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  while true; do
    lasttry="$(date +%s)"
    printf "%s" "$lasttry" > "$CC_TMPFS/.codecomet/lasttry"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-live] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Break if we have been hanging out more than a second (meaning the other end did connect, but exit in error)
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-live] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
    }
    x=$(( x + 1 ))
    cc::logger::debug "[debugger-live] sleeping"
    sleep 1
  done
}

cc::debugger::start(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  # Prep-up profile
  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  cc::logger::error "Abnormal exit code $ex. If you want to inspect manually, start codecomet-debugger. Otherwise, we will exit after $CC_DEBUGGER_GRACE seconds"
  cc::logger::error "You can also restart the build with CODECOMET_DEBUG=true"

  >&2 _cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "waiting" printf "Waiting %s seconds for debugger to connect" "$CC_DEBUGGER_GRACE"
  # cc::logger::warning "Waiting "


  # https://medium.com/@JAlblas/tryhackme-what-the-shell-walkthrough-6c0ebe8f854e
  #pty, allocates a pseudoterminal on the target ‚Äî part of the stabilisation process
  #stderr, makes sure that any error messages get shown in the shell (often a problem with non-interactive shells)
  #sigint, passes any Ctrl + C commands through into the sub-process, allowing us to kill commands inside the shell
  #setsid, creates the process in a new session
  #sane, stabilises the terminal, attempting to ‚Äúnormalise‚Äù it.

  while [ "$x" -lt "$CC_DEBUGGER_GRACE" ]; do
    lasttry="$(date +%s)"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-stat] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Timeing out means we wait for a second. Any more than that should mean the connection was succesful
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-stat] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
      >&2 printf "."
    }
    x=$(( x + 1 ))
    sleep 1
  done
}

ccdebug_stdout(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stdout.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stdout.log
  fi
}

ccdebug_stderr(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stderr.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stderr.log
  fi
}

ccdebug_stdex(){
  [ -e "$CC_TMPFS"/.codecomet/logs/ex.log ] && {
    cat "$CC_TMPFS"/.codecomet/logs/ex.log
  } || {
    cc::logger::warning "Action is in progress, no exit code yet"
  }
}

ccdebug_action(){
  echo "$_CC_PV_SCRIPT"
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# List all environment variables we depend on, possibly providing defaults
########################################################################################################################

#############
# Generic controls
#############
# Log level to start with (error, warning, info, debug or 4, 3, 2, 1, 0 <- mute)
readonly CC_LOG_LEVEL="${CC_LOG_LEVEL:-}"
# Where is the tempfs mounted
readonly CC_TMPFS="${CC_TMPFS:-}"
# Honors NO_COLOR (see https://no-color.org/)
# shellcheck disable=SC2034
readonly CC_CAP_NO_COLOR="${NO_COLOR:-}"
# About detection
# https://stackoverflow.com/questions/911168/how-can-i-detect-if-my-shell-script-is-running-through-a-pipe
# Could also test for [ ! -t 2 ]
# Or could be: `test -t 0` (formerly `tty -s`)
# In our context though, this probably does not matter much
# shellcheck disable=SC2034
readonly CC_CAP_HAS_TERM="${TERM:-}"

#############
# Action execution flow control
#############
# Whether the action can fail or not
readonly CC_ACTION_CAN_FAIL="${CC_ACTION_CAN_FAIL:-}"

#############
# Tracing and debugging
#############
# Controls wether the tracer will also trace internal codecomet library or hide them
readonly CC_TRACER_CODECOMET_INTERNALS="${CC_TRACER_CODECOMET_INTERNALS:-}"
# How long to wait for a connection before dropping the debugger
export CC_DEBUGGER_GRACE="${CC_DEBUGGER_GRACE:-}"
# Port to connect to
readonly CC_DEBUGGER_PORT="${CC_DEBUGGER_PORT:-}"
# IP to connect to
readonly CC_DEBUGGER_IP="${CC_DEBUGGER_IP:-}"
# Whether a debugger should be started pre-emptively so that one can hook in "live" during the action. This is very wonky as soon as you have parallelism...
readonly CC_DEBUGGER_LIVE="${CC_DEBUGGER_LIVE:-}"


#############
# Error code used accross the codebase - rn, only the bland FAILED is used...
#############
# shellcheck disable=SC2034
readonly ERROR_NETWORK=200
# Thrown if a required argument is missing
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_MISSING=201
# Thrown if an argument does not match validation
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_INVALID=202
# Should be used to convey that a certain operation is not supported
# shellcheck disable=SC2034
readonly ERROR_UNSUPPORTED=203
# Generic error to denote that the operation has failed. More specific errors may be provided instead
# shellcheck disable=SC2034
readonly ERROR_FAILED=204
# Expectations failed on a file (not readable, writable, doesn't exist, can't be created)
# shellcheck disable=SC2034
readonly ERROR_FILESYSTEM=205
# System requirements
# shellcheck disable=SC2034
readonly ERROR_MISSING_REQUIREMENTS=206

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# A generic logger
#
# Depends on:
# console.sh
########################################################################################################################

readonly CC_LOGGER_DEBUG=4
readonly CC_LOGGER_INFO=3
readonly CC_LOGGER_WARNING=2
readonly CC_LOGGER_ERROR=1

_CC_PV_LOGGER_LEVEL="$CC_LOGGER_WARNING"

_cc_private::logger::log(){
  local prefix="$1"
  shift

  local level="CC_LOGGER_$prefix"
  local i

  [ "$_CC_PV_LOGGER_LEVEL" -ge "${!level}" ] || return 0

  # About the crazy shit: https://stackoverflow.com/questions/12674783/bash-double-process-substitution-gives-bad-file-descriptor
  exec 3>&2
  for i in "$@"; do
    >&2 cc::console::"$(printf "$prefix" | tr '[:upper:]' '[:lower:]')" printf "$i"
  done
  exec 3>&-
}

cc::logger::level::set() {
  local level
  level="$(printf "%s" "${1:-}" | tr '[:upper:]' '[:lower:]')"

  case "$level" in
    ''|*[!0-9]*)
      case "$level" in
          "debug")
            _CC_PV_LOGGER_LEVEL=4
            ;;
          "info")
            _CC_PV_LOGGER_LEVEL=3
            ;;
          "warning")
            _CC_PV_LOGGER_LEVEL=2
            ;;
          "error")
            _CC_PV_LOGGER_LEVEL=1
            ;;
          "mute")
            _CC_PV_LOGGER_LEVEL=0
            ;;
          *)
            _CC_PV_LOGGER_LEVEL=3
            ;;
      esac
      ;;
    *)
      if [ "$level" -gt "$CC_LOGGER_DEBUG" ]; then
        return "$ERROR_FAILED"
      fi
      _CC_PV_LOGGER_LEVEL="$level"
      ;;
  esac

  [ "$_CC_PV_LOGGER_LEVEL" != "$CC_LOGGER_DEBUG" ] || {
    cc::console::warning printf "YOU ARE LOGGING AT THE DEBUG LEVEL."
    cc::console::warning printf "This is NOT recommended for production use, and WILL LIKELY LEAK sensitive information to logs."
  }
}

# Sugar
cc::logger::level::set::debug(){
  cc::logger::level::set "$CC_LOGGER_DEBUG"
}

cc::logger::level::set::info(){
  cc::logger::level::set "$CC_LOGGER_INFO"
}

cc::logger::level::set::warning(){
  cc::logger::level::set "$CC_LOGGER_WARNING"
}

cc::logger::level::set::error(){
  cc::logger::level::set "$CC_LOGGER_ERROR"
}

cc::logger::mute() {
  _CC_PV_LOGGER_LEVEL=0
}

cc::logger::ismute() {
  [ "$_CC_PV_LOGGER_LEVEL" == 0 ] || return "$ERROR_FAILED"
}

cc::logger::debug(){
  _cc_private::logger::log "DEBUG" "$@"
}

cc::logger::info(){
  _cc_private::logger::log "INFO" "$@"
}

cc::logger::warning(){
  _cc_private::logger::log "WARNING" "$@"
}

cc::logger::error(){
  _cc_private::logger::log "ERROR" "$@"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provides fancy display for `set -x`
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
########################################################################################################################

cc::codecomet::tracer(){
  local length="${#BASH_SOURCE[@]}"

  #local indent=""
  local linenumber
  local filename
  local filecontent
  local funcname
  local col

  [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[1]}" == *"action.sh" ]] || return 0

  printf "\n"

  for (( j=$(( length - 1 )); j>0; j-- )); do
    [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[$j]}" == *"action.sh" ]] || {
      continue
    }

    linenumber="${BASH_LINENO[$(( j - 1 ))]}"
    filename="${BASH_SOURCE[$j]}"
    filecontent="$(cat -n "$filename" | grep -E "^\s+$linenumber\s" | sed -E "s/^\s+$linenumber\s+//")"
    funcname="${FUNCNAME[$j]}"

    # Why is this showing is a mystery for the times
    # [ "$filecontent" != "#!/usr/bin/env bash" ] || continue

    [ "$j" != 1 ] && {
      col="$CC_COLOR_DEFAULT_FRONT"
    } || {
      col="$CC_COLOR_TRACER_HUMPF"
    }

    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$filename"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$linenumber"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "function" printf "%-30s" "$funcname()"
    printf "\n"
    [ "$j" != 1 ] || {
      _cc_private::console "$CC_COLOR_TRACER_COMMAND_LABEL" "$CC_COLOR_DEFAULT_FRONT" "command" printf "%s" "$filecontent"
      _cc_private::console "$CC_COLOR_TRACER_OUTPUT_LABEL" "$CC_COLOR_DEFAULT_FRONT" "output" printf ""
    }

  done
}

cc::tracer::register(){
  # shellcheck disable=SC2016
  local ps=('$(' "$@" ')')
  export PS4="${ps[*]}"
}

cc::init::tracer(){
  cc::tracer::register cc::codecomet::tracer
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Trap management
#
# Depends on:
# colors.sh
# console.sh
########################################################################################################################

_CC_PV_TRAP_LISTENERS=()

_CC_PV_ERR_LNO=
_CC_PV_ERR_CMD=
_CC_PV_ERR_STACK=
_CC_PV_ERR_EX=

dc::trap::register(){
  _CC_PV_TRAP_LISTENERS+=( "$1" )
}

# Trap lno and cmd on ERR for future use
cc::trap::err(){
  _CC_PV_ERR_EX="$1"
  _CC_PV_ERR_LNO="$2"
  _CC_PV_ERR_CMD="$3"
  _CC_PV_ERR_STACK="$4"
  # Dropping the rest of the stack?

  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$_CC_PV_ERR_STACK"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$_CC_PV_ERR_LNO"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "exit" printf "%s" "$_CC_PV_ERR_EX"
  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "command" printf "%-30s" "$_CC_PV_ERR_CMD"
  >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  >&2 printf "\n"

  >&2 _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "source" printf ""
  prefix=" "
  for (( j=$(( _CC_PV_ERR_LNO - 3 )); j<$(( _CC_PV_ERR_LNO + 3 )); j++ )); do
    [ "$j" -gt 0 ] || continue
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=">"
      >&2 _cc_private::tput setaf "$CC_COLOR_ERROR_FRONT"
      #>&2 _cc_private::tput bold
    fi
    #  | sed -E "s/^\s+$j\s//"
    >&2 printf "%s%s" "$prefix" "$(cat -n "$_CC_PV_ERR_STACK" | grep -E "^\s+$j\s")" || true
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=" "
      >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
      #>&2 _cc_private::tput sgr0
    fi
    >&2 printf "\n"
  done
}

_CC_PV_NO_REENTRY=

# Trap exit for the actual cleanup
cc::trap::exit() {
  # { set +x; } 2>/dev/null

  local ex="$1"
  local i

  # Prevent reentrancy - XXX is this actually needed?
  [ ! "$_CC_PV_NO_REENTRY" ] || return 0
  _CC_PV_NO_REENTRY="exiting"

  printf "%s\n" "$ex" > "$CC_TMPFS"/.codecomet/logs/ex.log

  if [ "${#_CC_PV_TRAP_LISTENERS[@]}" -gt 0 ]; then
    for i in "${_CC_PV_TRAP_LISTENERS[@]}"; do
      cc::logger::debug "Calling exit hook $i"
#      >&2 printf "\n"
      "$i" "$ex" "$_CC_PV_ERR_CMD" "$_CC_PV_ERR_LNO" "$_CC_PV_ERR_STACK"
    done
  fi
  >&2 cc::console::reset
  >&2 printf "\n"
  cc::logger::debug "Exiting ($ex)"
  [ "$CC_ACTION_CAN_FAIL" == "true" ] && {
    [ "$ex" != "" ] || cc::logger::error "Action failed, but it is marked as 'can fail', so, exiting successfully"
    exit 0
  } || exit "$ex"
}

# Forking to disable xtrace when entering traps
cc::init::trap(){
  # Signals are caught by buildkit already - and only SIGKILL triggers a failure
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::err "$ex" "$LINENO" "$BASH_COMMAND" "${BASH_SOURCE[@]}"' ERR
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::exit "$ex"' EXIT
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# See https://manpages.ubuntu.com/manpages/xenial/man1/eatmydata.1.html
# Technically, we get a 10% speedup with apt operations for eg
# XXX careful here if this is going to be used in a chroot
cc::init::speedup(){
  ! command -v eatmydata >/dev/null || export LD_PRELOAD=libeatmydata.so
}

# Boot if we have an argument - otherwise, we are being sourced
if [ "$#" -gt 0 ]; then
  mkdir -p "$TMPDIR"
  rm -Rf "$CC_TMPFS"/.codecomet
  mkdir -p "$CC_TMPFS"/.codecomet/bin
  mkdir -p "$CC_TMPFS"/.codecomet/logs

  # Set logger to env var from the Bash helper
  cc::logger::level::set "$CC_LOG_LEVEL"

  # Eat data, trap, register tracer, register debugger on exit trap
  cc::init::speedup
  cc::init::trap
  cc::init::tracer
  # Live debugger is really wonky
  if [ "${CC_DEBUGGER_LIVE:-}" != "" ]; then
    cc::debugger::live &
    dc::trap::register cc::debugger::front
  else
    [ "$CC_ACTION_CAN_FAIL" == true ] || dc::trap::register cc::debugger::start
  fi

  # XXX technically, we receive a bunch of scripts, and we could just play them all - use case is not completely clear yet
  out="$CC_TMPFS"/.codecomet/logs/stdout.log
  err="$CC_TMPFS"/.codecomet/logs/stderr.log

  # Unpack libraries path and source them
  while [ "$#" -gt 1 ]; do
    cp "$1" "$CC_TMPFS"/.codecomet/bin
    # shellcheck disable=SC1090
    source "$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
    shift
  done
  cp "$1" "$CC_TMPFS"/.codecomet/bin
  _CC_PV_SCRIPT="$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
  export _CC_PV_SCRIPT

  # Run the actual action
  # shellcheck disable=SC1090
  source "$_CC_PV_SCRIPT" > >(tee -a "$out") 2> >(tee -a "$err" >&2)
else
  # If we are a library, toss this one so we do not exit on any error...
  # This is especially important for the reverse debugger
  set +o errexit
fi
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
â"Ûˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*◊
/library0.sh¿∏#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# A generic lock mechanism that supports exclusive locks, shared locks, and a simplistic queueing mechanism
_cc_lockindex=9
_cc_lock_location="/_cc/share/locks"

# Sets our locks location. Must be called to guarantee that the lock location exist.
cc::lock::init(){
	_cc_lock_location="${1:-.}"
	mkdir -p "${_cc_lock_location}"
}

# Acquire a lock with a given name, and a share mode (shared or exclusive (which is the default))
# If the lock is already acquired in a different mode, or the mode is exclusive, the function will wait until the lock is released.
# Return the lock id that you need to carry around to release the lock later on.
cc::lock::acquire(){
	local lockfile="$_cc_lock_location/$1"
	local shared="${2:-}"
	[ "$shared" ] && shared=-s || shared=-x
	_cc_lockindex=$((_cc_lockindex+1))
	mkdir -p "$(dirname "$lockfile")"
	exec {_cc_lockindex}>"$lockfile"
	flock $shared $_cc_lockindex
	return $_cc_lockindex
}

# Release a previously acquire lock by its id
cc::lock::release(){
	local idx="$1"
	# This is essentially the same
	flock -u "$idx"
	# exec {idx}>&-
}

cc::lock::queue(){
	local basepath="${1:-.}"
	local shared1="${2:-}"
	local shared2="${3:-}"
	local qid
	local oid

	# Get into the queue first
	cc::lock::acquire "$basepath"/cc_queue.lock "$shared1" || qid=$?

	# Then when out of the queue, acquire an operation lock
	cc::lock::acquire "$basepath"/cc_op.lock "$shared2" || oid=$?

	# Now, leave the queue
	cc::lock::release $qid

	# Return the lock id
	return $oid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
˙"‰·ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*»
/library1.sh¿©#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Lessons learned:
# - find -exec is VERY SLOW - better off piping to read (almost 10x) (0.2 second vs 0.02 second for about 200 files)
# - then globbing and grepping is faster than find + read
# This matters not in case we are copying a large amount of data of course, but then
# - there is no way to get something stable out of ls without further processing - directories with different owners
# for eg will widen some columns
# this "works" right now (if we do not use --numeric-uid-gid) but will be problematic outside of this specific case

_cc::fingerprint(){
  local directory="$1"
  # Will fail if the directory is empty, so the guardrail
  # Ignore directories, links, and "total" (note: -d will not work for that)
  # --numeric-uid-gid < messes up the output width
  # shellcheck disable=SC2010
  ls --full-time --almost-all --ignore lock "$directory" 2>/dev/null | grep -v "^[d|l|t]" || true
}

# Copy or symlink data "from" storage "to" destination
# This assume that storage holds only files, and no lock
# Will not copy anything if there is no difference
cc::storage::retrieve(){
  local from="$1"
  local to="$2"
  local copy="${3:-}"
  local lid
  local fromState

  # Ensure destination exists
  mkdir -p "$to"

  # Lock origin and keep the lock id
  cc::lock::acquire "$from" shared || lid=$?

  # Ensure origin exists
  mkdir -p "$from"

  # If we are asked to copy (not expected for large amount of data - linking is prefered in that case)
  if [ "$copy" ]; then
    # Retrieve the state of it
    fromState="$(_cc::fingerprint "$from")"

    # Check that we have content in storage
    # Check that we have a difference between storage and destination (ignoring directories and lock file)
    # shellcheck disable=SC2010
    # shellcheck disable=SC2015
    [ "$fromState" ] && [ "$fromState" != "$(_cc::fingerprint "$to")" ] && {
      # Then cleanup destination
      rm -Rf "$to"
      mkdir -p "$to"
      # And copy over
      cp -p "$from"/* "$to"
      # Slower
      #find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
      #  cp -p "$fd" "$to"
      #done
    } || {
      # Otherwise, do nothing
      cc::logger::debug "Nothing to retrieve from storage"
    }
  else
    # We want links, so, lets check we have anything in the origin
    #[ ! "$fromState" ] || {
    # Get rid of possibly remaining files in our destination
    find "$to" -type f -delete
    ln -sf "$from"/* "$to" 2>/dev/null || true
    # Note: below is slower
    # find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
    #  ln -s "$fd" "$to"
    # done
    #}
  fi

  # Release the lock
	cc::lock::release $lid
}

cc::storage::store(){
  local from="$1"
  local to="$2"
  local erase="${3:-}"
  local lid
  local fd
  local toState

  # Ensure origin exists
  mkdir -p "$from"

  # Lock destination and keep the lock id
  cc::lock::acquire "$to" "" || lid=$?

  # Ensure destination exists
  mkdir -p "$to"
  # Retrieve the state of it
  # shellcheck disable=SC2010
  toState="$(_cc::fingerprint "$to")"

  # Compare state of the destination with the origin (origin ignores directories and lock files)
  # shellcheck disable=SC2010
  # shellcheck disable=SC2015
  [ "$toState" != "$(_cc::fingerprint "$from")" ] && {
    # We have changes - if asked to wipe out, do so
    if [ "$erase" ]; then
      rm -Rf "$to"
      mkdir -p "$to"
    fi
    # Now copy the files
    # This is probably slow-ish. The question is: will it be significant in a context where copy IO is the bottleneck?
    find "$from" -type f -not -iname "lock" -print0 | while IFS= read -r -d $'\0' fd; do
      cp -p "$fd" "$to"
    done
  } || {
    cc::logger::debug "Nothing to save to storage"
  }

  # Release the lock
	cc::lock::release $lid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
Ï*"÷*”*ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∫*
/library2.sh¿õ*#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Helpers to allow apt to share cache properly

# Private tmpfs location
_cc_tmpfs_location=/codecomet/apt-get-private/tmp

# Location of the list cache
_cc_apt_list_store_location=/codecomet/apt-get-shared/lists
# And pack cache
_cc_apt_pack_local_location=/codecomet/apt-get-shared/packs

# Location of the packages cache
_cc_apt_pack_store_location=/codecomet/apt-get-shared/cache

# Location of our private lists files - by default, Debian normal location, which means state will persist
_cc_apt_list_local_location=/var/lib/apt/lists

# Location of the config file
export APT_CONFIG=$_cc_tmpfs_location/apt-get.conf

# Hash of the sources.list, which dictates the cache location to share
# Different sources means different cache location
# Caveats: this will likely not work with a future debian release as they change the sources.list format
# XXX this wracking the debugger output
cc::apt_get::shard(){
  sha256sum <<< "$(uname -m)$(grep --no-filename -Ev "^#" /etc/apt/sources.list /etc/apt/sources.list.d/* 2>/dev/null | sed -E 's/#.+$//' | sort || true)" | sed -E 's/  .*//'
}

# Set the tmp location, initiliaze APT_CONFIG and shared and private locations
cc::apt_get::init(){
  # Get the desired tmpfs mount point
  _cc_tmpfs_location="$1"

  mkdir -p "$_cc_tmpfs_location"

  # Point configuration there
  export APT_CONFIG="$_cc_tmpfs_location"/apt-get.conf

  # Sharding by sources list content, cleaned-up and sorted to maximize cache hits
	_cc_apt_list_store_location="$2/$(cc::apt_get::shard)"

  # Technically, we should not be sharding the architecture
  # But then, the only upside would be when installing cross-arch packages
	_cc_apt_pack_store_location="$3/$(cc::apt_get::shard)"

  # If we do not want lists to persist, use the tmp storage
  [ "${4:-}" == true ] || _cc_apt_list_local_location="$_cc_tmpfs_location"/lists

  # Finally, local pack location
  _cc_apt_pack_local_location="$_cc_tmpfs_location"/packs

  # Make sure they all exist
  mkdir -p "$_cc_apt_list_local_location"
  mkdir -p "$_cc_apt_pack_local_location"

  mkdir -p "$_cc_apt_list_store_location"
  mkdir -p "$_cc_apt_pack_store_location"
}

# Create the configuration file for APT
cc::apt_get::configure(){
  local config_extra="${1:-}"
  local persist="${2:-}"

  mkdir -p "$_cc_tmpfs_location/logs"
  cat << EOF > "$APT_CONFIG"
# Divert both lists and archives location
Dir::Cache::Archives "$_cc_apt_pack_local_location";
Dir::State::Lists "$_cc_apt_list_local_location";
# Prevent the default apt config to be used
Dir::Etc::parts "";
# Put the logs in the tmp zone
Dir::Log "$_cc_tmpfs_location/logs";
# Put the bin cache files in the private mount
Dir::Cache::srcpkgcache "$_cc_tmpfs_location/srcpkgcache.bin";
Dir::Cache::pkgcache "$_cc_tmpfs_location/pkgcache.bin";

$config_extra
EOF

  # If asked to persist the config, copy over the generated file
  [ "$persist" == "false" ] || cp "$APT_CONFIG" /etc/apt/apt.conf
}

#cc::apt_get::cleanup(){
  # This is only necessary if we were not using an tmpfs mount...
  # rm "$APT_CONFIG"
#}

cc::apt_get::update(){
  # Remove our marker if here
  rm -f "$_cc_apt_list_local_location"/.cc_updated

  # Retrieve existing data
  cc::storage::retrieve "$_cc_apt_list_store_location" "$_cc_apt_list_local_location" copy

	# Do the deed, same restriction applies
	apt-get update "$@"

  # Save it back (storage will decide)
  cc::storage::store "$_cc_apt_list_local_location" "$_cc_apt_list_store_location" erase

  # Now, flag it
  date > "$_cc_apt_list_local_location"/.cc_updated
}

cc::apt_get::do(){
  # Bring in any cache
  cc::storage::retrieve "$_cc_apt_pack_store_location" "$_cc_apt_pack_local_location"

	apt-get "$@"

  # Store the packages permanently
  cc::storage::store "$_cc_apt_pack_local_location" "$_cc_apt_pack_store_location"
}

# XXX what if sources are being modified, or config, or something else that materially impacts update?
cc::high::update(){
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "$nooutput"

  args+=("$@")
  time cc::apt_get::update "${args[@]}"
}

cc::high::install(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists has been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  args+=("$@")
  time cc::apt_get::do install "${args[@]}"
}

cc::high::upgrade(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists have been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  # ls -lAR "$_cc_tmpfs_location"/packs || true
  # time cc::apt_get::do upgrade "$nooutput" "$@"

  # XXX WIP here
  # Bust cache - delete this
  #time cc::apt_get::do upgrade --download-only "$nooutput" "$@"
  #time cc::apt_get::do upgrade --no-download "$nooutput" "$@"
  args+=("$@")
  time cc::apt_get::do upgrade "${args[@]}"
}

cc::high::purge(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")

  args+=("$@")
  time cc::apt_get::do purge --auto-remove "${args[@]}"
}(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
’"øºˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*£

/action.sh¿Ü#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::upgrade

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f7942
 



Z 
£
I
Gsha256:aba97bce52cb75c817d06fec2353f811940c416a472ab6b0fab8ae0a54511d83
I
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
arm64linuxZ 
Í"‘—ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∏

/action.sh¿õ#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::install eatmydata nano socat

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c2
 



Z 
£
I
Gsha256:1f71c46c8f58462f657331fc0617521fb54f9990f04397320f86547435ca03f3
I
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
arm64linuxZ 
K
I
Gsha256:c7759768f7674d770a8a4ef7c18d38e5c0deb872d612f1f8102e8bdebc9bcf0eπ
Gsha256:1f71c46c8f58462f657331fc0617521fb54f9990f04397320f86547435ca03f3Ì!
codecomet.optest codecomet op!
llb.customnameapt-get upgrade*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeü
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library2.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library1.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962—!
codecomet.optest codecomet op0
llb.customname[action:addfile] codecomet in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupË
Gsha256:aba97bce52cb75c817d06fec2353f811940c416a472ab6b0fab8ae0a54511d83ú!
codecomet.optest codecomet opG
llb.customname5[source:image] docker.io/library/debian:bullseye-slim*
source.image*
source.image.resolvemodeê
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edfƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library0.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupŒ
Gsha256:c7759768f7674d770a8a4ef7c18d38e5c0deb872d612f1f8102e8bdebc9bcf0eÇ!
codecomet.optest codecomet op6
llb.customname$apt-get install eatmydata nano socat*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeÄ
Gsha256:e0223abffd3a522e48edba08a44b777ad6b5b53eaafcfe5f5f7ae63aaa1097405*
constraints*
meta.description*
platformê
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8aƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupœ
K
Gsha256:1f71c46c8f58462f657331fc0617521fb54f9990f04397320f86547435ca03f3 
K
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f 
K
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7 
K
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962 
K
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c 
K
Gsha256:aba97bce52cb75c817d06fec2353f811940c416a472ab6b0fab8ae0a54511d83 
K
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf 
K
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c 
K
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794 
K
Gsha256:c7759768f7674d770a8a4ef7c18d38e5c0deb872d612f1f8102e8bdebc9bcf0e 
K
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a 
hR
5docker-image://docker.io/library/debian:bullseye-slim
image.resolvemodepullR
armlinuxv7Z 
æ›"ß›£›ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*â›

/codecomet¿Î‹#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Defines the supported color palette, and our color scheme
########################################################################################################################

# Supported color palette
readonly _CC_PV_COLOR_BLACK=0
readonly _CC_PV_COLOR_RED=1
readonly _CC_PV_COLOR_GREEN=2
readonly _CC_PV_COLOR_YELLOW=3
# shellcheck disable=SC2034
readonly _CC_PV_COLOR_BLUE=4
readonly _CC_PV_COLOR_MAGENTA=5
readonly _CC_PV_COLOR_CYAN=6
readonly _CC_PV_COLOR_WHITE=7

# Colors scheme definition - can evidently be customized at runtime by setting these variables to other values from the palette
export CC_COLOR_DEFAULT_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEFAULT_BACK="$_CC_PV_COLOR_BLACK"

export CC_COLOR_BODY="$_CC_PV_COLOR_WHITE"
export CC_COLOR_COMMENT="$_CC_PV_COLOR_CYAN"
export CC_COLOR_HUMPF="$_CC_PV_COLOR_MAGENTA"

# Logger
export CC_COLOR_ERROR_FRONT="$_CC_PV_COLOR_RED"
export CC_COLOR_ERROR_BACK="$_CC_PV_COLOR_WHITE"
export CC_COLOR_WARNING_FRONT="$_CC_PV_COLOR_YELLOW"
export CC_COLOR_WARNING_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_INFO_FRONT="$_CC_PV_COLOR_GREEN"
export CC_COLOR_INFO_BACK="$_CC_PV_COLOR_BLACK"
export CC_COLOR_DEBUG_FRONT="$_CC_PV_COLOR_WHITE"
export CC_COLOR_DEBUG_BACK="$_CC_PV_COLOR_BLACK"

# Tracer
export CC_COLOR_TRACER_HUMPF="$_CC_PV_COLOR_GREEN"
export CC_COLOR_TRACER_COMMAND_LABEL="$_CC_PV_COLOR_BLUE"
export CC_COLOR_TRACER_OUTPUT_LABEL="$_CC_PV_COLOR_RED"
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provide helpers to print colorful text
#
# Depends on:
# defaults.sh
# colors.sh
########################################################################################################################

_cc_private::tput(){
  [ ! "$CC_CAP_HAS_TERM" ] || [ "$CC_CAP_NO_COLOR" != "" ] || tput "$@" 2>/dev/null || true
}

_cc_private::console::inline(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it and pad to 7 chars, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"
}

_cc_private::console(){
  local front="$1"
  local back="$2"
  local label="$3"
  shift
  shift
  shift

  # If there is a label, swap out front/back colors to build it, and the rest will just use the front color
  [ "$label" ] && {
    _cc_private::tput setaf "$back"
    _cc_private::tput setab "$front"
    printf " %-7s " "$label"
    _cc_private::tput setaf "$front"
    _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
    printf "‚ñ∂ "
  } || {
    # Otherwise, just a plain front/back
    [ ! "$front" ] || _cc_private::tput setaf "$front"
    [ ! "$back" ] || _cc_private::tput setaf "$back"
  }

  "$@"

  # Restore console to default before we \n so that we do not leak over into BK timestamp display
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::error(){
  _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_ERROR_BACK" "error" "$@"
}

cc::console::warning(){
  _cc_private::console "$CC_COLOR_WARNING_FRONT" "$CC_COLOR_WARNING_BACK" "warning" "$@"
}

cc::console::info(){
  _cc_private::console "$CC_COLOR_INFO_FRONT" "$CC_COLOR_INFO_BACK" "info" "$@"
}

cc::console::debug(){
  _cc_private::console "$CC_COLOR_DEBUG_FRONT" "$CC_COLOR_DEBUG_BACK" "debug" "$@"
}

cc::console::body(){
  _cc_private::console "$CC_COLOR_BODY" "" "" "$@"
}

cc::console::comment(){
  _cc_private::console "$CC_COLOR_COMMENT" "" "" "$@"
}

cc::console::humpf(){
  _cc_private::console "$CC_COLOR_HUMPF" "" "" "$@"
}

cc::console::reset(){
  _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  _cc_private::tput setab "$CC_COLOR_DEFAULT_BACK"
  printf "\n"
}

cc::console::end(){
  _cc_private::tput op
  printf "\n"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Debugger based on socat
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
# logger.sh
########################################################################################################################

# Fancy prompt adapted from https://github.com/pombadev/fancy-linux-prompt/blob/master/LICENSE under MIT License
__powerline() {
    # Unicode symbols
    readonly GIT_NEED_PULL_SYMBOL='‚á£'
    readonly GIT_NEED_PUSH_SYMBOL='‚á°'
    readonly PS_SYMBOL='ü™ê' # üêß‚òÑ'‚ñ∂‚èµ‚ñ∂‚èµ

    # Solarized colorscheme
    readonly BG_BLUE="\\[$(tput setab 4)\\]"
    readonly BG_COLOR5="\\[\\e[48;5;31m\\]"
    readonly BG_COLOR8="\\[\\e[48;5;161m\\]"
    readonly BG_GREEN="\\[$(tput setab 2)\\]"
    readonly BG_RED="\\[$(tput setab 1)\\]"
    readonly FG_BASE3="\\[$(tput setaf 15)\\]"
    readonly FG_BLUE="\\[$(tput setaf 4)\\]"
    readonly FG_COLOR1="\\[\\e[38;5;250m\\]"
    readonly FG_COLOR6="\\[\\e[38;5;31m\\]"
    readonly FG_COLOR9="\\[\\e[38;5;161m\\]"
    readonly FG_GREEN="\\[$(tput setaf 2)\\]"
    readonly FG_RED="\\[$(tput setaf 1)\\]"
    readonly RESET="\\[$(tput sgr0)\\]"

    __git_info() {
        # has a .git directory and a git binary
    	[ -d .git ] || command -v git >/dev/null || return 0

        local aheadN
        local behindN
        local branch
        local marks=""
        local stats

        # get current branch name or short SHA1 hash for detached head
        branch="$(git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --always 2>/dev/null)"
        [ -n "$branch" ] || return 0 # git branch not found

        # how many commits local branch is ahead/behind of remote?
        stats="$(git status --porcelain --branch | grep '^##' | grep -o '\[.\+\]$')"
        aheadN="$(echo "$stats" | grep -o 'ahead \d\+' | grep -o '\d\+')"
        behindN="$(echo "$stats" | grep -o 'behind \d\+' | grep -o '\d\+')"
        [ -n "$aheadN" ] && marks+=" $GIT_NEED_PUSH_SYMBOL$aheadN"
        [ -n "$behindN" ] && marks+=" $GIT_NEED_PULL_SYMBOL$behindN"

        # print the git branch segment without a trailing newline
        # branch is modified?
        if [ -n "$(git status --porcelain)" ]; then
            printf "%s" "${BG_COLOR8}‚ñ∂$RESET$BG_COLOR8 $branch$marks $FG_COLOR9"
        else
            printf "%s" "${BG_BLUE}‚ñ∂$RESET$BG_BLUE $branch$marks $RESET$FG_BLUE"
        fi
    }


    ps1() {
        # Check the exit code of the previous command and display different
        # colors in the prompt accordingly.
        if [ "$?" -eq 0 ]; then
            local BG_EXIT="$BG_GREEN"
            local FG_EXIT="$FG_GREEN"
        else
            local BG_EXIT="$BG_RED"
            local FG_EXIT="$FG_RED"
        fi

        PS1="$FG_COLOR1$BG_COLOR5 CodeComet \\w "
        PS1+="$RESET${FG_COLOR6}"
        PS1+="$(__git_info)"
        PS1+="$BG_EXIT‚ñ∂$RESET"
        PS1+="$BG_EXIT$FG_BASE3 ${PS_SYMBOL} ${RESET}${FG_EXIT}‚ñ∂${RESET} "
    }

    PROMPT_COMMAND=ps1
}

_cc_private::debugger::setup(){
  # Set-up PS1
  cat << EOF > "$CC_TMPFS"/.profile
# export PS1='\[\033[01;32m\]CodeComet\[\033[00m\] \w \$ '
alias l="ls -lA"
source ${BASH_SOURCE[0]}
umask 077
export LSCOLORS=exfxcxdxbxegedabagacad
export CLICOLOR=1

_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Welcome!" printf "You are now debugging your pipeline at the point it stopped.\n"
printf "\n"
#_cc_private::console::inline "$_CC_PV_COLOR_BLACK" "$_CC_PV_COLOR_BLACK" "         " printf ""
printf "Environment, pwd, and filesystem, are exactly as they were when the last action failed.\n"
printf "You can call the following helpers:\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdout" printf "will output your action stdout\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stderr" printf "will output your action stderr\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_stdex " printf "will output your action exit code\n"
_cc_private::console::inline "$_CC_PV_COLOR_YELLOW" "$_CC_PV_COLOR_BLACK" "ccdebug_action" printf "will output the location of your action script\n\n"
_cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "Tip           " printf "If you want to re-run your action, just call \\\$(ccdebug_action)\n"

# touch "$CC_TMPFS/.codecomet/connected"
__powerline

EOF

  cat << EOF >> "$CC_TMPFS"/.inputrc
"\e[A": history-search-backward
"\e[B": history-search-forward
set show-all-if-ambiguous on
set completion-ignore-case on

EOF

}

# "on demand
# "Abnormal exit, with non zero grace:
# - start debugger repeatedly, with grace
# - once the other end exits, bail out

# "live", with non zero grace
# - start debugger, with infinity grace
# - if the other end was connected and exited, that is it, end of story
# - if the other end is still running, bring socat forward and wait for the end to exit
# - if there was no other end, we should branch back to the first scenario

# This is called on trap ERR, if a live debugger has been running, and will make a decision to bring it back forward and keep it alive,
# or to drop it
cc::debugger::front(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  cc::logger::debug "[debugger-front] socat is here"
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  cc::logger::debug "[debugger-front] grace is fine"


  # Debugger still live? Bail out if not
  jobs | grep -q -v Done || {
    cc::logger::debug "[debugger-front] no jobs detected. Bailing out."
    return 0
  }

  # Ok, it is live. Do we have a client?
  # XXX unfortunately, this does not work as expected... socat does start the process first, bash sources the files and create the stamp file...
  local lasttry
  local current
  lasttry="$(cat $CC_TMPFS/.codecomet/lasttry 2>/dev/null)" || true
  current="$(date +%s)"
  # The older an unconnected socat could be is 2 seconds - if greater than that, then we definitely have a client
  # However, it is possible that a client has been connected for less than 2 seconds (since socat call) when the failure happens,
  # which means the client will wrongly get the boot... no good solution right now
  [ $(( current - lasttry)) -gt 2 ] && {
  # [ -e "$CC_TMPFS/.codecomet/connected" ] && {
    cc::logger::debug "[debugger-front] we have a connected client"
    # Yes, then foreground and let it sit
    fg 2>/dev/null
  } || {
    cc::logger::debug "[debugger-front] no live client. Kick it out restart."
    # No live client. Kill it, and start again the normal process with timeout and message
    kill %%
    cc::debugger::start "$ex"
  }
}

# XXX this is largely broken
cc::debugger::live(){
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  while true; do
    lasttry="$(date +%s)"
    printf "%s" "$lasttry" > "$CC_TMPFS/.codecomet/lasttry"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-live] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Break if we have been hanging out more than a second (meaning the other end did connect, but exit in error)
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-live] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
    }
    x=$(( x + 1 ))
    cc::logger::debug "[debugger-live] sleeping"
    sleep 1
  done
}

cc::debugger::start(){
  # If we exited successfully, just bail out
  local ex="$1"
  [ "$ex" != 0 ] || return 0
  # If we do not have socat, we do not have a debugger...
  command -v socat >/dev/null || return 0
  # If the debugger was disabled, return
  [ "$CC_DEBUGGER_GRACE" != 0 ] || return 0
  # If the grace was not set, set it now to the default
  [ "$CC_DEBUGGER_GRACE" != "" ] || CC_DEBUGGER_GRACE=20

  # Prep-up profile
  _cc_private::debugger::setup
  local lasttry
  local current
  local x=0

  cc::logger::error "Abnormal exit code $ex. If you want to inspect manually, start codecomet-debugger. Otherwise, we will exit after $CC_DEBUGGER_GRACE seconds"
  cc::logger::error "You can also restart the build with CODECOMET_DEBUG=true"

  >&2 _cc_private::console::inline "$_CC_PV_COLOR_GREEN" "$_CC_PV_COLOR_BLACK" "waiting" printf "Waiting %s seconds for debugger to connect" "$CC_DEBUGGER_GRACE"
  # cc::logger::warning "Waiting "


  # https://medium.com/@JAlblas/tryhackme-what-the-shell-walkthrough-6c0ebe8f854e
  #pty, allocates a pseudoterminal on the target ‚Äî part of the stabilisation process
  #stderr, makes sure that any error messages get shown in the shell (often a problem with non-interactive shells)
  #sigint, passes any Ctrl + C commands through into the sub-process, allowing us to kill commands inside the shell
  #setsid, creates the process in a new session
  #sane, stabilises the terminal, attempting to ‚Äúnormalise‚Äù it.

  while [ "$x" -lt "$CC_DEBUGGER_GRACE" ]; do
    lasttry="$(date +%s)"
    HOME="$CC_TMPFS" socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$CC_DEBUGGER_IP:$CC_DEBUGGER_PORT,connect-timeout=1 2>/dev/null && {
      cc::logger::debug "[debugger-stat] socat returned successfully, meaning the other end has exited 0"
      break
    } || {
      # Timeing out means we wait for a second. Any more than that should mean the connection was succesful
      current="$(date +%s)"
      if [ $(( current - lasttry)) -gt 1 ]; then
        cc::logger::debug "[debugger-stat] socat returned with an error, but after more than 1 second, meaning the other end has exited non zero"
        break
      fi
      >&2 printf "."
    }
    x=$(( x + 1 ))
    sleep 1
  done
}

ccdebug_stdout(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stdout.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stdout.log
  fi
}

ccdebug_stderr(){
  if [ "${1:-}" == "-f" ]; then
    tail -f "$CC_TMPFS"/.codecomet/logs/stderr.log
  else
    cat "$CC_TMPFS"/.codecomet/logs/stderr.log
  fi
}

ccdebug_stdex(){
  [ -e "$CC_TMPFS"/.codecomet/logs/ex.log ] && {
    cat "$CC_TMPFS"/.codecomet/logs/ex.log
  } || {
    cc::logger::warning "Action is in progress, no exit code yet"
  }
}

ccdebug_action(){
  echo "$_CC_PV_SCRIPT"
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# List all environment variables we depend on, possibly providing defaults
########################################################################################################################

#############
# Generic controls
#############
# Log level to start with (error, warning, info, debug or 4, 3, 2, 1, 0 <- mute)
readonly CC_LOG_LEVEL="${CC_LOG_LEVEL:-}"
# Where is the tempfs mounted
readonly CC_TMPFS="${CC_TMPFS:-}"
# Honors NO_COLOR (see https://no-color.org/)
# shellcheck disable=SC2034
readonly CC_CAP_NO_COLOR="${NO_COLOR:-}"
# About detection
# https://stackoverflow.com/questions/911168/how-can-i-detect-if-my-shell-script-is-running-through-a-pipe
# Could also test for [ ! -t 2 ]
# Or could be: `test -t 0` (formerly `tty -s`)
# In our context though, this probably does not matter much
# shellcheck disable=SC2034
readonly CC_CAP_HAS_TERM="${TERM:-}"

#############
# Action execution flow control
#############
# Whether the action can fail or not
readonly CC_ACTION_CAN_FAIL="${CC_ACTION_CAN_FAIL:-}"

#############
# Tracing and debugging
#############
# Controls wether the tracer will also trace internal codecomet library or hide them
readonly CC_TRACER_CODECOMET_INTERNALS="${CC_TRACER_CODECOMET_INTERNALS:-}"
# How long to wait for a connection before dropping the debugger
export CC_DEBUGGER_GRACE="${CC_DEBUGGER_GRACE:-}"
# Port to connect to
readonly CC_DEBUGGER_PORT="${CC_DEBUGGER_PORT:-}"
# IP to connect to
readonly CC_DEBUGGER_IP="${CC_DEBUGGER_IP:-}"
# Whether a debugger should be started pre-emptively so that one can hook in "live" during the action. This is very wonky as soon as you have parallelism...
readonly CC_DEBUGGER_LIVE="${CC_DEBUGGER_LIVE:-}"


#############
# Error code used accross the codebase - rn, only the bland FAILED is used...
#############
# shellcheck disable=SC2034
readonly ERROR_NETWORK=200
# Thrown if a required argument is missing
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_MISSING=201
# Thrown if an argument does not match validation
# shellcheck disable=SC2034
readonly ERROR_ARGUMENT_INVALID=202
# Should be used to convey that a certain operation is not supported
# shellcheck disable=SC2034
readonly ERROR_UNSUPPORTED=203
# Generic error to denote that the operation has failed. More specific errors may be provided instead
# shellcheck disable=SC2034
readonly ERROR_FAILED=204
# Expectations failed on a file (not readable, writable, doesn't exist, can't be created)
# shellcheck disable=SC2034
readonly ERROR_FILESYSTEM=205
# System requirements
# shellcheck disable=SC2034
readonly ERROR_MISSING_REQUIREMENTS=206

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# A generic logger
#
# Depends on:
# console.sh
########################################################################################################################

readonly CC_LOGGER_DEBUG=4
readonly CC_LOGGER_INFO=3
readonly CC_LOGGER_WARNING=2
readonly CC_LOGGER_ERROR=1

_CC_PV_LOGGER_LEVEL="$CC_LOGGER_WARNING"

_cc_private::logger::log(){
  local prefix="$1"
  shift

  local level="CC_LOGGER_$prefix"
  local i

  [ "$_CC_PV_LOGGER_LEVEL" -ge "${!level}" ] || return 0

  # About the crazy shit: https://stackoverflow.com/questions/12674783/bash-double-process-substitution-gives-bad-file-descriptor
  exec 3>&2
  for i in "$@"; do
    >&2 cc::console::"$(printf "$prefix" | tr '[:upper:]' '[:lower:]')" printf "$i"
  done
  exec 3>&-
}

cc::logger::level::set() {
  local level
  level="$(printf "%s" "${1:-}" | tr '[:upper:]' '[:lower:]')"

  case "$level" in
    ''|*[!0-9]*)
      case "$level" in
          "debug")
            _CC_PV_LOGGER_LEVEL=4
            ;;
          "info")
            _CC_PV_LOGGER_LEVEL=3
            ;;
          "warning")
            _CC_PV_LOGGER_LEVEL=2
            ;;
          "error")
            _CC_PV_LOGGER_LEVEL=1
            ;;
          "mute")
            _CC_PV_LOGGER_LEVEL=0
            ;;
          *)
            _CC_PV_LOGGER_LEVEL=3
            ;;
      esac
      ;;
    *)
      if [ "$level" -gt "$CC_LOGGER_DEBUG" ]; then
        return "$ERROR_FAILED"
      fi
      _CC_PV_LOGGER_LEVEL="$level"
      ;;
  esac

  [ "$_CC_PV_LOGGER_LEVEL" != "$CC_LOGGER_DEBUG" ] || {
    cc::console::warning printf "YOU ARE LOGGING AT THE DEBUG LEVEL."
    cc::console::warning printf "This is NOT recommended for production use, and WILL LIKELY LEAK sensitive information to logs."
  }
}

# Sugar
cc::logger::level::set::debug(){
  cc::logger::level::set "$CC_LOGGER_DEBUG"
}

cc::logger::level::set::info(){
  cc::logger::level::set "$CC_LOGGER_INFO"
}

cc::logger::level::set::warning(){
  cc::logger::level::set "$CC_LOGGER_WARNING"
}

cc::logger::level::set::error(){
  cc::logger::level::set "$CC_LOGGER_ERROR"
}

cc::logger::mute() {
  _CC_PV_LOGGER_LEVEL=0
}

cc::logger::ismute() {
  [ "$_CC_PV_LOGGER_LEVEL" == 0 ] || return "$ERROR_FAILED"
}

cc::logger::debug(){
  _cc_private::logger::log "DEBUG" "$@"
}

cc::logger::info(){
  _cc_private::logger::log "INFO" "$@"
}

cc::logger::warning(){
  _cc_private::logger::log "WARNING" "$@"
}

cc::logger::error(){
  _cc_private::logger::log "ERROR" "$@"
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Provides fancy display for `set -x`
#
# Depends on:
# defaults.sh
# colors.sh
# console.sh
########################################################################################################################

cc::codecomet::tracer(){
  local length="${#BASH_SOURCE[@]}"

  #local indent=""
  local linenumber
  local filename
  local filecontent
  local funcname
  local col

  [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[1]}" == *"action.sh" ]] || return 0

  printf "\n"

  for (( j=$(( length - 1 )); j>0; j-- )); do
    [ "$CC_TRACER_CODECOMET_INTERNALS" == "true" ] || [[ "${BASH_SOURCE[$j]}" == *"action.sh" ]] || {
      continue
    }

    linenumber="${BASH_LINENO[$(( j - 1 ))]}"
    filename="${BASH_SOURCE[$j]}"
    filecontent="$(cat -n "$filename" | grep -E "^\s+$linenumber\s" | sed -E "s/^\s+$linenumber\s+//")"
    funcname="${FUNCNAME[$j]}"

    # Why is this showing is a mystery for the times
    # [ "$filecontent" != "#!/usr/bin/env bash" ] || continue

    [ "$j" != 1 ] && {
      col="$CC_COLOR_DEFAULT_FRONT"
    } || {
      col="$CC_COLOR_TRACER_HUMPF"
    }

    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$filename"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$linenumber"
    _cc_private::console::inline "$col" "$CC_COLOR_DEFAULT_BACK" "function" printf "%-30s" "$funcname()"
    printf "\n"
    [ "$j" != 1 ] || {
      _cc_private::console "$CC_COLOR_TRACER_COMMAND_LABEL" "$CC_COLOR_DEFAULT_FRONT" "command" printf "%s" "$filecontent"
      _cc_private::console "$CC_COLOR_TRACER_OUTPUT_LABEL" "$CC_COLOR_DEFAULT_FRONT" "output" printf ""
    }

  done
}

cc::tracer::register(){
  # shellcheck disable=SC2016
  local ps=('$(' "$@" ')')
  export PS4="${ps[*]}"
}

cc::init::tracer(){
  cc::tracer::register cc::codecomet::tracer
}
#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor
########################################################################################################################
# Trap management
#
# Depends on:
# colors.sh
# console.sh
########################################################################################################################

_CC_PV_TRAP_LISTENERS=()

_CC_PV_ERR_LNO=
_CC_PV_ERR_CMD=
_CC_PV_ERR_STACK=
_CC_PV_ERR_EX=

dc::trap::register(){
  _CC_PV_TRAP_LISTENERS+=( "$1" )
}

# Trap lno and cmd on ERR for future use
cc::trap::err(){
  _CC_PV_ERR_EX="$1"
  _CC_PV_ERR_LNO="$2"
  _CC_PV_ERR_CMD="$3"
  _CC_PV_ERR_STACK="$4"
  # Dropping the rest of the stack?

  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "file   " printf "%-45s" "$_CC_PV_ERR_STACK"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "line" printf "%-9s" "#$_CC_PV_ERR_LNO"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "exit" printf "%s" "$_CC_PV_ERR_EX"
  >&2 printf "\n"
  >&2 _cc_private::console::inline "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "command" printf "%-30s" "$_CC_PV_ERR_CMD"
  >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
  >&2 printf "\n"

  >&2 _cc_private::console "$CC_COLOR_ERROR_FRONT" "$CC_COLOR_DEFAULT_BACK" "source" printf ""
  prefix=" "
  for (( j=$(( _CC_PV_ERR_LNO - 3 )); j<$(( _CC_PV_ERR_LNO + 3 )); j++ )); do
    [ "$j" -gt 0 ] || continue
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=">"
      >&2 _cc_private::tput setaf "$CC_COLOR_ERROR_FRONT"
      #>&2 _cc_private::tput bold
    fi
    #  | sed -E "s/^\s+$j\s//"
    >&2 printf "%s%s" "$prefix" "$(cat -n "$_CC_PV_ERR_STACK" | grep -E "^\s+$j\s")" || true
    if [ "$j" == "$_CC_PV_ERR_LNO" ]; then
      prefix=" "
      >&2 _cc_private::tput setaf "$CC_COLOR_DEFAULT_FRONT"
      #>&2 _cc_private::tput sgr0
    fi
    >&2 printf "\n"
  done
}

_CC_PV_NO_REENTRY=

# Trap exit for the actual cleanup
cc::trap::exit() {
  # { set +x; } 2>/dev/null

  local ex="$1"
  local i

  # Prevent reentrancy - XXX is this actually needed?
  [ ! "$_CC_PV_NO_REENTRY" ] || return 0
  _CC_PV_NO_REENTRY="exiting"

  printf "%s\n" "$ex" > "$CC_TMPFS"/.codecomet/logs/ex.log

  if [ "${#_CC_PV_TRAP_LISTENERS[@]}" -gt 0 ]; then
    for i in "${_CC_PV_TRAP_LISTENERS[@]}"; do
      cc::logger::debug "Calling exit hook $i"
#      >&2 printf "\n"
      "$i" "$ex" "$_CC_PV_ERR_CMD" "$_CC_PV_ERR_LNO" "$_CC_PV_ERR_STACK"
    done
  fi
  >&2 cc::console::reset
  >&2 printf "\n"
  cc::logger::debug "Exiting ($ex)"
  [ "$CC_ACTION_CAN_FAIL" == "true" ] && {
    [ "$ex" != "" ] || cc::logger::error "Action failed, but it is marked as 'can fail', so, exiting successfully"
    exit 0
  } || exit "$ex"
}

# Forking to disable xtrace when entering traps
cc::init::trap(){
  # Signals are caught by buildkit already - and only SIGKILL triggers a failure
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::err "$ex" "$LINENO" "$BASH_COMMAND" "${BASH_SOURCE[@]}"' ERR
  trap '{ ex=$?; set +x; } 2>/dev/null && cc::trap::exit "$ex"' EXIT
}

#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# See https://manpages.ubuntu.com/manpages/xenial/man1/eatmydata.1.html
# Technically, we get a 10% speedup with apt operations for eg
# XXX careful here if this is going to be used in a chroot
cc::init::speedup(){
  ! command -v eatmydata >/dev/null || export LD_PRELOAD=libeatmydata.so
}

# Boot if we have an argument - otherwise, we are being sourced
if [ "$#" -gt 0 ]; then
  mkdir -p "$TMPDIR"
  rm -Rf "$CC_TMPFS"/.codecomet
  mkdir -p "$CC_TMPFS"/.codecomet/bin
  mkdir -p "$CC_TMPFS"/.codecomet/logs

  # Set logger to env var from the Bash helper
  cc::logger::level::set "$CC_LOG_LEVEL"

  # Eat data, trap, register tracer, register debugger on exit trap
  cc::init::speedup
  cc::init::trap
  cc::init::tracer
  # Live debugger is really wonky
  if [ "${CC_DEBUGGER_LIVE:-}" != "" ]; then
    cc::debugger::live &
    dc::trap::register cc::debugger::front
  else
    [ "$CC_ACTION_CAN_FAIL" == true ] || dc::trap::register cc::debugger::start
  fi

  # XXX technically, we receive a bunch of scripts, and we could just play them all - use case is not completely clear yet
  out="$CC_TMPFS"/.codecomet/logs/stdout.log
  err="$CC_TMPFS"/.codecomet/logs/stderr.log

  # Unpack libraries path and source them
  while [ "$#" -gt 1 ]; do
    cp "$1" "$CC_TMPFS"/.codecomet/bin
    # shellcheck disable=SC1090
    source "$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
    shift
  done
  cp "$1" "$CC_TMPFS"/.codecomet/bin
  _CC_PV_SCRIPT="$CC_TMPFS"/.codecomet/bin/"$(basename "$1")"
  export _CC_PV_SCRIPT

  # Run the actual action
  # shellcheck disable=SC1090
  source "$_CC_PV_SCRIPT" > >(tee -a "$out") 2> >(tee -a "$err" >&2)
else
  # If we are a library, toss this one so we do not exit on any error...
  # This is especially important for the reverse debugger
  set +o errexit
fi
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
â"Ûˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*◊
/library0.sh¿∏#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# A generic lock mechanism that supports exclusive locks, shared locks, and a simplistic queueing mechanism
_cc_lockindex=9
_cc_lock_location="/_cc/share/locks"

# Sets our locks location. Must be called to guarantee that the lock location exist.
cc::lock::init(){
	_cc_lock_location="${1:-.}"
	mkdir -p "${_cc_lock_location}"
}

# Acquire a lock with a given name, and a share mode (shared or exclusive (which is the default))
# If the lock is already acquired in a different mode, or the mode is exclusive, the function will wait until the lock is released.
# Return the lock id that you need to carry around to release the lock later on.
cc::lock::acquire(){
	local lockfile="$_cc_lock_location/$1"
	local shared="${2:-}"
	[ "$shared" ] && shared=-s || shared=-x
	_cc_lockindex=$((_cc_lockindex+1))
	mkdir -p "$(dirname "$lockfile")"
	exec {_cc_lockindex}>"$lockfile"
	flock $shared $_cc_lockindex
	return $_cc_lockindex
}

# Release a previously acquire lock by its id
cc::lock::release(){
	local idx="$1"
	# This is essentially the same
	flock -u "$idx"
	# exec {idx}>&-
}

cc::lock::queue(){
	local basepath="${1:-.}"
	local shared1="${2:-}"
	local shared2="${3:-}"
	local qid
	local oid

	# Get into the queue first
	cc::lock::acquire "$basepath"/cc_queue.lock "$shared1" || qid=$?

	# Then when out of the queue, acquire an operation lock
	cc::lock::acquire "$basepath"/cc_op.lock "$shared2" || oid=$?

	# Now, leave the queue
	cc::lock::release $qid

	# Return the lock id
	return $oid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
˙"‰·ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*»
/library1.sh¿©#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Lessons learned:
# - find -exec is VERY SLOW - better off piping to read (almost 10x) (0.2 second vs 0.02 second for about 200 files)
# - then globbing and grepping is faster than find + read
# This matters not in case we are copying a large amount of data of course, but then
# - there is no way to get something stable out of ls without further processing - directories with different owners
# for eg will widen some columns
# this "works" right now (if we do not use --numeric-uid-gid) but will be problematic outside of this specific case

_cc::fingerprint(){
  local directory="$1"
  # Will fail if the directory is empty, so the guardrail
  # Ignore directories, links, and "total" (note: -d will not work for that)
  # --numeric-uid-gid < messes up the output width
  # shellcheck disable=SC2010
  ls --full-time --almost-all --ignore lock "$directory" 2>/dev/null | grep -v "^[d|l|t]" || true
}

# Copy or symlink data "from" storage "to" destination
# This assume that storage holds only files, and no lock
# Will not copy anything if there is no difference
cc::storage::retrieve(){
  local from="$1"
  local to="$2"
  local copy="${3:-}"
  local lid
  local fromState

  # Ensure destination exists
  mkdir -p "$to"

  # Lock origin and keep the lock id
  cc::lock::acquire "$from" shared || lid=$?

  # Ensure origin exists
  mkdir -p "$from"

  # If we are asked to copy (not expected for large amount of data - linking is prefered in that case)
  if [ "$copy" ]; then
    # Retrieve the state of it
    fromState="$(_cc::fingerprint "$from")"

    # Check that we have content in storage
    # Check that we have a difference between storage and destination (ignoring directories and lock file)
    # shellcheck disable=SC2010
    # shellcheck disable=SC2015
    [ "$fromState" ] && [ "$fromState" != "$(_cc::fingerprint "$to")" ] && {
      # Then cleanup destination
      rm -Rf "$to"
      mkdir -p "$to"
      # And copy over
      cp -p "$from"/* "$to"
      # Slower
      #find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
      #  cp -p "$fd" "$to"
      #done
    } || {
      # Otherwise, do nothing
      cc::logger::debug "Nothing to retrieve from storage"
    }
  else
    # We want links, so, lets check we have anything in the origin
    #[ ! "$fromState" ] || {
    # Get rid of possibly remaining files in our destination
    find "$to" -type f -delete
    ln -sf "$from"/* "$to" 2>/dev/null || true
    # Note: below is slower
    # find "$from" -type f -not -iname lock -print0 | while IFS= read -r -d $'\0' fd; do
    #  ln -s "$fd" "$to"
    # done
    #}
  fi

  # Release the lock
	cc::lock::release $lid
}

cc::storage::store(){
  local from="$1"
  local to="$2"
  local erase="${3:-}"
  local lid
  local fd
  local toState

  # Ensure origin exists
  mkdir -p "$from"

  # Lock destination and keep the lock id
  cc::lock::acquire "$to" "" || lid=$?

  # Ensure destination exists
  mkdir -p "$to"
  # Retrieve the state of it
  # shellcheck disable=SC2010
  toState="$(_cc::fingerprint "$to")"

  # Compare state of the destination with the origin (origin ignores directories and lock files)
  # shellcheck disable=SC2010
  # shellcheck disable=SC2015
  [ "$toState" != "$(_cc::fingerprint "$from")" ] && {
    # We have changes - if asked to wipe out, do so
    if [ "$erase" ]; then
      rm -Rf "$to"
      mkdir -p "$to"
    fi
    # Now copy the files
    # This is probably slow-ish. The question is: will it be significant in a context where copy IO is the bottleneck?
    find "$from" -type f -not -iname "lock" -print0 | while IFS= read -r -d $'\0' fd; do
      cp -p "$fd" "$to"
    done
  } || {
    cc::logger::debug "Nothing to save to storage"
  }

  # Release the lock
	cc::lock::release $lid
}
(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
Ï*"÷*”*ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∫*
/library2.sh¿õ*#!/usr/bin/env bash
set -o errexit -o errtrace -o functrace -o nounset -o pipefail -o monitor

# Helpers to allow apt to share cache properly

# Private tmpfs location
_cc_tmpfs_location=/codecomet/apt-get-private/tmp

# Location of the list cache
_cc_apt_list_store_location=/codecomet/apt-get-shared/lists
# And pack cache
_cc_apt_pack_local_location=/codecomet/apt-get-shared/packs

# Location of the packages cache
_cc_apt_pack_store_location=/codecomet/apt-get-shared/cache

# Location of our private lists files - by default, Debian normal location, which means state will persist
_cc_apt_list_local_location=/var/lib/apt/lists

# Location of the config file
export APT_CONFIG=$_cc_tmpfs_location/apt-get.conf

# Hash of the sources.list, which dictates the cache location to share
# Different sources means different cache location
# Caveats: this will likely not work with a future debian release as they change the sources.list format
# XXX this wracking the debugger output
cc::apt_get::shard(){
  sha256sum <<< "$(uname -m)$(grep --no-filename -Ev "^#" /etc/apt/sources.list /etc/apt/sources.list.d/* 2>/dev/null | sed -E 's/#.+$//' | sort || true)" | sed -E 's/  .*//'
}

# Set the tmp location, initiliaze APT_CONFIG and shared and private locations
cc::apt_get::init(){
  # Get the desired tmpfs mount point
  _cc_tmpfs_location="$1"

  mkdir -p "$_cc_tmpfs_location"

  # Point configuration there
  export APT_CONFIG="$_cc_tmpfs_location"/apt-get.conf

  # Sharding by sources list content, cleaned-up and sorted to maximize cache hits
	_cc_apt_list_store_location="$2/$(cc::apt_get::shard)"

  # Technically, we should not be sharding the architecture
  # But then, the only upside would be when installing cross-arch packages
	_cc_apt_pack_store_location="$3/$(cc::apt_get::shard)"

  # If we do not want lists to persist, use the tmp storage
  [ "${4:-}" == true ] || _cc_apt_list_local_location="$_cc_tmpfs_location"/lists

  # Finally, local pack location
  _cc_apt_pack_local_location="$_cc_tmpfs_location"/packs

  # Make sure they all exist
  mkdir -p "$_cc_apt_list_local_location"
  mkdir -p "$_cc_apt_pack_local_location"

  mkdir -p "$_cc_apt_list_store_location"
  mkdir -p "$_cc_apt_pack_store_location"
}

# Create the configuration file for APT
cc::apt_get::configure(){
  local config_extra="${1:-}"
  local persist="${2:-}"

  mkdir -p "$_cc_tmpfs_location/logs"
  cat << EOF > "$APT_CONFIG"
# Divert both lists and archives location
Dir::Cache::Archives "$_cc_apt_pack_local_location";
Dir::State::Lists "$_cc_apt_list_local_location";
# Prevent the default apt config to be used
Dir::Etc::parts "";
# Put the logs in the tmp zone
Dir::Log "$_cc_tmpfs_location/logs";
# Put the bin cache files in the private mount
Dir::Cache::srcpkgcache "$_cc_tmpfs_location/srcpkgcache.bin";
Dir::Cache::pkgcache "$_cc_tmpfs_location/pkgcache.bin";

$config_extra
EOF

  # If asked to persist the config, copy over the generated file
  [ "$persist" == "false" ] || cp "$APT_CONFIG" /etc/apt/apt.conf
}

#cc::apt_get::cleanup(){
  # This is only necessary if we were not using an tmpfs mount...
  # rm "$APT_CONFIG"
#}

cc::apt_get::update(){
  # Remove our marker if here
  rm -f "$_cc_apt_list_local_location"/.cc_updated

  # Retrieve existing data
  cc::storage::retrieve "$_cc_apt_list_store_location" "$_cc_apt_list_local_location" copy

	# Do the deed, same restriction applies
	apt-get update "$@"

  # Save it back (storage will decide)
  cc::storage::store "$_cc_apt_list_local_location" "$_cc_apt_list_store_location" erase

  # Now, flag it
  date > "$_cc_apt_list_local_location"/.cc_updated
}

cc::apt_get::do(){
  # Bring in any cache
  cc::storage::retrieve "$_cc_apt_pack_store_location" "$_cc_apt_pack_local_location"

	apt-get "$@"

  # Store the packages permanently
  cc::storage::store "$_cc_apt_pack_local_location" "$_cc_apt_pack_store_location"
}

# XXX what if sources are being modified, or config, or something else that materially impacts update?
cc::high::update(){
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "$nooutput"

  args+=("$@")
  time cc::apt_get::update "${args[@]}"
}

cc::high::install(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists has been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  args+=("$@")
  time cc::apt_get::do install "${args[@]}"
}

cc::high::upgrade(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")
  # Do have a marker indicating that the lists have been kept around?
  # If not, then force update
  [ -e "$_cc_apt_list_local_location"/.cc_updated ] || time cc::apt_get::update "${args[@]}"

  # ls -lAR "$_cc_tmpfs_location"/packs || true
  # time cc::apt_get::do upgrade "$nooutput" "$@"

  # XXX WIP here
  # Bust cache - delete this
  #time cc::apt_get::do upgrade --download-only "$nooutput" "$@"
  #time cc::apt_get::do upgrade --no-download "$nooutput" "$@"
  args+=("$@")
  time cc::apt_get::do upgrade "${args[@]}"
}

cc::high::purge(){
  local args=()
  [ "$_CC_PV_LOGGER_LEVEL" == "$CC_LOGGER_DEBUG" ] || args=("-qq")

  args+=("$@")
  time cc::apt_get::do purge --auto-remove "${args[@]}"
}(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
’"øºˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*£

/action.sh¿Ü#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::upgrade

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f7942
 



Z 
•
I
Gsha256:1fbbc4badd25a127fd4fadc9695046d27c048e2401041b62bedf36d229e45f77
I
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
armlinuxv7Z 
Í"‘—ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ*∏

/action.sh¿õ#!/usr/bin/env bash
set +o allexport -o braceexpand -o emacs -o errexit -o errtrace -o functrace -o hashall +o histexpand +o history +o ignoreeof -o interactive-comments +o keyword -o monitor +o noclobber +o noexec +o noglob +o nolog +o notify -o nounset +o onecmd +o physical -o pipefail +o posix +o privileged +o verbose +o xtrace


cc::lock::init "/_cc/share/apt/locks"
cc::apt_get::init "$CC_TMPFS" "/_cc/share/apt/lists" "/_cc/share/apt/packs" false

cc::apt_get::configure 'APT::AutoRemove::SuggestsImportant "false";
APT::Install-Recommends "false";
APT::Get::Assume-Yes "true";
Acquire::http::User-Agent "codecomet/mark-I";
Acquire::Check-Valid-Until "false";
Acquire::GzipIndexes "false";
Acquire::Languages "";
;
' false

# Run the command
cc::high::install eatmydata nano socat

# Cleanup
## Only there when installing
rm -f /var/cache/ldconfig/aux-cache
rm -f /var/log/dpkg.log
rm -f /var/log/alternatives.log

(ˇˇˇˇˇˇˇˇˇR
arm64darwinZ 
ç
I
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962
I
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c
I
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7
I
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f
I
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c2
 



Z 
•
I
Gsha256:55ec848cf7d65106bee358f2ac6a5bba29563bf30924f0ee03dac01e2cbbc43e
I
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf¯
È
/_cc/state/bash/codecomet
/_cc/state/bash/library0.sh
/_cc/state/bash/library1.sh
/_cc/state/bash/library2.sh
/_cc/state/bash/action.shCC_ACTION_CAN_FAIL=falseCC_DEBUGGER_GRACE=CC_DEBUGGER_IP=10.0.0.91CC_DEBUGGER_LIVE=CC_DEBUGGER_PORT=6666CC_LOG_LEVEL=CC_TMPFS=/codecometCC_TRACER_CODECOMET_INTERNALS=DEBIAN_FRONTEND=noninteractiveLANG=C.UTF-8LC_ALL=C.UTF-8	NO_COLOR=
TERM=xtermTMPDIR=/codecomet/tmpTZ=America/Los_Angeles/codecomet/tmp:codecomet-bashX/hˇˇˇˇˇˇˇˇˇ/_cc/share/apt ˇˇˇˇˇˇˇˇˇ0¢=
;apt-get shared storage, including locks, lists and packages//_cc/state/bash -ˇˇˇˇˇˇˇˇˇ
/codecomet ˇˇˇˇˇˇˇˇˇ0öÄÄÄÄ-ˇˇˇˇˇˇˇˇˇ//codecomet/input ˇˇˇˇˇˇˇˇˇ(#ˇˇˇˇˇˇˇˇˇ//codecomet/output R
armlinuxv7Z 
K
I
Gsha256:7d56e94b3beb356751a3e6f559295c2e360361498efd4103e6dd6dc5063a8e84Ë
Gsha256:1fbbc4badd25a127fd4fadc9695046d27c048e2401041b62bedf36d229e45f77ú!
codecomet.optest codecomet opG
llb.customname5[source:image] docker.io/library/debian:bullseye-slim*
source.image*
source.image.resolvemodeü
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library2.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library1.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupπ
Gsha256:55ec848cf7d65106bee358f2ac6a5bba29563bf30924f0ee03dac01e2cbbc43eÌ!
codecomet.optest codecomet op!
llb.customnameapt-get upgrade*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeŒ
Gsha256:7d56e94b3beb356751a3e6f559295c2e360361498efd4103e6dd6dc5063a8e84Ç!
codecomet.optest codecomet op6
llb.customname$apt-get install eatmydata nano socat*
exec.meta.base*
exec.mount.bind*
exec.mount.cache*
exec.mount.cache.sharing*
exec.mount.selector*
exec.mount.tmpfs*
exec.mount.tmpfs.sizeù
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962—!
codecomet.optest codecomet op0
llb.customname[action:addfile] codecomet in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupê
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edfƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupü
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c”!
codecomet.optest codecomet op2
llb.customname [action:addfile] library0.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupù
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794—!
codecomet.optest codecomet op0
llb.customname[action:addfile] action.sh in *
	file.base2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupÄ
Gsha256:d8bbf2a7da2fc3ca36bc870ec340d424817c686cb2f622f469f5329d4532732b5*
constraints*
meta.description*
platformê
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8aƒ!
codecomet.optest codecomet op%
llb.customname[action:merge]     *
mergeop2k
B2aa6f7c90065d8da445fb1245a399727883e139844ce1d8eb00f8f6a0f0a8e3c-0#CodeComet internal operations groupœ
K
Gsha256:1fbbc4badd25a127fd4fadc9695046d27c048e2401041b62bedf36d229e45f77 
K
Gsha256:386948484449889faa6e53fdeab0ffe574592271fe7837cfb4d4c7956e68536f 
K
Gsha256:40d45dbee0e5b82ebfff8280c9228685e183a1d0fce870788d45ed91782209e7 
K
Gsha256:55ec848cf7d65106bee358f2ac6a5bba29563bf30924f0ee03dac01e2cbbc43e 
K
Gsha256:7d56e94b3beb356751a3e6f559295c2e360361498efd4103e6dd6dc5063a8e84 
K
Gsha256:a5cdfddeb97be71e3359d61e8210c54fe3d67454a0caa9b9f76eefdf9c914962 
K
Gsha256:a9794a51203259ff17811a9b0977255dd4569259a22385e45ac701672f89bc6c 
K
Gsha256:b6b183f954966a5bf87d9e9c3b2d00d660adf3e3fcb4a682905acc8741f46edf 
K
Gsha256:bb5403fcb112974cc7c2d909b4dc7206231d7dc04c891718ffcd986d93695e8c 
K
Gsha256:bf638a8cd32a455b30a7f5dceaf1e6d48b0f8b1f103239a22f8784ac64c2f794 
K
Gsha256:e069c7dc66e4fc362a7060091ab143381beaece7e780c4e0c759b7567537ed8a 